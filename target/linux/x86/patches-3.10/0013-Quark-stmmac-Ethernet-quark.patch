From xxxx Mon Sep 17 00:00:00 2001
From: Krzysztof Sywula <krzysztof.m.sywula@intel.com>
Date: Thu, 20 Feb 2014 15:16:30 +0000
Subject: [PATCH 13/21] Quark stmmac Ethernet

---
 drivers/net/ethernet/stmicro/stmmac/Kconfig        |   25 +-
 drivers/net/ethernet/stmicro/stmmac/Makefile       |    1 +
 drivers/net/ethernet/stmicro/stmmac/common.h       |   14 +-
 drivers/net/ethernet/stmicro/stmmac/descs.h        |   45 ++-
 drivers/net/ethernet/stmicro/stmmac/dwmac1000.h    |   64 ++-
 .../net/ethernet/stmicro/stmmac/dwmac1000_core.c   |  139 ++++-
 .../net/ethernet/stmicro/stmmac/dwmac1000_dma.c    |    9 +-
 .../net/ethernet/stmicro/stmmac/dwmac100_core.c    |    6 +-
 drivers/net/ethernet/stmicro/stmmac/mmc_core.c     |    1 +
 drivers/net/ethernet/stmicro/stmmac/stmmac.h       |   76 ++
 .../net/ethernet/stmicro/stmmac/stmmac_ethtool.c   |   21 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |  163 ++++-
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |  263 +++++++-
 drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c   |  723 ++++++++++++++++++++
 14 files changed, 1476 insertions(+), 74 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 1164930..c959209 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -1,11 +1,10 @@
 config STMMAC_ETH
 	tristate "STMicroelectronics 10/100/1000 Ethernet driver"
-	depends on HAS_IOMEM && HAS_DMA
+	depends on HAS_IOMEM
 	select NET_CORE
 	select MII
 	select PHYLIB
 	select CRC32
-	select PTP_1588_CLOCK
 	---help---
 	  This is the driver for the Ethernet IPs are built around a
 	  Synopsys IP Core and only tested on the STMicroelectronics
@@ -55,4 +54,43 @@
 	  By default, the DMA arbitration scheme is based on Round-robin
 	  (rx:tx priority is 1:1).
 
+config STMMAC_PTP
+	bool "STMMAC PTP (1588-2005) Clock Support"
+	default n
+	depends on EXPERIMENTAL
+	select PPS
+	select PTP_1588_CLOCK
+	---help---
+	  Say Y here if you want support for 1588 Timestamping with a
+	  Quark device, using the PTP 1588 Clock support. This is
+	  required to enable timestamping support for the device.
+
+	  If unsure, say N.
+
+config STMMAC_PTP_CLK_MHZ
+	depends on STMMAC_PTP
+	int "Reference clock in Mhz"
+	default 50
+	---help---
+	  Frequency if MHz of the reference clock used to derive PTP time
+	  locally. Permissable values are 1 - 255 inclusive
+
+choice
+	prompt "Select the DMA TX/RX descriptor operating modes"
+	depends on STMMAC_ETH
+	---help---
+	  This driver supports DMA descriptor to operate both in dual buffer
+	  (RING) and linked-list(CHAINED) mode. In RING mode each descriptor
+	  points to two data buffer pointers whereas in CHAINED mode they
+	  points to only one data buffer pointer.
+
+config STMMAC_RING
+	bool "Enable Descriptor Ring Mode"
+
+config STMMAC_CHAINED
+	bool "Enable Descriptor Chained Mode"
+
+endchoice
+
+
 endif
diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
index c8e8ea6..0995db5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -1,7 +1,10 @@
 obj-$(CONFIG_STMMAC_ETH) += stmmac.o
+stmmac-$(CONFIG_STMMAC_RING) += ring_mode.o
+stmmac-$(CONFIG_STMMAC_CHAINED) += chain_mode.o
 stmmac-$(CONFIG_STMMAC_PLATFORM) += stmmac_platform.o
 stmmac-$(CONFIG_STMMAC_PCI) += stmmac_pci.o
-stmmac-objs:= stmmac_main.o stmmac_ethtool.o stmmac_mdio.o ring_mode.o	\
-	      chain_mode.o dwmac_lib.o dwmac1000_core.o  dwmac1000_dma.o \
+stmmac-$(CONFIG_STMMAC_PTP) += stmmac_ptp.o
+stmmac-objs:= stmmac_main.o stmmac_ethtool.o stmmac_mdio.o	\
+	      dwmac_lib.o dwmac1000_core.o  dwmac1000_dma.o	\
 	      dwmac100_core.o dwmac100_dma.o enh_desc.o  norm_desc.o \
-	      mmc_core.o stmmac_hwtstamp.o stmmac_ptp.o $(stmmac-y)
+	      mmc_core.o $(stmmac-y)
diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 186d148..ad16e73 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -32,9 +32,15 @@
 #include <linux/init.h>
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 #define STMMAC_VLAN_TAG_USED
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+#define STMMAC_VLAN_HASH
+#endif
 #include <linux/if_vlan.h>
 #endif
 
+#if defined(STMMAC_VLAN_HASH) || defined(CONFIG_STMMAC_PTP)
+#define STMMAC_ATDS_USED
+#endif
 #include "descs.h"
 #include "mmc.h"
 
@@ -117,36 +123,6 @@
 	unsigned long irq_rx_path_in_lpi_mode_n;
 	unsigned long irq_rx_path_exit_lpi_mode_n;
 	unsigned long phy_eee_wakeup_error_n;
-	/* Extended RDES status */
-	unsigned long ip_hdr_err;
-	unsigned long ip_payload_err;
-	unsigned long ip_csum_bypassed;
-	unsigned long ipv4_pkt_rcvd;
-	unsigned long ipv6_pkt_rcvd;
-	unsigned long rx_msg_type_ext_no_ptp;
-	unsigned long rx_msg_type_sync;
-	unsigned long rx_msg_type_follow_up;
-	unsigned long rx_msg_type_delay_req;
-	unsigned long rx_msg_type_delay_resp;
-	unsigned long rx_msg_type_pdelay_req;
-	unsigned long rx_msg_type_pdelay_resp;
-	unsigned long rx_msg_type_pdelay_follow_up;
-	unsigned long ptp_frame_type;
-	unsigned long ptp_ver;
-	unsigned long timestamp_dropped;
-	unsigned long av_pkt_rcvd;
-	unsigned long av_tagged_pkt_rcvd;
-	unsigned long vlan_tag_priority_val;
-	unsigned long l3_filter_match;
-	unsigned long l4_filter_match;
-	unsigned long l3_l4_filter_no_match;
-	/* PCS */
-	unsigned long irq_pcs_ane_n;
-	unsigned long irq_pcs_link_n;
-	unsigned long irq_rgmii_n;
-	unsigned long pcs_link;
-	unsigned long pcs_duplex;
-	unsigned long pcs_speed;
 };
 
 /* CSR Frequency Access Defines*/
@@ -168,43 +144,37 @@
 #define FLOW_TX		2
 #define FLOW_AUTO	(FLOW_TX | FLOW_RX)
 
-/* PCS defines */
-#define STMMAC_PCS_RGMII	(1 << 0)
-#define STMMAC_PCS_SGMII	(1 << 1)
-#define STMMAC_PCS_TBI		(1 << 2)
-#define STMMAC_PCS_RTBI		(1 << 3)
-
-#define SF_DMA_MODE 1		/* DMA STORE-AND-FORWARD Operation Mode */
+#define SF_DMA_MODE 1 /* DMA STORE-AND-FORWARD Operation Mode */
 
 /* DAM HW feature register fields */
-#define DMA_HW_FEAT_MIISEL	0x00000001	/* 10/100 Mbps Support */
-#define DMA_HW_FEAT_GMIISEL	0x00000002	/* 1000 Mbps Support */
-#define DMA_HW_FEAT_HDSEL	0x00000004	/* Half-Duplex Support */
-#define DMA_HW_FEAT_EXTHASHEN	0x00000008	/* Expanded DA Hash Filter */
-#define DMA_HW_FEAT_HASHSEL	0x00000010	/* HASH Filter */
-#define DMA_HW_FEAT_ADDMAC	0x00000020	/* Multiple MAC Addr Reg */
-#define DMA_HW_FEAT_PCSSEL	0x00000040	/* PCS registers */
-#define DMA_HW_FEAT_L3L4FLTREN	0x00000080	/* Layer 3 & Layer 4 Feature */
-#define DMA_HW_FEAT_SMASEL	0x00000100	/* SMA(MDIO) Interface */
-#define DMA_HW_FEAT_RWKSEL	0x00000200	/* PMT Remote Wakeup */
-#define DMA_HW_FEAT_MGKSEL	0x00000400	/* PMT Magic Packet */
-#define DMA_HW_FEAT_MMCSEL	0x00000800	/* RMON Module */
-#define DMA_HW_FEAT_TSVER1SEL	0x00001000	/* Only IEEE 1588-2002 */
-#define DMA_HW_FEAT_TSVER2SEL	0x00002000	/* IEEE 1588-2008 PTPv2 */
-#define DMA_HW_FEAT_EEESEL	0x00004000	/* Energy Efficient Ethernet */
-#define DMA_HW_FEAT_AVSEL	0x00008000	/* AV Feature */
-#define DMA_HW_FEAT_TXCOESEL	0x00010000	/* Checksum Offload in Tx */
-#define DMA_HW_FEAT_RXTYP1COE	0x00020000	/* IP COE (Type 1) in Rx */
-#define DMA_HW_FEAT_RXTYP2COE	0x00040000	/* IP COE (Type 2) in Rx */
-#define DMA_HW_FEAT_RXFIFOSIZE	0x00080000	/* Rx FIFO > 2048 Bytes */
-#define DMA_HW_FEAT_RXCHCNT	0x00300000	/* No. additional Rx Channels */
-#define DMA_HW_FEAT_TXCHCNT	0x00c00000	/* No. additional Tx Channels */
-#define DMA_HW_FEAT_ENHDESSEL	0x01000000	/* Alternate Descriptor */
-/* Timestamping with Internal System Time */
-#define DMA_HW_FEAT_INTTSEN	0x02000000
-#define DMA_HW_FEAT_FLEXIPPSEN	0x04000000	/* Flexible PPS Output */
-#define DMA_HW_FEAT_SAVLANINS	0x08000000	/* Source Addr or VLAN */
-#define DMA_HW_FEAT_ACTPHYIF	0x70000000	/* Active/selected PHY iface */
+#define DMA_HW_FEAT_MIISEL	0x00000001 /* 10/100 Mbps Support */
+#define DMA_HW_FEAT_GMIISEL	0x00000002 /* 1000 Mbps Support */
+#define DMA_HW_FEAT_HDSEL	0x00000004 /* Half-Duplex Support */
+#define DMA_HW_FEAT_EXTHASHEN	0x00000008 /* Expanded DA Hash Filter */
+#define DMA_HW_FEAT_HASHSEL	0x00000010 /* HASH Filter */
+#define DMA_HW_FEAT_ADDMACADRSEL	0x00000020 /* Multiple MAC Addr Reg */
+#define DMA_HW_FEAT_PCSSEL	0x00000040 /* PCS registers */
+#define DMA_HW_FEAT_L3L4FLTREN	0x00000080 /* Layer 3 & Layer 4 Feature */
+#define DMA_HW_FEAT_SMASEL	0x00000100 /* SMA(MDIO) Interface */
+#define DMA_HW_FEAT_RWKSEL	0x00000200 /* PMT Remote Wakeup */
+#define DMA_HW_FEAT_MGKSEL	0x00000400 /* PMT Magic Packet */
+#define DMA_HW_FEAT_MMCSEL	0x00000800 /* RMON Module */
+#define DMA_HW_FEAT_TSVER1SEL	0x00001000 /* Only IEEE 1588-2002 Timestamp */
+#define DMA_HW_FEAT_TSVER2SEL	0x00002000 /* IEEE 1588-2008 Adv Timestamp */
+#define DMA_HW_FEAT_EEESEL	0x00004000 /* Energy Efficient Ethernet */
+#define DMA_HW_FEAT_AVSEL	0x00008000 /* AV Feature */
+#define DMA_HW_FEAT_TXCOESEL	0x00010000 /* Checksum Offload in Tx */
+#define DMA_HW_FEAT_RXTYP1COE	0x00020000 /* IP csum Offload(Type 1) in Rx */
+#define DMA_HW_FEAT_RXTYP2COE	0x00040000 /* IP csum Offload(Type 2) in Rx */
+#define DMA_HW_FEAT_RXFIFOSIZE	0x00080000 /* Rx FIFO > 2048 Bytes */
+#define DMA_HW_FEAT_RXCHCNT	0x00300000 /* No. of additional Rx Channels */
+#define DMA_HW_FEAT_TXCHCNT	0x00c00000 /* No. of additional Tx Channels */
+#define DMA_HW_FEAT_ENHDESSEL	0x01000000 /* Alternate (Enhanced Descriptor) */
+#define DMA_HW_FEAT_INTTSEN	0x02000000 /* Timestamping with Internal
+					      System Time */
+#define DMA_HW_FEAT_FLEXIPPSEN	0x04000000 /* Flexible PPS Output */
+#define DMA_HW_FEAT_SAVLANINS	0x08000000 /* Source Addr or VLAN Insertion */
+#define DMA_HW_FEAT_ACTPHYIF	0x70000000 /* Active/selected PHY interface */
 #define DEFAULT_DMA_PBL		8
 
 /* Max/Min RI Watchdog Timer count value */
@@ -216,8 +186,7 @@
 #define STMMAC_TX_MAX_FRAMES	256
 #define STMMAC_TX_FRAMES	64
 
-/* Rx IPC status */
-enum rx_frame_status {
+enum rx_frame_status { /* IPC status */
 	good_frame = 0,
 	discard_frame = 1,
 	csum_none = 2,
@@ -231,25 +200,17 @@
 	handle_tx = 0x8,
 };
 
-#define	CORE_IRQ_TX_PATH_IN_LPI_MODE	(1 << 1)
-#define	CORE_IRQ_TX_PATH_EXIT_LPI_MODE	(1 << 2)
-#define	CORE_IRQ_RX_PATH_IN_LPI_MODE	(1 << 3)
-#define	CORE_IRQ_RX_PATH_EXIT_LPI_MODE	(1 << 4)
-
-#define	CORE_PCS_ANE_COMPLETE		(1 << 5)
-#define	CORE_PCS_LINK_STATUS		(1 << 6)
-#define	CORE_RGMII_IRQ			(1 << 7)
-
-struct rgmii_adv {
-	unsigned int pause;
-	unsigned int duplex;
-	unsigned int lp_pause;
-	unsigned int lp_duplex;
+enum core_specific_irq_mask {
+	core_mmc_tx_irq = 1,
+	core_mmc_rx_irq = 2,
+	core_mmc_rx_csum_offload_irq = 4,
+	core_irq_receive_pmt_irq = 8,
+	core_irq_tx_path_in_lpi_mode = 16,
+	core_irq_tx_path_exit_lpi_mode = 32,
+	core_irq_rx_path_in_lpi_mode = 64,
+	core_irq_rx_path_exit_lpi_mode = 128,
 };
 
-#define STMMAC_PCS_PAUSE	1
-#define STMMAC_PCS_ASYM_PAUSE	2
-
 /* DMA HW capabilities */
 struct dma_features {
 	unsigned int mbps_10_100;
@@ -262,9 +223,9 @@
 	unsigned int pmt_remote_wake_up;
 	unsigned int pmt_magic_frame;
 	unsigned int rmon;
-	/* IEEE 1588-2002 */
+	/* IEEE 1588-2002*/
 	unsigned int time_stamp;
-	/* IEEE 1588-2008 */
+	/* IEEE 1588-2008*/
 	unsigned int atime_stamp;
 	/* 802.3az - Energy-Efficient Ethernet (EEE) */
 	unsigned int eee;
@@ -277,7 +238,7 @@
 	/* TX and RX number of channels */
 	unsigned int number_rx_channel;
 	unsigned int number_tx_channel;
-	/* Alternate (enhanced) DESC mode */
+	/* Alternate (enhanced) DESC mode*/
 	unsigned int enh_desc;
 };
 
@@ -297,29 +258,26 @@
 #define MAC_RNABLE_RX		0x00000004	/* Receiver Enable */
 
 /* Default LPI timers */
-#define STMMAC_DEFAULT_LIT_LS	0x3E8
-#define STMMAC_DEFAULT_TWT_LS	0x0
-
-#define STMMAC_CHAIN_MODE	0x1
-#define STMMAC_RING_MODE	0x2
+#define STMMAC_DEFAULT_LIT_LS_TIMER	0x3E8
+#define STMMAC_DEFAULT_TWT_LS_TIMER	0x0
 
 struct stmmac_desc_ops {
 	/* DMA RX descriptor ring initialization */
-	void (*init_rx_desc) (struct dma_desc *p, int disable_rx_ic, int mode,
-			      int end);
+	void (*init_rx_desc) (struct dma_desc *p, unsigned int ring_size,
+			      int disable_rx_ic);
 	/* DMA TX descriptor ring initialization */
-	void (*init_tx_desc) (struct dma_desc *p, int mode, int end);
+	void (*init_tx_desc) (struct dma_desc *p, unsigned int ring_size);
 
 	/* Invoked by the xmit function to prepare the tx descriptor */
 	void (*prepare_tx_desc) (struct dma_desc *p, int is_fs, int len,
-				 int csum_flag, int mode);
+				 int csum_flag);
 	/* Set/get the owner of the descriptor */
 	void (*set_tx_owner) (struct dma_desc *p);
 	int (*get_tx_owner) (struct dma_desc *p);
 	/* Invoked by the xmit function to close the tx descriptor */
 	void (*close_tx_desc) (struct dma_desc *p);
 	/* Clean the tx descriptor as soon as the tx irq is received */
-	void (*release_tx_desc) (struct dma_desc *p, int mode);
+	void (*release_tx_desc) (struct dma_desc *p);
 	/* Clear interrupt on tx frame completion. When this bit is
 	 * set an interrupt happens as soon as the frame is transmitted */
 	void (*clear_tx_ic) (struct dma_desc *p);
@@ -338,22 +296,12 @@
 	/* Return the reception status looking at the RDES1 */
 	int (*rx_status) (void *data, struct stmmac_extra_stats *x,
 			  struct dma_desc *p);
-	void (*rx_extended_status) (void *data, struct stmmac_extra_stats *x,
-				    struct dma_extended_desc *p);
-	/* Set tx timestamp enable bit */
-	void (*enable_tx_timestamp) (struct dma_desc *p);
-	/* get tx timestamp status */
-	int (*get_tx_timestamp_status) (struct dma_desc *p);
-	/* get timestamp value */
-	 u64(*get_timestamp) (void *desc, u32 ats);
-	/* get rx timestamp status */
-	int (*get_rx_timestamp_status) (void *desc, u32 ats);
 };
 
 struct stmmac_dma_ops {
 	/* DMA core initialization */
 	int (*init) (void __iomem *ioaddr, int pbl, int fb, int mb,
-		     int burst_len, u32 dma_tx, u32 dma_rx, int atds);
+		     int burst_len, u32 dma_tx, u32 dma_rx);
 	/* Dump DMA registers */
 	void (*dump_regs) (void __iomem *ioaddr);
 	/* Set tx/rx threshold in the csr6 register
@@ -377,16 +325,16 @@
 	void (*rx_watchdog) (void __iomem *ioaddr, u32 riwt);
 };
 
+struct stmmac_priv;
 struct stmmac_ops {
 	/* MAC core initialization */
-	void (*core_init) (void __iomem *ioaddr);
+	void (*core_init) (void __iomem *ioaddr) ____cacheline_aligned;
 	/* Enable and verify that the IPC module is supported */
-	int (*rx_ipc) (void __iomem *ioaddr);
+	int (*set_rx_ipc) (void __iomem *ioaddr, bool on);
 	/* Dump MAC registers */
 	void (*dump_regs) (void __iomem *ioaddr);
 	/* Handle extra events on specific interrupts hw dependent */
-	int (*host_irq_status) (void __iomem *ioaddr,
-				struct stmmac_extra_stats *x);
+	int (*host_irq_status) (struct stmmac_priv * priv);
 	/* Multicast filter setting */
 	void (*set_filter) (struct net_device *dev, int id);
 	/* Flow control setting */
@@ -399,22 +347,13 @@
 			       unsigned int reg_n);
 	void (*get_umac_addr) (void __iomem *ioaddr, unsigned char *addr,
 			       unsigned int reg_n);
+	/* Enable/Disable VLAN Hash filters */
+	int (*vlan_rx_add_vid)(struct stmmac_priv *priv, unsigned short vid);
+	int (*vlan_rx_kill_vid)(struct stmmac_priv *priv, unsigned short vid);
 	void (*set_eee_mode) (void __iomem *ioaddr);
 	void (*reset_eee_mode) (void __iomem *ioaddr);
 	void (*set_eee_timer) (void __iomem *ioaddr, int ls, int tw);
 	void (*set_eee_pls) (void __iomem *ioaddr, int link);
-	void (*ctrl_ane) (void __iomem *ioaddr, bool restart);
-	void (*get_adv) (void __iomem *ioaddr, struct rgmii_adv *adv);
-};
-
-struct stmmac_hwtimestamp {
-	void (*config_hw_tstamping) (void __iomem *ioaddr, u32 data);
-	void (*config_sub_second_increment) (void __iomem *ioaddr);
-	int (*init_systime) (void __iomem *ioaddr, u32 sec, u32 nsec);
-	int (*config_addend) (void __iomem *ioaddr, u32 addend);
-	int (*adjust_systime) (void __iomem *ioaddr, u32 sec, u32 nsec,
-			       int add_sub);
-	 u64(*get_systime) (void __iomem *ioaddr);
 };
 
 struct mac_link {
@@ -431,28 +370,19 @@
 struct stmmac_ring_mode_ops {
 	unsigned int (*is_jumbo_frm) (int len, int ehn_desc);
 	unsigned int (*jumbo_frm) (void *priv, struct sk_buff *skb, int csum);
-	void (*refill_desc3) (void *priv, struct dma_desc *p);
-	void (*init_desc3) (struct dma_desc *p);
-	void (*clean_desc3) (void *priv, struct dma_desc *p);
+	void (*refill_desc3) (int bfsize, struct dma_desc *p);
+	void (*init_desc3) (int des3_as_data_buf, struct dma_desc *p);
+	void (*init_dma_chain) (struct dma_desc *des, dma_addr_t phy_addr,
+				unsigned int size);
+	void (*clean_desc3) (struct dma_desc *p);
 	int (*set_16kib_bfsize) (int mtu);
 };
 
-struct stmmac_chain_mode_ops {
-	void (*init) (void *des, dma_addr_t phy_addr, unsigned int size,
-		      unsigned int extend_desc);
-	unsigned int (*is_jumbo_frm) (int len, int ehn_desc);
-	unsigned int (*jumbo_frm) (void *priv, struct sk_buff *skb, int csum);
-	void (*refill_desc3) (void *priv, struct dma_desc *p);
-	void (*clean_desc3) (void *priv, struct dma_desc *p);
-};
-
 struct mac_device_info {
-	const struct stmmac_ops *mac;
-	const struct stmmac_desc_ops *desc;
-	const struct stmmac_dma_ops *dma;
-	const struct stmmac_ring_mode_ops *ring;
-	const struct stmmac_chain_mode_ops *chain;
-	const struct stmmac_hwtimestamp *ptp;
+	const struct stmmac_ops		*mac;
+	const struct stmmac_desc_ops	*desc;
+	const struct stmmac_dma_ops	*dma;
+	const struct stmmac_ring_mode_ops	*ring;
 	struct mii_regs mii;	/* MII register Addresses */
 	struct mac_link link;
 	unsigned int synopsys_uid;
@@ -470,6 +400,5 @@
 
 extern void dwmac_dma_flush_tx_fifo(void __iomem *ioaddr);
 extern const struct stmmac_ring_mode_ops ring_mode_ops;
-extern const struct stmmac_chain_mode_ops chain_mode_ops;
 
 #endif /* __COMMON_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h
index 223adf9..ce08163 100644
--- a/drivers/net/ethernet/stmicro/stmmac/descs.h
+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h
@@ -25,8 +25,8 @@
 #define __DESCS_H__
 
 struct dma_desc {
-	/* Receive descriptor */
 	union {
+		/* Receive descriptor */
 		struct {
 			/* RDES0 */
 			u32 payload_csum_error:1;
@@ -160,6 +160,49 @@ struct dma_desc {
 	} des01;
 	unsigned int des2;
 	unsigned int des3;
+
+	/* Enhanced mode - with VLAN/1588-2005/IPC CHKSUM offload */
+	#if defined(STMMAC_ATDS_USED)
+		union {
+			/* Receive descriptor */
+			struct {
+				/* RDES4 */
+				u32 ip_payload_type:3;
+				u32 ip_header_error:1;
+				u32 ip_payload_error:1;
+				u32 ip_checksum_bypassed:1;
+				u32 ipv4_packet_received:1;
+				u32 ipv6_packet_received:1;
+				u32 message_type:4;
+				u32 ptp_frame_type:1;
+				u32 ptp_version:1;
+				u32 timestamp_dropped:1;
+				u32 reserved1:1;
+				u32 av_packet_received:1;
+				u32 av_tagged_packet_received:1;
+				u32 vlan_tag_priority_value:3;
+				u32 reserved2:3;
+				u32 layer3_filter_match:1;
+				u32 layer4_filter_match:1;
+				u32 layer3_layer4_filter_num_matched:2;
+				u32 reserved3:4;
+
+				/* RDES5 */
+				u32 reserved4;
+			}erx;
+
+			/* Transmit descriptor */
+			struct {
+				/* TDES4 */
+				u32 reserved1;
+
+				/* TDES5 */
+				u32 reserved2;
+			} etx;
+		} des05;
+		unsigned int ts_lo;		/* des6 Tx/Rx timestmp lo */
+		unsigned int ts_hi;		/* des7 Tx/Rx timestamp hi */
+	#endif
 };
 
 /* Transmit checksum insertion control */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
index 7ad56af..3042098 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
@@ -50,7 +50,14 @@
 	rgmii_irq = 0x0001,
 };
 #define GMAC_INT_MASK		0x0000003c	/* interrupt mask register */
-
+#define GMAC_INT_MASK_LPIIM	0x00000200	/* LPI Interrupt Mask */
+#define GMAC_INT_MASK_TSIM	0x00000100	/* Timestamp Interrupt Mask */
+#define GMAC_INT_MASK_PMTIM	0x00000004	/* PMT Interrupt Mask */
+#define GMAC_INT_MASK_PCSANCIM	0x00000002	/* PCS AN Completion */
+#define GMAC_INT_MASK_PCSLCHGIM	0x00000001	/* PCS Link Status */
+#define GMAC_INT_MASK_DEFAULT GMAC_INT_MASK_PCSLCHGIM | GMAC_INT_MASK_PCSANCIM\
+				| GMAC_INT_MASK_PMTIM | GMAC_INT_MASK_TSIM\
+				| GMAC_INT_MASK_LPIIM
 /* PMT Control and Status */
 #define GMAC_PMT		0x0000002c
 enum power_event {
@@ -89,46 +96,13 @@
 				(reg * 8))
 #define GMAC_MAX_PERFECT_ADDRESSES	32
 
-/* PCS registers (AN/TBI/SGMII/RGMII) offset */
 #define GMAC_AN_CTRL	0x000000c0	/* AN control */
 #define GMAC_AN_STATUS	0x000000c4	/* AN status */
 #define GMAC_ANE_ADV	0x000000c8	/* Auto-Neg. Advertisement */
-#define GMAC_ANE_LPA	0x000000cc	/* Auto-Neg. link partener ability */
+#define GMAC_ANE_LINK	0x000000cc	/* Auto-Neg. link partener ability */
 #define GMAC_ANE_EXP	0x000000d0	/* ANE expansion */
 #define GMAC_TBI	0x000000d4	/* TBI extend status */
-#define GMAC_S_R_GMII	0x000000d8	/* SGMII RGMII status */
-
-/* AN Configuration defines */
-#define GMAC_AN_CTRL_RAN	0x00000200	/* Restart Auto-Negotiation */
-#define GMAC_AN_CTRL_ANE	0x00001000	/* Auto-Negotiation Enable */
-#define GMAC_AN_CTRL_ELE	0x00004000	/* External Loopback Enable */
-#define GMAC_AN_CTRL_ECD	0x00010000	/* Enable Comma Detect */
-#define GMAC_AN_CTRL_LR		0x00020000	/* Lock to Reference */
-#define GMAC_AN_CTRL_SGMRAL	0x00040000	/* SGMII RAL Control */
-
-/* AN Status defines */
-#define GMAC_AN_STATUS_LS	0x00000004	/* Link Status 0:down 1:up */
-#define GMAC_AN_STATUS_ANA	0x00000008	/* Auto-Negotiation Ability */
-#define GMAC_AN_STATUS_ANC	0x00000020	/* Auto-Negotiation Complete */
-#define GMAC_AN_STATUS_ES	0x00000100	/* Extended Status */
-
-/* Register 54 (SGMII/RGMII status register) */
-#define GMAC_S_R_GMII_LINK		0x8
-#define GMAC_S_R_GMII_SPEED		0x5
-#define GMAC_S_R_GMII_SPEED_SHIFT	0x1
-#define GMAC_S_R_GMII_MODE		0x1
-#define GMAC_S_R_GMII_SPEED_125		2
-#define GMAC_S_R_GMII_SPEED_25		1
-
-/* Common ADV and LPA defines */
-#define GMAC_ANE_FD		(1 << 5)
-#define GMAC_ANE_HD		(1 << 6)
-#define GMAC_ANE_PSE		(3 << 7)
-#define GMAC_ANE_PSE_SHIFT	7
-
- /* GMAC Configuration defines */
-#define GMAC_CONTROL_TC	0x01000000	/* Transmit Conf. in RGMII/SGMII */
-#define GMAC_CONTROL_WD	0x00800000	/* Disable Watchdog on receive */
+#define GMAC_GMII_STATUS 0x000000d8	/* S/R-GMII status */
 
 /* GMAC Configuration defines */
 #define GMAC_CONTROL_TC	0x01000000	/* Transmit Conf. in RGMII/SGMII */
@@ -141,19 +115,19 @@
 	GMAC_CONTROL_IFG_80 = 0x00020000,
 	GMAC_CONTROL_IFG_40 = 0x000e0000,
 };
-#define GMAC_CONTROL_DCRS	0x00010000	/* Disable carrier sense */
-#define GMAC_CONTROL_PS		0x00008000	/* Port Select 0:GMI 1:MII */
-#define GMAC_CONTROL_FES	0x00004000	/* Speed 0:10 1:100 */
-#define GMAC_CONTROL_DO		0x00002000	/* Disable Rx Own */
-#define GMAC_CONTROL_LM		0x00001000	/* Loop-back mode */
-#define GMAC_CONTROL_DM		0x00000800	/* Duplex Mode */
-#define GMAC_CONTROL_IPC	0x00000400	/* Checksum Offload */
-#define GMAC_CONTROL_DR		0x00000200	/* Disable Retry */
-#define GMAC_CONTROL_LUD	0x00000100	/* Link up/down */
-#define GMAC_CONTROL_ACS	0x00000080	/* Auto Pad/FCS Stripping */
-#define GMAC_CONTROL_DC		0x00000010	/* Deferral Check */
-#define GMAC_CONTROL_TE		0x00000008	/* Transmitter Enable */
-#define GMAC_CONTROL_RE		0x00000004	/* Receiver Enable */
+#define GMAC_CONTROL_DCRS	0x00010000 /* Disable carrier sense during tx */
+#define GMAC_CONTROL_PS		0x00008000 /* Port Select 0:GMI 1:MII */
+#define GMAC_CONTROL_FES	0x00004000 /* Speed 0:10 1:100 */
+#define GMAC_CONTROL_DO		0x00002000 /* Disable Rx Own */
+#define GMAC_CONTROL_LM		0x00001000 /* Loop-back mode */
+#define GMAC_CONTROL_DM		0x00000800 /* Duplex Mode */
+#define GMAC_CONTROL_IPC	0x00000400 /* Checksum Offload */
+#define GMAC_CONTROL_DR		0x00000200 /* Disable Retry */
+#define GMAC_CONTROL_LUD	0x00000100 /* Link up/down */
+#define GMAC_CONTROL_ACS	0x00000080 /* Automatic Pad/FCS Stripping */
+#define GMAC_CONTROL_DC		0x00000010 /* Deferral Check */
+#define GMAC_CONTROL_TE		0x00000008 /* Transmitter Enable */
+#define GMAC_CONTROL_RE		0x00000004 /* Receiver Enable */
 
 #define GMAC_CORE_INIT (GMAC_CONTROL_JD | GMAC_CONTROL_PS | GMAC_CONTROL_ACS | \
 			GMAC_CONTROL_JE | GMAC_CONTROL_BE)
@@ -168,6 +142,7 @@
 #define GMAC_FRAME_FILTER_SAIF	0x00000100	/* Inverse Filtering */
 #define GMAC_FRAME_FILTER_SAF	0x00000200	/* Source Address Filter */
 #define GMAC_FRAME_FILTER_HPF	0x00000400	/* Hash or perfect Filter */
+#define GMAC_FRAME_FILTER_VTFE	0x00010000	/* VLAN Tag Filter Enable */
 #define GMAC_FRAME_FILTER_RA	0x80000000	/* Receive all mode */
 /* GMII ADDR  defines */
 #define GMAC_MII_ADDR_WRITE	0x00000002	/* MII Write */
@@ -178,22 +153,27 @@
 #define GMAC_FLOW_CTRL_RFE	0x00000004	/* Rx Flow Control Enable */
 #define GMAC_FLOW_CTRL_TFE	0x00000002	/* Tx Flow Control Enable */
 #define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
-
+/* GMAC VLAN TAG defines */
+#define GMAC_VLAN_TAG_VTHM	0x00080000	/* Hash Table Match Enable */
+#define GMAC_VLAN_TAG_ESVL	0x00040000	/* Enable S-VLAN */
+#define GMAC_VLAN_TAG_VTIM	0x00020000	/* VLAN Tag inverse match */
+#define GMAC_VLAN_TAG_ETV	0x00010000	/* Enable 12-bit tag comp */
+#define GMAC_VLAN_TAG_VLMASK	0x0000FFFF	/* VLAN tag ID for Rx frames */
 /*--- DMA BLOCK defines ---*/
 /* DMA Bus Mode register defines */
 #define DMA_BUS_MODE_SFT_RESET	0x00000001	/* Software Reset */
 #define DMA_BUS_MODE_DA		0x00000002	/* Arbitration scheme */
+#define DMA_BUS_MODE_ATDS	0X00000080	/* Alternate Descriptor Size */
 #define DMA_BUS_MODE_DSL_MASK	0x0000007c	/* Descriptor Skip Length */
-#define DMA_BUS_MODE_DSL_SHIFT	2		/*   (in DWORDS)      */
+#define DMA_BUS_MODE_DSL_SHIFT	2	/*   (in DWORDS)      */
 /* Programmable burst length (passed thorugh platform)*/
 #define DMA_BUS_MODE_PBL_MASK	0x00003f00	/* Programmable Burst Len */
 #define DMA_BUS_MODE_PBL_SHIFT	8
-#define DMA_BUS_MODE_ATDS	0x00000080	/* Alternate Descriptor Size */
 
 enum rx_tx_priority_ratio {
-	double_ratio = 0x00004000,	/* 2:1 */
-	triple_ratio = 0x00008000,	/* 3:1 */
-	quadruple_ratio = 0x0000c000,	/* 4:1 */
+	double_ratio = 0x00004000,	/*2:1 */
+	triple_ratio = 0x00008000,	/*3:1 */
+	quadruple_ratio = 0x0000c000,	/*4:1 */
 };
 
 #define DMA_BUS_MODE_FB		0x00010000	/* Fixed burst */
@@ -203,6 +183,7 @@
 #define DMA_BUS_MODE_USP	0x00800000
 #define DMA_BUS_MODE_PBL	0x01000000
 #define DMA_BUS_MODE_AAL	0x02000000
+#define DMA_BUS_MODE_RIX	0x80000000
 
 /* DMA CRS Control and Status Register Mapping */
 #define DMA_HOST_TX_DESC	  0x00001048	/* Current Host Tx descriptor */
@@ -213,10 +194,9 @@
 #define DMA_BUS_FB	  	  0x00010000	/* Fixed Burst */
 
 /* DMA operation mode defines (start/stop tx/rx are placed in common header)*/
-/* Disable Drop TCP/IP csum error */
-#define DMA_CONTROL_DT		0x04000000
-#define DMA_CONTROL_RSF		0x02000000	/* Receive Store and Forward */
-#define DMA_CONTROL_DFF		0x01000000	/* Disaable flushing */
+#define DMA_CONTROL_DT		0x04000000 /* Disable Drop TCP/IP csum error */
+#define DMA_CONTROL_RSF		0x02000000 /* Receive Store and Forward */
+#define DMA_CONTROL_DFF		0x01000000 /* Disaable flushing */
 /* Threshold for Activating the FC */
 enum rfa {
 	act_full_minus_1 = 0x00800000,
@@ -231,7 +211,7 @@
 	deac_full_minus_3 = 0x00401000,
 	deac_full_minus_4 = 0x00401800,
 };
-#define DMA_CONTROL_TSF	0x00200000	/* Transmit  Store and Forward */
+#define DMA_CONTROL_TSF		0x00200000 /* Transmit  Store and Forward */
 
 enum ttc_control {
 	DMA_CONTROL_TTC_64 = 0x00000000,
@@ -265,5 +245,50 @@
 #define GMAC_MMC_TX_INTR   0x108
 #define GMAC_MMC_RX_CSUM_OFFLOAD   0x208
 
+/* VLAN Hash register offset */
+#define GMAC_VLAN_TAG_REP	0x584
+#define GMAC_VLAN_HASH		0x588
+#define GMAC_VLAN_HASH_MAXID	0x0F
+
+/***************** 1588 regs *****************/
+#define GMAC_TS_CTRL		0x700		/* Timestamp control reg */
+#define GMAC_TS_CTRL_TSENA	0x00000001	/* Timestamp enable */
+#define GMAC_TS_CTRL_TSCFUPDT	0x00000002	/* Timestamp fine/coarse */
+#define GMAC_TS_CTRL_TSINT	0x00000004	/* Timestamp initialise */
+#define GMAC_TS_CTRL_TSUPDT	0x00000008	/* Timestamp update */
+#define GMAC_TS_CTRL_TSTRIG	0x00000010	/* Timestamp trigger en */
+#define GMAC_TS_CTRL_TSADDREG	0x00000020	/* Timestamp addreg update */
+#define GMAC_TS_CTRL_TSENALL	0x00000100	/* Timestamp RX enable all */
+#define GMAC_TS_CTRL_TSCTRLSSR	0x00000200	/* Timestamp rollover ctr */
+#define GMAC_TS_CTRL_TSVER2ENA	0x00000400	/* Timestamp PTP v2 en */
+#define GMAC_TS_CTRL_TSIPENA	0x00000800	/* Timestamp PTP over eth */
+#define GMAC_TS_CTRL_TSIPV6ENA	0x00001000	/* Timestamp over IPV6 */
+#define GMAC_TS_CTRL_TSIPV4ENA	0x00002000	/* Timestamp over IPV4 */
+#define GMAC_TS_CTRL_TSEVNTENA	0x00004000	/* Timestamp event only */
+#define GMAC_TS_CTRL_TSMSTRENA	0x00008000	/* Timestamp master enable */
+#define GMAC_TS_CTRL_SNTYPSEL0	0x00000000	/* Timestamp type 0 snapshot */
+#define GMAC_TS_CTRL_SNTYPSEL1	0x00010000	/* Timestamp type 1 snapshot */
+#define GMAC_TS_CTRL_SNTYPSEL2	0x00020000	/* Timestamp type 2 snapshot */
+#define GMAC_TS_CTRL_SNTYPSEL3	0x00030000	/* Timestamp type 3 snapshot */
+#define GMAC_TS_CTRL_TSENMACADR	0x00040000	/* Timestamp mac filter en */
+#define GMAC_TS_CTRL_ATSFC	0x01000000	/* Timestamp aux fifo clear */
+#define GMAC_TS_CTRL_ATSEN0	0x02000000	/* Timestamp aux0 snap en */
+#define GMAC_TS_CTRL_ATSEN1	0x04000000	/* Timestamp aux1 snap en */
+#define GMAC_TS_CTRL_ATSEN2	0x08000000	/* Timestamp aux2 snap en */
+#define GMAC_TS_CTRL_ATSEN3	0x10000000	/* Timestamp aux3 enable */
+#define GMAC_SS_INC		0x704		/* Sub-second increment reg */
+#define GMAC_ST_SEC		0x708		/* System time seconds */
+#define GMAC_ST_NSEC		0x70C		/* System time nseconds */
+#define GMAC_ST_SECUP		0x710		/* System time sec-update */
+#define GMAC_ST_NSECUP		0x714		/* System time nsec-update */
+#define GMAC_TS_APPEND		0x718		/* Timestamp append */
+#define GMAC_TT_SEC		0x71C		/* Target time seconds */
+#define GMAC_TT_NSEC		0x720		/* Target time nseconds */
+#define GMAC_ST_HWSEC		0x724		/* System time high word sec */
+#define GMAC_ST_TS_STAT		0x728		/* Timestamp status */
+#define GMAC_PPS_CTRL		0x72C		/* PPS signal output control */
+#define GMAC_AUXTS_NSEC		0x730		/* Aux timestamp counter nsec */
+#define GMAC_AUXTS_SEC		0x734		/* Aux timestamp counter sec */
+
 extern const struct stmmac_dma_ops dwmac1000_dma_ops;
 #endif /* __DWMAC1000_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index bfe0226..b6d04ca 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -28,9 +28,9 @@
 
 #include <linux/crc32.h>
 #include <linux/slab.h>
-#include <linux/ethtool.h>
 #include <asm/io.h>
 #include "dwmac1000.h"
+#include "stmmac.h"
 
 static void dwmac1000_core_init(void __iomem *ioaddr)
 {
@@ -39,7 +39,7 @@
 	writel(value, ioaddr + GMAC_CONTROL);
 
 	/* Mask GMAC interrupts */
-	writel(0x207, ioaddr + GMAC_INT_MASK);
+	writel(GMAC_INT_MASK_DEFAULT, ioaddr + GMAC_INT_MASK);
 
 #ifdef STMMAC_VLAN_TAG_USED
 	/* Tag detection without filtering */
@@ -47,11 +47,15 @@
 #endif
 }
 
-static int dwmac1000_rx_ipc_enable(void __iomem *ioaddr)
+static int dwmac1000_set_rx_ipc(void __iomem *ioaddr, bool on)
 {
 	u32 value = readl(ioaddr + GMAC_CONTROL);
 
-	value |= GMAC_CONTROL_IPC;
+	if(on == true){
+		value |= GMAC_CONTROL_IPC;
+	}else{
+		value &= ~GMAC_CONTROL_IPC;
+	}
 	writel(value, ioaddr + GMAC_CONTROL);
 
 	value = readl(ioaddr + GMAC_CONTROL);
@@ -72,22 +76,23 @@
 }
 
 static void dwmac1000_set_umac_addr(void __iomem *ioaddr, unsigned char *addr,
-				    unsigned int reg_n)
+				unsigned int reg_n)
 {
 	stmmac_set_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),
-			    GMAC_ADDR_LOW(reg_n));
+				GMAC_ADDR_LOW(reg_n));
 }
 
 static void dwmac1000_get_umac_addr(void __iomem *ioaddr, unsigned char *addr,
-				    unsigned int reg_n)
+				unsigned int reg_n)
 {
 	stmmac_get_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),
-			    GMAC_ADDR_LOW(reg_n));
+				GMAC_ADDR_LOW(reg_n));
 }
 
 static void dwmac1000_set_filter(struct net_device *dev, int id)
 {
-	void __iomem *ioaddr = (void __iomem *)dev->base_addr;
+	void __iomem *ioaddr = (void __iomem *) dev->base_addr;
+	struct stmmac_priv *priv = netdev_priv(dev);
 	unsigned int value = 0;
 	unsigned int perfect_addr_number;
 
@@ -97,7 +102,7 @@
 	if (dev->flags & IFF_PROMISC)
 		value = GMAC_FRAME_FILTER_PR;
 	else if ((netdev_mc_count(dev) > HASH_TABLE_SIZE)
-		 || (dev->flags & IFF_ALLMULTI)) {
+		   || (dev->flags & IFF_ALLMULTI)) {
 		value = GMAC_FRAME_FILTER_PM;	/* pass all multi */
 		writel(0xffffffff, ioaddr + GMAC_HASH_HIGH);
 		writel(0xffffffff, ioaddr + GMAC_HASH_LOW);
@@ -111,13 +116,12 @@
 		memset(mc_filter, 0, sizeof(mc_filter));
 		netdev_for_each_mc_addr(ha, dev) {
 			/* The upper 6 bits of the calculated CRC are used to
-			 * index the contens of the hash table
-			 */
-			int bit_nr = bitrev32(~crc32_le(~0, ha->addr, 6)) >> 26;
+			   index the contens of the hash table */
+			int bit_nr =
+			    bitrev32(~crc32_le(~0, ha->addr, 6)) >> 26;
 			/* The most significant bit determines the register to
 			 * use (H/L) while the other 5 bits determine the bit
-			 * within the register.
-			 */
+			 * within the register. */
 			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
 		}
 		writel(mc_filter[0], ioaddr + GMAC_HASH_LOW);
@@ -130,11 +134,10 @@
 	else
 		perfect_addr_number = GMAC_MAX_PERFECT_ADDRESSES / 2;
 
-	/* Handle multiple unicast addresses (perfect filtering) */
+	/* Handle multiple unicast addresses (perfect filtering)*/
 	if (netdev_uc_count(dev) > perfect_addr_number)
-		/* Switch to promiscuous mode if more than 16 addrs
-		 * are required
-		 */
+		/* Switch to promiscuous mode is more than 16 addrs
+		   are required */
 		value |= GMAC_FRAME_FILTER_PR;
 	else {
 		int reg = 1;
@@ -150,15 +153,19 @@
 	/* Enable Receive all mode (to debug filtering_fail errors) */
 	value |= GMAC_FRAME_FILTER_RA;
 #endif
+	if (priv->active_vlans != 0){
+		/* VLAN hash filtering is active on this interface */
+		value |= GMAC_FRAME_FILTER_VTFE;
+	}
 	writel(value, ioaddr + GMAC_FRAME_FILTER);
 
-	CHIP_DBG(KERN_INFO "\tFilter: 0x%08x\n\tHash: HI 0x%08x, LO 0x%08x\n",
-		 readl(ioaddr + GMAC_FRAME_FILTER),
-		 readl(ioaddr + GMAC_HASH_HIGH), readl(ioaddr + GMAC_HASH_LOW));
+	CHIP_DBG(KERN_INFO "\tFrame Filter reg: 0x%08x\n\tHash regs: "
+	    "HI 0x%08x, LO 0x%08x\n", readl(ioaddr + GMAC_FRAME_FILTER),
+	    readl(ioaddr + GMAC_HASH_HIGH), readl(ioaddr + GMAC_HASH_LOW));
 }
 
 static void dwmac1000_flow_ctrl(void __iomem *ioaddr, unsigned int duplex,
-				unsigned int fc, unsigned int pause_time)
+			   unsigned int fc, unsigned int pause_time)
 {
 	unsigned int flow = 0;
 
@@ -196,106 +203,178 @@
 	writel(pmt, ioaddr + GMAC_PMT);
 }
 
-static int dwmac1000_irq_status(void __iomem *ioaddr,
-				struct stmmac_extra_stats *x)
+
+#ifndef CONFIG_STMMAC_PTP
+#define stmmac_ptp_check_pps_event(x){}
+#endif
+
+static int dwmac1000_irq_status(struct stmmac_priv *priv)
 {
-	u32 intr_status = readl(ioaddr + GMAC_INT_STATUS);
-	int ret = 0;
+	u32 intr_status = readl(priv->ioaddr + GMAC_INT_STATUS);
+	int status = 0;
 
 	/* Not used events (e.g. MMC interrupts) are not handled. */
 	if ((intr_status & mmc_tx_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: MMC tx interrupt: 0x%08x\n",
-			 readl(ioaddr + GMAC_MMC_TX_INTR));
-		x->mmc_tx_irq_n++;
+		    readl(priv->ioaddr + GMAC_MMC_TX_INTR));
+		status |= core_mmc_tx_irq;
 	}
 	if (unlikely(intr_status & mmc_rx_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: MMC rx interrupt: 0x%08x\n",
-			 readl(ioaddr + GMAC_MMC_RX_INTR));
-		x->mmc_rx_irq_n++;
+		    readl(priv->ioaddr + GMAC_MMC_RX_INTR));
+		status |= core_mmc_rx_irq;
 	}
 	if (unlikely(intr_status & mmc_rx_csum_offload_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: MMC rx csum offload: 0x%08x\n",
-			 readl(ioaddr + GMAC_MMC_RX_CSUM_OFFLOAD));
-		x->mmc_rx_csum_offload_irq_n++;
+		    readl(priv->ioaddr + GMAC_MMC_RX_CSUM_OFFLOAD));
+		status |= core_mmc_rx_csum_offload_irq;
 	}
 	if (unlikely(intr_status & pmt_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: received Magic frame\n");
-		/* clear the PMT bits 5 and 6 by reading the PMT status reg */
-		readl(ioaddr + GMAC_PMT);
-		x->irq_receive_pmt_irq_n++;
+		/* clear the PMT bits 5 and 6 by reading the PMT
+		 * status register. */
+		readl(priv->ioaddr + GMAC_PMT);
+		status |= core_irq_receive_pmt_irq;
 	}
 	/* MAC trx/rx EEE LPI entry/exit interrupts */
 	if (intr_status & lpiis_irq) {
 		/* Clean LPI interrupt by reading the Reg 12 */
-		ret = readl(ioaddr + LPI_CTRL_STATUS);
+		u32 lpi_status = readl(priv->ioaddr + LPI_CTRL_STATUS);
 
-		if (ret & LPI_CTRL_STATUS_TLPIEN) {
+		if (lpi_status & LPI_CTRL_STATUS_TLPIEN) {
 			CHIP_DBG(KERN_INFO "GMAC TX entered in LPI\n");
-			x->irq_tx_path_in_lpi_mode_n++;
+			status |= core_irq_tx_path_in_lpi_mode;
 		}
-		if (ret & LPI_CTRL_STATUS_TLPIEX) {
+		if (lpi_status & LPI_CTRL_STATUS_TLPIEX) {
 			CHIP_DBG(KERN_INFO "GMAC TX exit from LPI\n");
-			x->irq_tx_path_exit_lpi_mode_n++;
+			status |= core_irq_tx_path_exit_lpi_mode;
 		}
-		if (ret & LPI_CTRL_STATUS_RLPIEN) {
+		if (lpi_status & LPI_CTRL_STATUS_RLPIEN) {
 			CHIP_DBG(KERN_INFO "GMAC RX entered in LPI\n");
-			x->irq_rx_path_in_lpi_mode_n++;
+			status |= core_irq_rx_path_in_lpi_mode;
 		}
-		if (ret & LPI_CTRL_STATUS_RLPIEX) {
+		if (lpi_status & LPI_CTRL_STATUS_RLPIEX) {
 			CHIP_DBG(KERN_INFO "GMAC RX exit from LPI\n");
-			x->irq_rx_path_exit_lpi_mode_n++;
+			status |= core_irq_rx_path_exit_lpi_mode;
 		}
 	}
+	if (unlikely(intr_status & time_stamp_irq)){
+		stmmac_ptp_check_pps_event(priv);
+	}
+
+	return status;
+}
 
-	if ((intr_status & pcs_ane_irq) || (intr_status & pcs_link_irq)) {
-		CHIP_DBG(KERN_INFO "GMAC PCS ANE IRQ\n");
-		readl(ioaddr + GMAC_AN_STATUS);
-		x->irq_pcs_ane_n++;
-	}
-	if (intr_status & rgmii_irq) {
-		u32 status = readl(ioaddr + GMAC_S_R_GMII);
-		CHIP_DBG(KERN_INFO "GMAC RGMII/SGMII interrupt\n");
-		x->irq_rgmii_n++;
-
-		/* Save and dump the link status. */
-		if (status & GMAC_S_R_GMII_LINK) {
-			int speed_value = (status & GMAC_S_R_GMII_SPEED) >>
-			    GMAC_S_R_GMII_SPEED_SHIFT;
-			x->pcs_duplex = (status & GMAC_S_R_GMII_MODE);
-
-			if (speed_value == GMAC_S_R_GMII_SPEED_125)
-				x->pcs_speed = SPEED_1000;
-			else if (speed_value == GMAC_S_R_GMII_SPEED_25)
-				x->pcs_speed = SPEED_100;
-			else
-				x->pcs_speed = SPEED_10;
-
-			x->pcs_link = 1;
-			pr_debug("Link is Up - %d/%s\n", (int)x->pcs_speed,
-				 x->pcs_duplex ? "Full" : "Half");
-		} else {
-			x->pcs_link = 0;
-			pr_debug("Link is Down\n");
+static unsigned int dwmac1000_calc_vlan_4bit_crc ( const char * vlan )
+{
+	int i = 0, j = 0, len = 0, bit = 0;
+	unsigned int crc = 0xFFFFFFFF;
+	unsigned int poly = 0x04C11DB7;
+	unsigned char data;
+
+	if(unlikely(vlan == NULL)){
+		return 0;
+	}
+
+	for( i = 0; i < 2; i++ ) {
+		data = vlan[i];
+
+		if (i==0){
+			len = 8;
+		}else{
+			len = 4;
 		}
+
+		for( bit = 0; bit < len; bit++ ) {
+
+			j = ((crc >> 31) ^ data) & 0x1;
+			crc <<= 1;
+
+			if( j != 0 ){
+				crc ^= poly;
+			}
+
+			data >>= 1;
+		}
+	}
+	return crc;
+
+}
+
+static int dwmac1000_vlan_rx_add_vid(struct stmmac_priv *priv, unsigned short vid)
+{
+	u32 reg = 0;
+	u32 bit_nr = 0;
+
+	if(unlikely(priv == NULL || vid > GMAC_VLAN_HASH_MAXID)){
+		return -EINVAL;
+	}
+
+	if(priv->active_vlans == 0){
+
+		/* Flip the VTFE bit in GMAC_FRAME_FILTER */
+		reg = readl(priv->ioaddr + GMAC_FRAME_FILTER);
+		reg |= GMAC_FRAME_FILTER_VTFE;
+		writel(reg, priv->ioaddr + GMAC_FRAME_FILTER);
+
+		/* Enable hash filtering - based on 12 bit vid */
+		reg = readl(priv->ioaddr + GMAC_VLAN_TAG);
+		reg |= GMAC_VLAN_TAG_VTHM | GMAC_VLAN_TAG_ETV | 0x0000FFFF;
+		writel(reg, priv->ioaddr + GMAC_VLAN_TAG);
+	}
+
+	bit_nr = (~dwmac1000_calc_vlan_4bit_crc((const char*)&vid)) >> 28;
+	priv->active_vlans |= 1 << bit_nr;
+
+	writel(priv->active_vlans, priv->ioaddr + GMAC_VLAN_HASH);
+
+	return 0;
+}
+
+static int dwmac1000_vlan_rx_kill_vid(struct stmmac_priv *priv, unsigned short vid)
+{
+	u32 reg = 0;
+	u32 bit_nr = 0;
+
+	if(unlikely(priv == NULL || vid > GMAC_VLAN_HASH_MAXID)){
+		return -EINVAL;
 	}
 
-	return ret;
+	bit_nr = (~dwmac1000_calc_vlan_4bit_crc((const char*)&vid)) >> 28;
+
+	priv->active_vlans &= ~(1 << bit_nr);
+	writel(priv->active_vlans, priv->ioaddr + GMAC_VLAN_HASH);
+
+	if(priv->active_vlans == 0){
+
+		/* Disable hash filtering */
+		reg = readl(priv->ioaddr + GMAC_VLAN_TAG);
+		reg &= ~(GMAC_VLAN_TAG_VTHM | GMAC_VLAN_TAG_ETV | 0x00000001);
+		writel(reg, priv->ioaddr + GMAC_VLAN_TAG);
+
+		/* Flip the VTFE bit in GMAC_FRAME_FILTER */
+		reg = readl(priv->ioaddr + GMAC_FRAME_FILTER);
+		reg &= ~GMAC_FRAME_FILTER_VTFE;
+		writel(reg, priv->ioaddr + GMAC_FRAME_FILTER);
+
+	}
+
+	return 0;
 }
 
-static void dwmac1000_set_eee_mode(void __iomem *ioaddr)
+static void  dwmac1000_set_eee_mode(void __iomem *ioaddr)
 {
 	u32 value;
 
 	/* Enable the link status receive on RGMII, SGMII ore SMII
 	 * receive path and instruct the transmit to enter in LPI
-	 * state.
-	 */
+	 * state. */
 	value = readl(ioaddr + LPI_CTRL_STATUS);
 	value |= LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA;
 	writel(value, ioaddr + LPI_CTRL_STATUS);
 }
 
-static void dwmac1000_reset_eee_mode(void __iomem *ioaddr)
+static void  dwmac1000_reset_eee_mode(void __iomem *ioaddr)
 {
 	u32 value;
 
@@ -304,7 +383,7 @@
 	writel(value, ioaddr + LPI_CTRL_STATUS);
 }
 
-static void dwmac1000_set_eee_pls(void __iomem *ioaddr, int link)
+static void  dwmac1000_set_eee_pls(void __iomem *ioaddr, int link)
 {
 	u32 value;
 
@@ -318,7 +397,7 @@
 	writel(value, ioaddr + LPI_CTRL_STATUS);
 }
 
-static void dwmac1000_set_eee_timer(void __iomem *ioaddr, int ls, int tw)
+static void  dwmac1000_set_eee_timer(void __iomem *ioaddr, int ls, int tw)
 {
 	int value = ((tw & 0xffff)) | ((ls & 0x7ff) << 16);
 
@@ -332,44 +411,10 @@
 	writel(value, ioaddr + LPI_TIMER_CTRL);
 }
 
-static void dwmac1000_ctrl_ane(void __iomem *ioaddr, bool restart)
-{
-	u32 value;
-
-	value = readl(ioaddr + GMAC_AN_CTRL);
-	/* auto negotiation enable and External Loopback enable */
-	value = GMAC_AN_CTRL_ANE | GMAC_AN_CTRL_ELE;
-
-	if (restart)
-		value |= GMAC_AN_CTRL_RAN;
-
-	writel(value, ioaddr + GMAC_AN_CTRL);
-}
-
-static void dwmac1000_get_adv(void __iomem *ioaddr, struct rgmii_adv *adv)
-{
-	u32 value = readl(ioaddr + GMAC_ANE_ADV);
-
-	if (value & GMAC_ANE_FD)
-		adv->duplex = DUPLEX_FULL;
-	if (value & GMAC_ANE_HD)
-		adv->duplex |= DUPLEX_HALF;
-
-	adv->pause = (value & GMAC_ANE_PSE) >> GMAC_ANE_PSE_SHIFT;
-
-	value = readl(ioaddr + GMAC_ANE_LPA);
-
-	if (value & GMAC_ANE_FD)
-		adv->lp_duplex = DUPLEX_FULL;
-	if (value & GMAC_ANE_HD)
-		adv->lp_duplex = DUPLEX_HALF;
-
-	adv->lp_pause = (value & GMAC_ANE_PSE) >> GMAC_ANE_PSE_SHIFT;
-}
 
 static const struct stmmac_ops dwmac1000_ops = {
 	.core_init = dwmac1000_core_init,
-	.rx_ipc = dwmac1000_rx_ipc_enable,
+	.set_rx_ipc = dwmac1000_set_rx_ipc,
 	.dump_regs = dwmac1000_dump_regs,
 	.host_irq_status = dwmac1000_irq_status,
 	.set_filter = dwmac1000_set_filter,
@@ -377,12 +422,12 @@
 	.pmt = dwmac1000_pmt,
 	.set_umac_addr = dwmac1000_set_umac_addr,
 	.get_umac_addr = dwmac1000_get_umac_addr,
-	.set_eee_mode = dwmac1000_set_eee_mode,
-	.reset_eee_mode = dwmac1000_reset_eee_mode,
-	.set_eee_timer = dwmac1000_set_eee_timer,
-	.set_eee_pls = dwmac1000_set_eee_pls,
-	.ctrl_ane = dwmac1000_ctrl_ane,
-	.get_adv = dwmac1000_get_adv,
+	.vlan_rx_add_vid = dwmac1000_vlan_rx_add_vid,
+	.vlan_rx_kill_vid = dwmac1000_vlan_rx_kill_vid,
+	.set_eee_mode =  dwmac1000_set_eee_mode,
+	.reset_eee_mode =  dwmac1000_reset_eee_mode,
+	.set_eee_timer =  dwmac1000_set_eee_timer,
+	.set_eee_pls =  dwmac1000_set_eee_pls,
 };

 struct mac_device_info *dwmac1000_setup(void __iomem *ioaddr)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
index bf83c03..a0c08e1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
@@ -30,8 +30,8 @@
 #include "dwmac1000.h"
 #include "dwmac_dma.h"
 
-static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
-			      int burst_len, u32 dma_tx, u32 dma_rx, int atds)
+static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb,
+			      int mb, int burst_len, u32 dma_tx, u32 dma_rx)
 {
 	u32 value = readl(ioaddr + DMA_BUS_MODE);
 	int limit;
@@ -59,9 +59,12 @@
 	 * DMA transfers the data in 8, 16, 32, 64, 128 & 256 beats
 	 * depending on pbl value.
 	 */
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	value = DMA_BUS_MODE_RIX | (pbl << DMA_BUS_MODE_PBL_SHIFT);
+#else
 	value = DMA_BUS_MODE_PBL | ((pbl << DMA_BUS_MODE_PBL_SHIFT) |
-				    (pbl << DMA_BUS_MODE_RPBL_SHIFT));
-
+		(pbl << DMA_BUS_MODE_RPBL_SHIFT));
+#endif
 	/* Set the Fixed burst mode */
 	if (fb)
 		value |= DMA_BUS_MODE_FB;
@@ -70,13 +73,13 @@
 	if (mb)
 		value |= DMA_BUS_MODE_MB;
 
+#if defined(STMMAC_ATDS_USED)
+	value |= DMA_BUS_MODE_ATDS;
+#endif
+
 #ifdef CONFIG_STMMAC_DA
 	value |= DMA_BUS_MODE_DA;	/* Rx has priority over tx */
 #endif
-
-	if (atds)
-		value |= DMA_BUS_MODE_ATDS;
-
 	writel(value, ioaddr + DMA_BUS_MODE);
 
 	/* In case of GMAC AXI configuration, program the DMA_AXI_BUS_MODE
@@ -94,16 +97,14 @@
 	 *
 	 *  For Non Fixed Burst Mode: provide the maximum value of the
 	 *  burst length. Any burst equal or below the provided burst
-	 *  length would be allowed to perform.
-	 */
+	 *  length would be allowed to perform. */
 	writel(burst_len, ioaddr + DMA_AXI_BUS_MODE);
 
 	/* Mask interrupts by writing to CSR7 */
 	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
 
-	/* RX/TX descriptor base address lists must be written into
-	 * DMA CSR3 and CSR4, respectively
-	 */
+	/* The base address of the RX/TX descriptor lists must be written into
+	 * DMA CSR3 and CSR4, respectively. */
 	writel(dma_tx, ioaddr + DMA_TX_BASE_ADDR);
 	writel(dma_rx, ioaddr + DMA_RCV_BASE_ADDR);
 
@@ -111,7 +112,7 @@
 }
 
 static void dwmac1000_dma_operation_mode(void __iomem *ioaddr, int txmode,
-					 int rxmode)
+				    int rxmode)
 {
 	u32 csr6 = readl(ioaddr + DMA_CONTROL);
 
@@ -120,12 +121,11 @@
 		/* Transmit COE type 2 cannot be done in cut-through mode. */
 		csr6 |= DMA_CONTROL_TSF;
 		/* Operating on second frame increase the performance
-		 * especially when transmit store-and-forward is used.
-		 */
+		 * especially when transmit store-and-forward is used.*/
 		csr6 |= DMA_CONTROL_OSF;
 	} else {
-		CHIP_DBG(KERN_DEBUG "GMAC: disabling TX SF (threshold %d)\n",
-			 txmode);
+		CHIP_DBG(KERN_DEBUG "GMAC: disabling TX store and forward mode"
+			      " (threshold = %d)\n", txmode);
 		csr6 &= ~DMA_CONTROL_TSF;
 		csr6 &= DMA_CONTROL_TC_TX_MASK;
 		/* Set the transmit threshold */
@@ -145,8 +145,8 @@
 		CHIP_DBG(KERN_DEBUG "GMAC: enable RX store and forward mode\n");
 		csr6 |= DMA_CONTROL_RSF;
 	} else {
-		CHIP_DBG(KERN_DEBUG "GMAC: disable RX SF mode (threshold %d)\n",
-			 rxmode);
+		CHIP_DBG(KERN_DEBUG "GMAC: disabling RX store and forward mode"
+			      " (threshold = %d)\n", rxmode);
 		csr6 &= ~DMA_CONTROL_RSF;
 		csr6 &= DMA_CONTROL_TC_RX_MASK;
 		if (rxmode <= 32)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
index f83210e..43472c0 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
@@ -47,7 +47,8 @@
 {
 	pr_info("\t----------------------------------------------\n"
 		"\t  DWMAC 100 CSR (base addr = 0x%p)\n"
-		"\t----------------------------------------------\n", ioaddr);
+		"\t----------------------------------------------\n",
+		ioaddr);
 	pr_info("\tcontrol reg (offset 0x%x): 0x%08x\n", MAC_CONTROL,
 		readl(ioaddr + MAC_CONTROL));
 	pr_info("\taddr HI (offset 0x%x): 0x%08x\n ", MAC_ADDR_HIGH,
@@ -66,13 +67,12 @@
 		readl(ioaddr + MAC_VLAN2));
 }
 
-static int dwmac100_rx_ipc_enable(void __iomem *ioaddr)
+static int dwmac100_set_rx_ipc(void __iomem *ioaddr, bool on)
 {
 	return 0;
 }
 
-static int dwmac100_irq_status(void __iomem *ioaddr,
-			       struct stmmac_extra_stats *x)
+static int dwmac100_irq_status(struct stmmac_priv *priv)
 {
 	return 0;
 }
@@ -91,7 +91,7 @@
 
 static void dwmac100_set_filter(struct net_device *dev, int id)
 {
-	void __iomem *ioaddr = (void __iomem *)dev->base_addr;
+	void __iomem *ioaddr = (void __iomem *) dev->base_addr;
 	u32 value = readl(ioaddr + MAC_CONTROL);
 
 	if (dev->flags & IFF_PROMISC) {
@@ -112,8 +112,7 @@
 		struct netdev_hw_addr *ha;
 
 		/* Perfect filter mode for physical address and Hash
-		 * filter for multicast
-		 */
+		   filter for multicast */
 		value |= MAC_CONTROL_HP;
 		value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |
 			   MAC_CONTROL_IF | MAC_CONTROL_HO);
@@ -121,13 +120,12 @@
 		memset(mc_filter, 0, sizeof(mc_filter));
 		netdev_for_each_mc_addr(ha, dev) {
 			/* The upper 6 bits of the calculated CRC are used to
-			 * index the contens of the hash table
-			 */
-			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			 * index the contens of the hash table */
+			int bit_nr =
+			    ether_crc(ETH_ALEN, ha->addr) >> 26;
 			/* The most significant bit determines the register to
 			 * use (H/L) while the other 5 bits determine the bit
-			 * within the register.
-			 */
+			 * within the register. */
 			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
 		}
 		writel(mc_filter[0], ioaddr + MAC_HASH_LOW);
@@ -136,9 +134,10 @@
 
 	writel(value, ioaddr + MAC_CONTROL);
 
-	CHIP_DBG(KERN_INFO "%s: Filter: 0x%08x Hash: HI 0x%08x, LO 0x%08x\n",
-		 __func__, readl(ioaddr + MAC_CONTROL),
-		 readl(ioaddr + MAC_HASH_HIGH), readl(ioaddr + MAC_HASH_LOW));
+	CHIP_DBG(KERN_INFO "%s: CTRL reg: 0x%08x Hash regs: "
+	    "HI 0x%08x, LO 0x%08x\n",
+	    __func__, readl(ioaddr + MAC_CONTROL),
+	    readl(ioaddr + MAC_HASH_HIGH), readl(ioaddr + MAC_HASH_LOW));
 }
 
 static void dwmac100_flow_ctrl(void __iomem *ioaddr, unsigned int duplex,
@@ -151,7 +150,9 @@
 	writel(flow, ioaddr + MAC_FLOW_CTRL);
 }
 
-/* No PMT module supported on ST boards with this Eth chip. */
+/* No PMT module supported for this Ethernet Controller.
+ * Tested on ST platforms only.
+ */
 static void dwmac100_pmt(void __iomem *ioaddr, unsigned long mode)
 {
 	return;
@@ -159,7 +160,7 @@
 
 static const struct stmmac_ops dwmac100_ops = {
 	.core_init = dwmac100_core_init,
-	.rx_ipc = dwmac100_rx_ipc_enable,
+	.set_rx_ipc = dwmac100_set_rx_ipc,
 	.dump_regs = dwmac100_dump_mac_regs,
 	.host_irq_status = dwmac100_irq_status,
 	.set_filter = dwmac100_set_filter,
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index b05df89..611f70e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -24,56 +24,45 @@
 #define __STMMAC_H__
 
 #define STMMAC_RESOURCE_NAME   "stmmaceth"
-#define DRV_MODULE_VERSION	"March_2013"
+#define DRV_MODULE_VERSION	"Nov_2012"
 
 #include <linux/clk.h>
+#include <linux/clocksource.h>
 #include <linux/stmmac.h>
 #include <linux/phy.h>
 #include <linux/pci.h>
-#include "common.h"
 #include <linux/ptp_clock_kernel.h>
+#include "common.h"
 
 struct stmmac_priv {
 	/* Frequently used values are kept adjacent for cache effect */
-	struct dma_extended_desc *dma_etx ____cacheline_aligned_in_smp;
-	struct dma_desc *dma_tx;
+	struct dma_desc *dma_tx ____cacheline_aligned;
+	dma_addr_t dma_tx_phy;
 	struct sk_buff **tx_skbuff;
 	unsigned int cur_tx;
 	unsigned int dirty_tx;
 	unsigned int dma_tx_size;
-	u32 tx_count_frames;
-	u32 tx_coal_frames;
-	u32 tx_coal_timer;
-	dma_addr_t *tx_skbuff_dma;
-	dma_addr_t dma_tx_phy;
 	int tx_coalesce;
-	int hwts_tx_en;
-	spinlock_t tx_lock;
-	bool tx_path_in_lpi_mode;
-	struct timer_list txtimer;
 
-	struct dma_desc *dma_rx	____cacheline_aligned_in_smp;
-	struct dma_extended_desc *dma_erx;
-	struct sk_buff **rx_skbuff;
+	struct dma_desc *dma_rx ;
 	unsigned int cur_rx;
 	unsigned int dirty_rx;
-	unsigned int dma_rx_size;
-	unsigned int dma_buf_sz;
-	u32 rx_riwt;
-	int hwts_rx_en;
+	struct sk_buff **rx_skbuff;
 	dma_addr_t *rx_skbuff_dma;
-	dma_addr_t dma_rx_phy;
-
-	struct napi_struct napi ____cacheline_aligned_in_smp;
 
-	void __iomem *ioaddr;
 	struct net_device *dev;
+	dma_addr_t dma_rx_phy;
+	unsigned int dma_rx_size;
+	unsigned int dma_buf_sz;
 	struct device *device;
 	struct mac_device_info *hw;
+	void __iomem *ioaddr;
+
+	struct stmmac_extra_stats xstats;
+	struct napi_struct napi;
 	int no_csum_insertion;
-	spinlock_t lock;
 
-	struct phy_device *phydev ____cacheline_aligned_in_smp;
+	struct phy_device *phydev;
 	int oldlink;
 	int speed;
 	int oldduplex;
@@ -82,31 +71,46 @@
 	struct mii_bus *mii;
 	int mii_irq[PHY_MAX_ADDR];
 
-	struct stmmac_extra_stats xstats ____cacheline_aligned_in_smp;
-	struct plat_stmmacenet_data *plat;
-	struct dma_features dma_cap;
-	struct stmmac_counters mmc;
-	int hw_cap_support;
-	int synopsys_id;
 	u32 msg_enable;
+	spinlock_t lock;
+	spinlock_t tx_lock;
+
+	/* PTP */
+	struct ptp_clock *ptp_clock;
+	struct ptp_clock_info ptp_caps;
+	struct delayed_work overflow_work;
+	spinlock_t tmreg_lock;
+	struct cyclecounter ccnt;
+	struct timecounter tcnt;
+//	struct timecompare tcmp;
+	int hwts;
+	struct stmmac_timer *tm;
+
 	int wolopts;
 	int wol_irq;
+
+	int active_vlans;
+	struct plat_stmmacenet_data *plat;
+	struct stmmac_counters mmc;
+	struct dma_features dma_cap;
+	int hw_cap_support;
 	struct clk *stmmac_clk;
 	int clk_csr;
+	int synopsys_id;
+	int irqmode_msi;
+	struct pci_dev * pdev;
 	struct timer_list eee_ctrl_timer;
+	bool tx_path_in_lpi_mode;
 	int lpi_irq;
 	int eee_enabled;
 	int eee_active;
 	int tx_lpi_timer;
-	int pcs;
-	unsigned int mode;
-	int extend_desc;
-	struct ptp_clock *ptp_clock;
-	struct ptp_clock_info ptp_clock_ops;
-	unsigned int default_addend;
-	u32 adv_ts;
+	struct timer_list txtimer;
+	u32 tx_count_frames;
+	u32 tx_coal_frames;
+	u32 tx_coal_timer;
 	int use_riwt;
-	spinlock_t ptp_lock;
+	u32 rx_riwt;
 };
 
 extern int phyaddr;
@@ -116,9 +120,6 @@
 extern void stmmac_set_ethtool_ops(struct net_device *netdev);
 extern const struct stmmac_desc_ops enh_desc_ops;
 extern const struct stmmac_desc_ops ndesc_ops;
-extern const struct stmmac_hwtimestamp stmmac_ptp;
-extern int stmmac_ptp_register(struct stmmac_priv *priv);
-extern void stmmac_ptp_unregister(struct stmmac_priv *priv);
 int stmmac_freeze(struct net_device *ndev);
 int stmmac_restore(struct net_device *ndev);
 int stmmac_resume(struct net_device *ndev);
@@ -127,6 +128,63 @@
 struct stmmac_priv *stmmac_dvr_probe(struct device *device,
 				     struct plat_stmmacenet_data *plat_dat,
 				     void __iomem *addr);
+#ifdef CONFIG_STMMAC_PTP
+
+#define STMMAC_PTP_OVERFLOW_CHECK_ENABLED	(u32)(1)
+#define STMMAC_PTP_PPS_ENABLED			(u32)(1 << 1)
+#define STMMAC_PTP_HWTS_TX_EN			(u32)(1 << 2)
+#define STMMAC_PTP_HWTS_RX_EN			(u32)(1 << 3)
+
+extern void stmmac_ptp_init(struct net_device *ndev, struct device * pdev);
+extern void stmmac_ptp_remove(struct stmmac_priv *priv);
+extern int stmmac_ptp_hwtstamp_ioctl(struct stmmac_priv *priv,
+			     struct ifreq *ifr, int cmd);
+extern void stmmac_ptp_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *pdma,
+			   struct sk_buff *skb);
+extern void stmmac_ptp_tx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *pdma,
+			   struct sk_buff *skb);
+extern void stmmac_ptp_check_pps_event(struct stmmac_priv *priv);
+#endif
+
+#ifdef CONFIG_HAVE_CLK
+static inline int stmmac_clk_enable(struct stmmac_priv *priv)
+{
+	if (!IS_ERR(priv->stmmac_clk))
+		return clk_prepare_enable(priv->stmmac_clk);
+
+	return 0;
+}
+
+static inline void stmmac_clk_disable(struct stmmac_priv *priv)
+{
+	if (IS_ERR(priv->stmmac_clk))
+		return;
+
+	clk_disable_unprepare(priv->stmmac_clk);
+}
+static inline int stmmac_clk_get(struct stmmac_priv *priv)
+{
+	priv->stmmac_clk = clk_get(priv->device, NULL);
+
+	if (IS_ERR(priv->stmmac_clk))
+		return PTR_ERR(priv->stmmac_clk);
+
+	return 0;
+}
+#else
+static inline int stmmac_clk_enable(struct stmmac_priv *priv)
+{
+	return 0;
+}
+static inline void stmmac_clk_disable(struct stmmac_priv *priv)
+{
+}
+static inline int stmmac_clk_get(struct stmmac_priv *priv)
+{
+	return 0;
+}
+#endif /* CONFIG_HAVE_CLK */
+
 void stmmac_disable_eee_mode(struct stmmac_priv *priv);
 bool stmmac_eee_init(struct stmmac_priv *priv);
 
@@ -142,7 +200,6 @@
 
 	return err;
 }
-
 static inline void stmmac_unregister_platform(void)
 {
 	platform_driver_unregister(&stmmac_pltfr_driver);
@@ -154,7 +211,6 @@
 
 	return 0;
 }
-
 static inline void stmmac_unregister_platform(void)
 {
 }
@@ -172,7 +228,6 @@
 
 	return err;
 }
-
 static inline void stmmac_unregister_pci(void)
 {
 	pci_unregister_driver(&stmmac_pci_driver);
@@ -184,10 +239,10 @@
 
 	return 0;
 }
-
 static inline void stmmac_unregister_pci(void)
 {
 }
+
 #endif /* CONFIG_STMMAC_PCI */
 
 #endif /* __STMMAC_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index 1372ce2..0644dcd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -27,11 +27,11 @@
 #include <linux/interrupt.h>
 #include <linux/mii.h>
 #include <linux/phy.h>
-#include <linux/net_tstamp.h>
 #include <asm/io.h>
 
 #include "stmmac.h"
 #include "dwmac_dma.h"
+#include "dwmac1000.h"
 
 #define REG_SPACE_SIZE	0x1054
 #define MAC100_ETHTOOL_NAME	"st_mac100"
@@ -109,33 +109,6 @@
 	STMMAC_STAT(irq_rx_path_in_lpi_mode_n),
 	STMMAC_STAT(irq_rx_path_exit_lpi_mode_n),
 	STMMAC_STAT(phy_eee_wakeup_error_n),
-	/* Extended RDES status */
-	STMMAC_STAT(ip_hdr_err),
-	STMMAC_STAT(ip_payload_err),
-	STMMAC_STAT(ip_csum_bypassed),
-	STMMAC_STAT(ipv4_pkt_rcvd),
-	STMMAC_STAT(ipv6_pkt_rcvd),
-	STMMAC_STAT(rx_msg_type_ext_no_ptp),
-	STMMAC_STAT(rx_msg_type_sync),
-	STMMAC_STAT(rx_msg_type_follow_up),
-	STMMAC_STAT(rx_msg_type_delay_req),
-	STMMAC_STAT(rx_msg_type_delay_resp),
-	STMMAC_STAT(rx_msg_type_pdelay_req),
-	STMMAC_STAT(rx_msg_type_pdelay_resp),
-	STMMAC_STAT(rx_msg_type_pdelay_follow_up),
-	STMMAC_STAT(ptp_frame_type),
-	STMMAC_STAT(ptp_ver),
-	STMMAC_STAT(timestamp_dropped),
-	STMMAC_STAT(av_pkt_rcvd),
-	STMMAC_STAT(av_tagged_pkt_rcvd),
-	STMMAC_STAT(vlan_tag_priority_val),
-	STMMAC_STAT(l3_filter_match),
-	STMMAC_STAT(l4_filter_match),
-	STMMAC_STAT(l3_l4_filter_no_match),
-	/* PCS */
-	STMMAC_STAT(irq_pcs_ane_n),
-	STMMAC_STAT(irq_pcs_link_n),
-	STMMAC_STAT(irq_rgmii_n),
 };
 #define STMMAC_STATS_LEN ARRAY_SIZE(stmmac_gstrings_stats)
 
@@ -238,7 +211,8 @@
 		strlcpy(info->driver, MAC100_ETHTOOL_NAME,
 			sizeof(info->driver));
 
-	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
+	strcpy(info->version, DRV_MODULE_VERSION);
+	info->fw_version[0] = '\0';
 }
 
 static int stmmac_ethtool_getsettings(struct net_device *dev,
@@ -247,70 +221,6 @@
 	struct stmmac_priv *priv = netdev_priv(dev);
 	struct phy_device *phy = priv->phydev;
 	int rc;
-
-	if ((priv->pcs & STMMAC_PCS_RGMII) || (priv->pcs & STMMAC_PCS_SGMII)) {
-		struct rgmii_adv adv;
-
-		if (!priv->xstats.pcs_link) {
-			ethtool_cmd_speed_set(cmd, SPEED_UNKNOWN);
-			cmd->duplex = DUPLEX_UNKNOWN;
-			return 0;
-		}
-		cmd->duplex = priv->xstats.pcs_duplex;
-
-		ethtool_cmd_speed_set(cmd, priv->xstats.pcs_speed);
-
-		/* Get and convert ADV/LP_ADV from the HW AN registers */
-		if (priv->hw->mac->get_adv)
-			priv->hw->mac->get_adv(priv->ioaddr, &adv);
-		else
-			return -EOPNOTSUPP;	/* should never happen indeed */
-
-		/* Encoding of PSE bits is defined in 802.3z, 37.2.1.4 */
-
-		if (adv.pause & STMMAC_PCS_PAUSE)
-			cmd->advertising |= ADVERTISED_Pause;
-		if (adv.pause & STMMAC_PCS_ASYM_PAUSE)
-			cmd->advertising |= ADVERTISED_Asym_Pause;
-		if (adv.lp_pause & STMMAC_PCS_PAUSE)
-			cmd->lp_advertising |= ADVERTISED_Pause;
-		if (adv.lp_pause & STMMAC_PCS_ASYM_PAUSE)
-			cmd->lp_advertising |= ADVERTISED_Asym_Pause;
-
-		/* Reg49[3] always set because ANE is always supported */
-		cmd->autoneg = ADVERTISED_Autoneg;
-		cmd->supported |= SUPPORTED_Autoneg;
-		cmd->advertising |= ADVERTISED_Autoneg;
-		cmd->lp_advertising |= ADVERTISED_Autoneg;
-
-		if (adv.duplex) {
-			cmd->supported |= (SUPPORTED_1000baseT_Full |
-					   SUPPORTED_100baseT_Full |
-					   SUPPORTED_10baseT_Full);
-			cmd->advertising |= (ADVERTISED_1000baseT_Full |
-					     ADVERTISED_100baseT_Full |
-					     ADVERTISED_10baseT_Full);
-		} else {
-			cmd->supported |= (SUPPORTED_1000baseT_Half |
-					   SUPPORTED_100baseT_Half |
-					   SUPPORTED_10baseT_Half);
-			cmd->advertising |= (ADVERTISED_1000baseT_Half |
-					     ADVERTISED_100baseT_Half |
-					     ADVERTISED_10baseT_Half);
-		}
-		if (adv.lp_duplex)
-			cmd->lp_advertising |= (ADVERTISED_1000baseT_Full |
-						ADVERTISED_100baseT_Full |
-						ADVERTISED_10baseT_Full);
-		else
-			cmd->lp_advertising |= (ADVERTISED_1000baseT_Half |
-						ADVERTISED_100baseT_Half |
-						ADVERTISED_10baseT_Half);
-		cmd->port = PORT_OTHER;
-
-		return 0;
-	}
-
 	if (phy == NULL) {
 		pr_err("%s: %s: PHY is not registered\n",
 		       __func__, dev->name);
@@ -322,9 +232,7 @@
 		return -EBUSY;
 	}
 	cmd->transceiver = XCVR_INTERNAL;
-	spin_lock_irq(&priv->lock);
 	rc = phy_ethtool_gset(phy, cmd);
-	spin_unlock_irq(&priv->lock);
 	return rc;
 }
 
@@ -335,34 +243,7 @@
 	struct phy_device *phy = priv->phydev;
 	int rc;
 
-	if ((priv->pcs & STMMAC_PCS_RGMII) || (priv->pcs & STMMAC_PCS_SGMII)) {
-		u32 mask = ADVERTISED_Autoneg | ADVERTISED_Pause;
-
-		/* Only support ANE */
-		if (cmd->autoneg != AUTONEG_ENABLE)
-			return -EINVAL;
-
-		if (cmd->autoneg == AUTONEG_ENABLE) {
-			mask &= (ADVERTISED_1000baseT_Half |
-			ADVERTISED_1000baseT_Full |
-			ADVERTISED_100baseT_Half |
-			ADVERTISED_100baseT_Full |
-			ADVERTISED_10baseT_Half |
-			ADVERTISED_10baseT_Full);
-
-			spin_lock(&priv->lock);
-			if (priv->hw->mac->ctrl_ane)
-				priv->hw->mac->ctrl_ane(priv->ioaddr, 1);
-			spin_unlock(&priv->lock);
-		}
-
-		return 0;
-	}
-
-	spin_lock(&priv->lock);
 	rc = phy_ethtool_sset(phy, cmd);
-	spin_unlock(&priv->lock);
-
 	return rc;
 }
 
@@ -394,7 +275,7 @@
 static void stmmac_ethtool_gregs(struct net_device *dev,
 			  struct ethtool_regs *regs, void *space)
 {
-	int i;
+	int i, offset = 0;
 	u32 *reg_space = (u32 *) space;
 
 	struct stmmac_priv *priv = netdev_priv(dev);
@@ -415,9 +296,20 @@
 		/* MAC registers */
 		for (i = 0; i < 55; i++)
 			reg_space[i] = readl(priv->ioaddr + (i * 4));
+
+		/* VLAN registers */
+		offset = i;
+		reg_space[offset++] = readl(priv->ioaddr + GMAC_VLAN_TAG_REP);
+		reg_space[offset++] = readl(priv->ioaddr + GMAC_VLAN_HASH);
+
+		/* 1588 registers */
+		for(i = 0; i < 13; i++);
+			reg_space[i + offset] = readl(priv->ioaddr + (GMAC_TS_CTRL + (i * 4)));
+
 		/* DMA registers */
+		offset += i;
 		for (i = 0; i < 22; i++)
-			reg_space[i + 55] =
+			reg_space[i + offset] =
 			    readl(priv->ioaddr + (DMA_BUS_MODE + (i * 4)));
 	}
 }
@@ -428,9 +320,6 @@
 {
 	struct stmmac_priv *priv = netdev_priv(netdev);
 
-	if (priv->pcs)	/* FIXME */
-		return;
-
 	spin_lock(&priv->lock);
 
 	pause->rx_pause = 0;
@@ -454,9 +343,6 @@
 	int new_pause = FLOW_OFF;
 	int ret = 0;
 
-	if (priv->pcs)	/* FIXME */
-		return -EOPNOTSUPP;
-
 	spin_lock(&priv->lock);
 
 	if (pause->rx_pause)
@@ -726,38 +612,6 @@
 	return 0;
 }
 
-static int stmmac_get_ts_info(struct net_device *dev,
-			      struct ethtool_ts_info *info)
-{
-	struct stmmac_priv *priv = netdev_priv(dev);
-
-	if ((priv->hwts_tx_en) && (priv->hwts_rx_en)) {
-
-		info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
-					SOF_TIMESTAMPING_RX_HARDWARE |
-					SOF_TIMESTAMPING_RAW_HARDWARE;
-
-		if (priv->ptp_clock)
-			info->phc_index = ptp_clock_index(priv->ptp_clock);
-
-		info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
-
-		info->rx_filters = ((1 << HWTSTAMP_FILTER_NONE) |
-				    (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
-				    (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
-				    (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
-				    (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
-				    (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
-				    (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
-				    (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |
-				    (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |
-				    (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
-				    (1 << HWTSTAMP_FILTER_ALL));
-		return 0;
-	} else
-		return ethtool_op_get_ts_info(dev, info);
-}
-
 static const struct ethtool_ops stmmac_ethtool_ops = {
 	.begin = stmmac_check_if_running,
 	.get_drvinfo = stmmac_ethtool_getdrvinfo,
@@ -777,7 +631,7 @@
 	.get_eee = stmmac_ethtool_op_get_eee,
 	.set_eee = stmmac_ethtool_op_set_eee,
 	.get_sset_count	= stmmac_get_sset_count,
-	.get_ts_info = stmmac_get_ts_info,
+	.get_ts_info = ethtool_op_get_ts_info,
 	.get_coalesce = stmmac_get_coalesce,
 	.set_coalesce = stmmac_set_coalesce,
 };
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index b75f4b2..aaccd3a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -28,6 +28,9 @@
 	https://bugzilla.stlinux.com/
 *******************************************************************************/
 
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+#include <asm/qrk.h>
+#endif
 #include <linux/clk.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
@@ -46,9 +49,7 @@
 #ifdef CONFIG_STMMAC_DEBUG_FS
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#endif /* CONFIG_STMMAC_DEBUG_FS */
-#include <linux/net_tstamp.h>
-#include "stmmac_ptp.h"
+#endif
 #include "stmmac.h"
 
 #undef STMMAC_DEBUG
@@ -81,14 +82,14 @@
 #define JUMBO_LEN	9000
 
 /* Module parameters */
-#define TX_TIMEO	5000
+#define TX_TIMEO 5000 /* default 5 seconds */
 static int watchdog = TX_TIMEO;
 module_param(watchdog, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(watchdog, "Transmit timeout in milliseconds (default 5s)");
+MODULE_PARM_DESC(watchdog, "Transmit timeout in milliseconds");
 
-static int debug = -1;
+static int debug = -1;		/* -1: default, 0: no output, 16:  all */
 module_param(debug, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Message Level (-1: default, 0: no output, 16: all)");
+MODULE_PARM_DESC(debug, "Message Level (0: no output, 16: all)");
 
 int phyaddr = -1;
 module_param(phyaddr, int, S_IRUGO);
@@ -130,20 +131,15 @@
 static int eee_timer = STMMAC_DEFAULT_LPI_TIMER;
 module_param(eee_timer, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(eee_timer, "LPI tx expiration time in msec");
-#define STMMAC_LPI_T(x) (jiffies + msecs_to_jiffies(x))
-
-/* By default the driver will use the ring mode to manage tx and rx descriptors
- * but passing this value so user can force to use the chain instead of the ring
- */
-static unsigned int chain_mode;
-module_param(chain_mode, int, S_IRUGO);
-MODULE_PARM_DESC(chain_mode, "To use chain instead of ring mode");
+#define STMMAC_LPI_TIMER(x) (jiffies + msecs_to_jiffies(x))
 
 static irqreturn_t stmmac_interrupt(int irq, void *dev_id);
 
 #ifdef CONFIG_STMMAC_DEBUG_FS
 static int stmmac_init_fs(struct net_device *dev);
 static void stmmac_exit_fs(void);
+static int debugfs_registered = 0;
+
 #endif
 
 #define STMMAC_COAL_TIMER(x) (jiffies + usecs_to_jiffies(x))
@@ -173,18 +169,6 @@
 		eee_timer = STMMAC_DEFAULT_LPI_TIMER;
 }
 
-/**
- * stmmac_clk_csr_set - dynamically set the MDC clock
- * @priv: driver private structure
- * Description: this is to dynamically set the MDC clock according to the csr
- * clock input.
- * Note:
- *	If a specific clk_csr value is passed from the platform
- *	this means that the CSR Clock Range selection cannot be
- *	changed at run-time and it is fixed (as reported in the driver
- *	documentation). Viceversa the driver will try to set the MDC
- *	clock dynamically according to the actual clock input.
- */
 static void stmmac_clk_csr_set(struct stmmac_priv *priv)
 {
 	u32 clk_rate;
@@ -192,12 +176,7 @@
 	clk_rate = clk_get_rate(priv->stmmac_clk);
 
 	/* Platform provided default clk_csr would be assumed valid
-	 * for all other cases except for the below mentioned ones.
-	 * For values higher than the IEEE 802.3 specified frequency
-	 * we can not estimate the proper divider as it is not known
-	 * the frequency of clk_csr_i. So we do not change the default
-	 * divider.
-	 */
+	 * for all other cases except for the below mentioned ones. */
 	if (!(priv->clk_csr & MAC_CSR_H_FRQ_MASK)) {
 		if (clk_rate < CSR_F_35M)
 			priv->clk_csr = STMMAC_CSR_20_35M;
@@ -211,7 +190,10 @@
 			priv->clk_csr = STMMAC_CSR_150_250M;
 		else if ((clk_rate >= CSR_F_250M) && (clk_rate < CSR_F_300M))
 			priv->clk_csr = STMMAC_CSR_250_300M;
-	}
+	} /* For values higher than the IEEE 802.3 specified frequency
+	   * we can not estimate the proper divider as it is not known
+	   * the frequency of clk_csr_i. So we do not change the default
+	   * divider. */
 }
 
 #if defined(STMMAC_XMIT_DEBUG) || defined(STMMAC_RX_DEBUG)
@@ -236,25 +218,18 @@
 	return priv->dirty_tx + priv->dma_tx_size - priv->cur_tx - 1;
 }
 
-/**
- * stmmac_hw_fix_mac_speed: callback for speed selection
- * @priv: driver private structure
- * Description: on some platforms (e.g. ST), some HW system configuraton
- * registers have to be set according to the link speed negotiated.
+/* On some ST platforms, some HW system configuraton registers have to be
+ * set according to the link speed negotiated.
  */
 static inline void stmmac_hw_fix_mac_speed(struct stmmac_priv *priv)
 {
 	struct phy_device *phydev = priv->phydev;
 
 	if (likely(priv->plat->fix_mac_speed))
-		priv->plat->fix_mac_speed(priv->plat->bsp_priv, phydev->speed);
+		priv->plat->fix_mac_speed(priv->plat->bsp_priv,
+					  phydev->speed);
 }
 
-/**
- * stmmac_enable_eee_mode: Check and enter in LPI mode
- * @priv: driver private structure
- * Description: this function is to verify and enter in LPI mode for EEE.
- */
 static void stmmac_enable_eee_mode(struct stmmac_priv *priv)
 {
 	/* Check and enter in LPI mode */
@@ -263,24 +238,19 @@
 		priv->hw->mac->set_eee_mode(priv->ioaddr);
 }
 
-/**
- * stmmac_disable_eee_mode: disable/exit from EEE
- * @priv: driver private structure
- * Description: this function is to exit and disable EEE in case of
- * LPI state is true. This is called by the xmit.
- */
 void stmmac_disable_eee_mode(struct stmmac_priv *priv)
 {
+	/* Exit and disable EEE in case of we are are in LPI state. */
 	priv->hw->mac->reset_eee_mode(priv->ioaddr);
 	del_timer_sync(&priv->eee_ctrl_timer);
 	priv->tx_path_in_lpi_mode = false;
 }
 
 /**
- * stmmac_eee_ctrl_timer: EEE TX SW timer.
+ * stmmac_eee_ctrl_timer
  * @arg : data hook
  * Description:
- *  if there is no data transfer and if we are not in LPI state,
+ *  If there is no data transfer and if we are not in LPI state,
  *  then MAC Transmitter can be moved to LPI state.
  */
 static void stmmac_eee_ctrl_timer(unsigned long arg)
@@ -288,12 +258,12 @@
 	struct stmmac_priv *priv = (struct stmmac_priv *)arg;
 
 	stmmac_enable_eee_mode(priv);
-	mod_timer(&priv->eee_ctrl_timer, STMMAC_LPI_T(eee_timer));
+	mod_timer(&priv->eee_ctrl_timer, STMMAC_LPI_TIMER(eee_timer));
 }
 
 /**
- * stmmac_eee_init: init EEE
- * @priv: driver private structure
+ * stmmac_eee_init
+ * @priv: private device pointer
  * Description:
  *  If the EEE support has been enabled while configuring the driver,
  *  if the GMAC actually supports the EEE (from the HW cap reg) and the
@@ -304,34 +274,22 @@
 {
 	bool ret = false;
 
-	/* Using PCS we cannot dial with the phy registers at this stage
-	 * so we do not support extra feature like EEE.
-	 */
-	if ((priv->pcs == STMMAC_PCS_RGMII) || (priv->pcs == STMMAC_PCS_TBI) ||
-	    (priv->pcs == STMMAC_PCS_RTBI))
-		goto out;
-
 	/* MAC core supports the EEE feature. */
 	if (priv->dma_cap.eee) {
 		/* Check if the PHY supports EEE */
 		if (phy_init_eee(priv->phydev, 1))
 			goto out;
 
-		if (!priv->eee_active) {
-			priv->eee_active = 1;
-			init_timer(&priv->eee_ctrl_timer);
-			priv->eee_ctrl_timer.function = stmmac_eee_ctrl_timer;
-			priv->eee_ctrl_timer.data = (unsigned long)priv;
-			priv->eee_ctrl_timer.expires = STMMAC_LPI_T(eee_timer);
-			add_timer(&priv->eee_ctrl_timer);
-
-			priv->hw->mac->set_eee_timer(priv->ioaddr,
-						     STMMAC_DEFAULT_LIT_LS,
-						     priv->tx_lpi_timer);
-		} else
-			/* Set HW EEE according to the speed */
-			priv->hw->mac->set_eee_pls(priv->ioaddr,
-						   priv->phydev->link);
+		priv->eee_active = 1;
+		init_timer(&priv->eee_ctrl_timer);
+		priv->eee_ctrl_timer.function = stmmac_eee_ctrl_timer;
+		priv->eee_ctrl_timer.data = (unsigned long)priv;
+		priv->eee_ctrl_timer.expires = STMMAC_LPI_TIMER(eee_timer);
+		add_timer(&priv->eee_ctrl_timer);
+
+		priv->hw->mac->set_eee_timer(priv->ioaddr,
+					     STMMAC_DEFAULT_LIT_LS_TIMER,
+					     priv->tx_lpi_timer);
 
 		pr_info("stmmac: Energy-Efficient Ethernet initialized\n");
 
@@ -341,343 +299,14 @@
 	return ret;
 }
 
-/* stmmac_get_tx_hwtstamp: get HW TX timestamps
- * @priv: driver private structure
- * @entry : descriptor index to be used.
- * @skb : the socket buffer
- * Description :
- * This function will read timestamp from the descriptor & pass it to stack.
- * and also perform some sanity checks.
- */
-static void stmmac_get_tx_hwtstamp(struct stmmac_priv *priv,
-				   unsigned int entry, struct sk_buff *skb)
-{
-	struct skb_shared_hwtstamps shhwtstamp;
-	u64 ns;
-	void *desc = NULL;
-
-	if (!priv->hwts_tx_en)
-		return;
-
-	/* exit if skb doesn't support hw tstamp */
-	if (likely(!(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)))
-		return;
-
-	if (priv->adv_ts)
-		desc = (priv->dma_etx + entry);
-	else
-		desc = (priv->dma_tx + entry);
-
-	/* check tx tstamp status */
-	if (!priv->hw->desc->get_tx_timestamp_status((struct dma_desc *)desc))
-		return;
-
-	/* get the valid tstamp */
-	ns = priv->hw->desc->get_timestamp(desc, priv->adv_ts);
-
-	memset(&shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
-	shhwtstamp.hwtstamp = ns_to_ktime(ns);
-	/* pass tstamp to stack */
-	skb_tstamp_tx(skb, &shhwtstamp);
-
-	return;
-}
-
-/* stmmac_get_rx_hwtstamp: get HW RX timestamps
- * @priv: driver private structure
- * @entry : descriptor index to be used.
- * @skb : the socket buffer
- * Description :
- * This function will read received packet's timestamp from the descriptor
- * and pass it to stack. It also perform some sanity checks.
- */
-static void stmmac_get_rx_hwtstamp(struct stmmac_priv *priv,
-				   unsigned int entry, struct sk_buff *skb)
-{
-	struct skb_shared_hwtstamps *shhwtstamp = NULL;
-	u64 ns;
-	void *desc = NULL;
-
-	if (!priv->hwts_rx_en)
-		return;
-
-	if (priv->adv_ts)
-		desc = (priv->dma_erx + entry);
-	else
-		desc = (priv->dma_rx + entry);
-
-	/* exit if rx tstamp is not valid */
-	if (!priv->hw->desc->get_rx_timestamp_status(desc, priv->adv_ts))
-		return;
-
-	/* get valid tstamp */
-	ns = priv->hw->desc->get_timestamp(desc, priv->adv_ts);
-	shhwtstamp = skb_hwtstamps(skb);
-	memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
-	shhwtstamp->hwtstamp = ns_to_ktime(ns);
-}
-
-/**
- *  stmmac_hwtstamp_ioctl - control hardware timestamping.
- *  @dev: device pointer.
- *  @ifr: An IOCTL specefic structure, that can contain a pointer to
- *  a proprietary structure used to pass information to the driver.
- *  Description:
- *  This function configures the MAC to enable/disable both outgoing(TX)
- *  and incoming(RX) packets time stamping based on user input.
- *  Return Value:
- *  0 on success and an appropriate -ve integer on failure.
- */
-static int stmmac_hwtstamp_ioctl(struct net_device *dev, struct ifreq *ifr)
-{
-	struct stmmac_priv *priv = netdev_priv(dev);
-	struct hwtstamp_config config;
-	struct timespec now;
-	u64 temp = 0;
-	u32 ptp_v2 = 0;
-	u32 tstamp_all = 0;
-	u32 ptp_over_ipv4_udp = 0;
-	u32 ptp_over_ipv6_udp = 0;
-	u32 ptp_over_ethernet = 0;
-	u32 snap_type_sel = 0;
-	u32 ts_master_en = 0;
-	u32 ts_event_en = 0;
-	u32 value = 0;
-
-	if (!(priv->dma_cap.time_stamp || priv->adv_ts)) {
-		netdev_alert(priv->dev, "No support for HW time stamping\n");
-		priv->hwts_tx_en = 0;
-		priv->hwts_rx_en = 0;
-
-		return -EOPNOTSUPP;
-	}
-
-	if (copy_from_user(&config, ifr->ifr_data,
-			   sizeof(struct hwtstamp_config)))
-		return -EFAULT;
-
-	pr_debug("%s config flags:0x%x, tx_type:0x%x, rx_filter:0x%x\n",
-		 __func__, config.flags, config.tx_type, config.rx_filter);
-
-	/* reserved for future extensions */
-	if (config.flags)
-		return -EINVAL;
-
-	switch (config.tx_type) {
-	case HWTSTAMP_TX_OFF:
-		priv->hwts_tx_en = 0;
-		break;
-	case HWTSTAMP_TX_ON:
-		priv->hwts_tx_en = 1;
-		break;
-	default:
-		return -ERANGE;
-	}
-
-	if (priv->adv_ts) {
-		switch (config.rx_filter) {
-		case HWTSTAMP_FILTER_NONE:
-			/* time stamp no incoming packet at all */
-			config.rx_filter = HWTSTAMP_FILTER_NONE;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
-			/* PTP v1, UDP, any kind of event packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;
-			/* take time stamp for all event messages */
-			snap_type_sel = PTP_TCR_SNAPTYPSEL_1;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
-			/* PTP v1, UDP, Sync packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_SYNC;
-			/* take time stamp for SYNC messages only */
-			ts_event_en = PTP_TCR_TSEVNTENA;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
-			/* PTP v1, UDP, Delay_req packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ;
-			/* take time stamp for Delay_Req messages only */
-			ts_master_en = PTP_TCR_TSMSTRENA;
-			ts_event_en = PTP_TCR_TSEVNTENA;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
-			/* PTP v2, UDP, any kind of event packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;
-			ptp_v2 = PTP_TCR_TSVER2ENA;
-			/* take time stamp for all event messages */
-			snap_type_sel = PTP_TCR_SNAPTYPSEL_1;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
-			/* PTP v2, UDP, Sync packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_SYNC;
-			ptp_v2 = PTP_TCR_TSVER2ENA;
-			/* take time stamp for SYNC messages only */
-			ts_event_en = PTP_TCR_TSEVNTENA;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
-			/* PTP v2, UDP, Delay_req packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ;
-			ptp_v2 = PTP_TCR_TSVER2ENA;
-			/* take time stamp for Delay_Req messages only */
-			ts_master_en = PTP_TCR_TSMSTRENA;
-			ts_event_en = PTP_TCR_TSEVNTENA;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V2_EVENT:
-			/* PTP v2/802.AS1 any layer, any kind of event packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
-			ptp_v2 = PTP_TCR_TSVER2ENA;
-			/* take time stamp for all event messages */
-			snap_type_sel = PTP_TCR_SNAPTYPSEL_1;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			ptp_over_ethernet = PTP_TCR_TSIPENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V2_SYNC:
-			/* PTP v2/802.AS1, any layer, Sync packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V2_SYNC;
-			ptp_v2 = PTP_TCR_TSVER2ENA;
-			/* take time stamp for SYNC messages only */
-			ts_event_en = PTP_TCR_TSEVNTENA;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			ptp_over_ethernet = PTP_TCR_TSIPENA;
-			break;
-
-		case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
-			/* PTP v2/802.AS1, any layer, Delay_req packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V2_DELAY_REQ;
-			ptp_v2 = PTP_TCR_TSVER2ENA;
-			/* take time stamp for Delay_Req messages only */
-			ts_master_en = PTP_TCR_TSMSTRENA;
-			ts_event_en = PTP_TCR_TSEVNTENA;
-
-			ptp_over_ipv4_udp = PTP_TCR_TSIPV4ENA;
-			ptp_over_ipv6_udp = PTP_TCR_TSIPV6ENA;
-			ptp_over_ethernet = PTP_TCR_TSIPENA;
-			break;
-
-		case HWTSTAMP_FILTER_ALL:
-			/* time stamp any incoming packet */
-			config.rx_filter = HWTSTAMP_FILTER_ALL;
-			tstamp_all = PTP_TCR_TSENALL;
-			break;
-
-		default:
-			return -ERANGE;
-		}
-	} else {
-		switch (config.rx_filter) {
-		case HWTSTAMP_FILTER_NONE:
-			config.rx_filter = HWTSTAMP_FILTER_NONE;
-			break;
-		default:
-			/* PTP v1, UDP, any kind of event packet */
-			config.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;
-			break;
-		}
-	}
-	priv->hwts_rx_en = ((config.rx_filter == HWTSTAMP_FILTER_NONE) ? 0 : 1);
-
-	if (!priv->hwts_tx_en && !priv->hwts_rx_en)
-		priv->hw->ptp->config_hw_tstamping(priv->ioaddr, 0);
-	else {
-		value = (PTP_TCR_TSENA | PTP_TCR_TSCFUPDT | PTP_TCR_TSCTRLSSR |
-			 tstamp_all | ptp_v2 | ptp_over_ethernet |
-			 ptp_over_ipv6_udp | ptp_over_ipv4_udp | ts_event_en |
-			 ts_master_en | snap_type_sel);
-
-		priv->hw->ptp->config_hw_tstamping(priv->ioaddr, value);
-
-		/* program Sub Second Increment reg */
-		priv->hw->ptp->config_sub_second_increment(priv->ioaddr);
-
-		/* calculate default added value:
-		 * formula is :
-		 * addend = (2^32)/freq_div_ratio;
-		 * where, freq_div_ratio = STMMAC_SYSCLOCK/50MHz
-		 * hence, addend = ((2^32) * 50MHz)/STMMAC_SYSCLOCK;
-		 * NOTE: STMMAC_SYSCLOCK should be >= 50MHz to
-		 *       achive 20ns accuracy.
-		 *
-		 * 2^x * y == (y << x), hence
-		 * 2^32 * 50000000 ==> (50000000 << 32)
-		 */
-		temp = (u64) (50000000ULL << 32);
-		priv->default_addend = div_u64(temp, STMMAC_SYSCLOCK);
-		priv->hw->ptp->config_addend(priv->ioaddr,
-					     priv->default_addend);
-
-		/* initialize system time */
-		getnstimeofday(&now);
-		priv->hw->ptp->init_systime(priv->ioaddr, now.tv_sec,
-					    now.tv_nsec);
-	}
-
-	return copy_to_user(ifr->ifr_data, &config,
-			    sizeof(struct hwtstamp_config)) ? -EFAULT : 0;
-}
-
-/**
- * stmmac_init_ptp: init PTP
- * @priv: driver private structure
- * Description: this is to verify if the HW supports the PTPv1 or v2.
- * This is done by looking at the HW cap. register.
- * Also it registers the ptp driver.
- */
-static int stmmac_init_ptp(struct stmmac_priv *priv)
-{
-	if (!(priv->dma_cap.time_stamp || priv->dma_cap.atime_stamp))
-		return -EOPNOTSUPP;
-
-	if (netif_msg_hw(priv)) {
-		if (priv->dma_cap.time_stamp) {
-			pr_debug("IEEE 1588-2002 Time Stamp supported\n");
-			priv->adv_ts = 0;
-		}
-		if (priv->dma_cap.atime_stamp && priv->extend_desc) {
-			pr_debug
-			    ("IEEE 1588-2008 Advanced Time Stamp supported\n");
-			priv->adv_ts = 1;
-		}
-	}
-
-	priv->hw->ptp = &stmmac_ptp;
-	priv->hwts_tx_en = 0;
-	priv->hwts_rx_en = 0;
-
-	return stmmac_ptp_register(priv);
-}
-
-static void stmmac_release_ptp(struct stmmac_priv *priv)
+static void stmmac_eee_adjust(struct stmmac_priv *priv)
 {
-	stmmac_ptp_unregister(priv);
+	/* When the EEE has been already initialised we have to
+	 * modify the PLS bit in the LPI ctrl & status reg according
+	 * to the PHY link status. For this reason.
+	 */
+	if (priv->eee_enabled)
+		priv->hw->mac->set_eee_pls(priv->ioaddr, priv->phydev->link);
 }
 
 /**
@@ -725,7 +354,7 @@
 			case 1000:
 				if (likely(priv->plat->has_gmac))
 					ctrl &= ~priv->hw->link.port;
-				stmmac_hw_fix_mac_speed(priv);
+					stmmac_hw_fix_mac_speed(priv);
 				break;
 			case 100:
 			case 10:
@@ -743,8 +372,8 @@
 				break;
 			default:
 				if (netif_msg_link(priv))
-					pr_warn("%s: Speed (%d) not 10/100\n",
-						dev->name, phydev->speed);
+					pr_warning("%s: Speed (%d) is not 10"
+				       " or 100!\n", dev->name, phydev->speed);
 				break;
 			}
 
@@ -767,10 +396,7 @@
 	if (new_state && netif_msg_link(priv))
 		phy_print_status(phydev);
 
-	/* At this stage, it could be needed to setup the EEE or adjust some
-	 * MAC related HW registers.
-	 */
-	priv->eee_enabled = stmmac_eee_init(priv);
+	stmmac_eee_adjust(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -778,31 +404,6 @@
 }
 
 /**
- * stmmac_check_pcs_mode: verify if RGMII/SGMII is supported
- * @priv: driver private structure
- * Description: this is to verify if the HW supports the PCS.
- * Physical Coding Sublayer (PCS) interface that can be used when the MAC is
- * configured for the TBI, RTBI, or SGMII PHY interface.
- */
-static void stmmac_check_pcs_mode(struct stmmac_priv *priv)
-{
-	int interface = priv->plat->interface;
-
-	if (priv->dma_cap.pcs) {
-		if ((interface & PHY_INTERFACE_MODE_RGMII) ||
-		    (interface & PHY_INTERFACE_MODE_RGMII_ID) ||
-		    (interface & PHY_INTERFACE_MODE_RGMII_RXID) ||
-		    (interface & PHY_INTERFACE_MODE_RGMII_TXID)) {
-			pr_debug("STMMAC: PCS RGMII support enable\n");
-			priv->pcs = STMMAC_PCS_RGMII;
-		} else if (interface & PHY_INTERFACE_MODE_SGMII) {
-			pr_debug("STMMAC: PCS SGMII support enable\n");
-			priv->pcs = STMMAC_PCS_SGMII;
-		}
-	}
-}
-
-/**
  * stmmac_init_phy - PHY initialization
  * @dev: net device structure
  * Description: it initializes the driver's PHY state, and attaches the PHY
@@ -823,16 +424,17 @@
 
 	if (priv->plat->phy_bus_name)
 		snprintf(bus_id, MII_BUS_ID_SIZE, "%s-%x",
-			 priv->plat->phy_bus_name, priv->plat->bus_id);
+				priv->plat->phy_bus_name, priv->plat->bus_id);
 	else
 		snprintf(bus_id, MII_BUS_ID_SIZE, "stmmac-%x",
-			 priv->plat->bus_id);
+				priv->plat->bus_id);
 
 	snprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
 		 priv->plat->phy_addr);
 	pr_debug("stmmac_init_phy:  trying to attach to %s\n", phy_id_fmt);
 
-	phydev = phy_connect(dev, phy_id_fmt, &stmmac_adjust_link, interface);
+	phydev = phy_connect(dev, phy_id_fmt, &stmmac_adjust_link, 0,
+			     interface);
 
 	if (IS_ERR(phydev)) {
 		pr_err("%s: Could not attach to PHY\n", dev->name);
@@ -865,57 +467,29 @@
 }
 
 /**
- * stmmac_display_ring: display ring
- * @head: pointer to the head of the ring passed.
+ * display_ring
+ * @p: pointer to the ring.
  * @size: size of the ring.
- * @extend_desc: to verify if extended descriptors are used.
- * Description: display the control/status and buffer descriptors.
+ * Description: display all the descriptors within the ring.
  */
-static void stmmac_display_ring(void *head, int size, int extend_desc)
+static void display_ring(struct dma_desc *p, int size)
 {
+	struct tmp_s {
+		u64 a;
+		unsigned int b;
+		unsigned int c;
+	};
 	int i;
-	struct dma_extended_desc *ep = (struct dma_extended_desc *)head;
-	struct dma_desc *p = (struct dma_desc *)head;
-
 	for (i = 0; i < size; i++) {
-		u64 x;
-		if (extend_desc) {
-			x = *(u64 *) ep;
-			pr_info("%d [0x%x]: 0x%x 0x%x 0x%x 0x%x\n",
-				i, (unsigned int)virt_to_phys(ep),
-				(unsigned int)x, (unsigned int)(x >> 32),
-				ep->basic.des2, ep->basic.des3);
-			ep++;
-		} else {
-			x = *(u64 *) p;
-			pr_info("%d [0x%x]: 0x%x 0x%x 0x%x 0x%x",
-				i, (unsigned int)virt_to_phys(p),
-				(unsigned int)x, (unsigned int)(x >> 32),
-				p->des2, p->des3);
-			p++;
-		}
+		struct tmp_s *x = (struct tmp_s *)(p + i);
+		pr_info("\t%d [0x%x]: DES0=0x%x DES1=0x%x BUF1=0x%x BUF2=0x%x",
+		       i, (unsigned int)virt_to_phys(&p[i]),
+		       (unsigned int)(x->a), (unsigned int)((x->a) >> 32),
+		       x->b, x->c);
 		pr_info("\n");
 	}
 }
 
-static void stmmac_display_rings(struct stmmac_priv *priv)
-{
-	unsigned int txsize = priv->dma_tx_size;
-	unsigned int rxsize = priv->dma_rx_size;
-
-	if (priv->extend_desc) {
-		pr_info("Extended RX descriptor ring:\n");
-		stmmac_display_ring((void *)priv->dma_erx, rxsize, 1);
-		pr_info("Extended TX descriptor ring:\n");
-		stmmac_display_ring((void *)priv->dma_etx, txsize, 1);
-	} else {
-		pr_info("RX descriptor ring:\n");
-		stmmac_display_ring((void *)priv->dma_rx, rxsize, 0);
-		pr_info("TX descriptor ring:\n");
-		stmmac_display_ring((void *)priv->dma_tx, txsize, 0);
-	}
-}
-
 static int stmmac_set_bfsize(int mtu, int bufsize)
 {
 	int ret = bufsize;
@@ -933,62 +507,19 @@
 }
 
 /**
- * stmmac_clear_descriptors: clear descriptors
- * @priv: driver private structure
- * Description: this function is called to clear the tx and rx descriptors
- * in case of both basic and extended descriptors are used.
- */
-static void stmmac_clear_descriptors(struct stmmac_priv *priv)
-{
-	int i;
-	unsigned int txsize = priv->dma_tx_size;
-	unsigned int rxsize = priv->dma_rx_size;
-
-	/* Clear the Rx/Tx descriptors */
-	for (i = 0; i < rxsize; i++)
-		if (priv->extend_desc)
-			priv->hw->desc->init_rx_desc(&priv->dma_erx[i].basic,
-						     priv->use_riwt, priv->mode,
-						     (i == rxsize - 1));
-		else
-			priv->hw->desc->init_rx_desc(&priv->dma_rx[i],
-						     priv->use_riwt, priv->mode,
-						     (i == rxsize - 1));
-	for (i = 0; i < txsize; i++)
-		if (priv->extend_desc)
-			priv->hw->desc->init_tx_desc(&priv->dma_etx[i].basic,
-						     priv->mode,
-						     (i == txsize - 1));
-		else
-			priv->hw->desc->init_tx_desc(&priv->dma_tx[i],
-						     priv->mode,
-						     (i == txsize - 1));
-}
-
-static int stmmac_init_rx_buffers(struct stmmac_priv *priv, struct dma_desc *p,
-				  int i)
-{
-	struct sk_buff *skb;
-
-	skb = __netdev_alloc_skb(priv->dev, priv->dma_buf_sz + NET_IP_ALIGN,
-				 GFP_KERNEL);
-	if (unlikely(skb == NULL)) {
-		pr_err("%s: Rx init fails; skb is NULL\n", __func__);
-		return 1;
-	}
-	skb_reserve(skb, NET_IP_ALIGN);
-	priv->rx_skbuff[i] = skb;
-	priv->rx_skbuff_dma[i] = dma_map_single(priv->device, skb->data,
-						priv->dma_buf_sz,
-						DMA_FROM_DEVICE);
-
-	p->des2 = priv->rx_skbuff_dma[i];
-
-	if ((priv->mode == STMMAC_RING_MODE) &&
-	    (priv->dma_buf_sz == BUF_SIZE_16KiB))
-		priv->hw->ring->init_desc3(p);
-
-	return 0;
+ * init_dma_err_cleanup
+ *
+ * @dev: net device to clean
+ * Description: Does a cleanup if kmalloc fails during init
+ */
+static void init_dma_err_cleanup(struct stmmac_priv * priv)
+{
+	if (priv->tx_skbuff != NULL)
+		kfree(priv->tx_skbuff);
+	if (priv->rx_skbuff_dma != NULL)
+		kfree (priv->rx_skbuff_dma);
+	if (priv->rx_skbuff != NULL)
+		kfree (priv->rx_skbuff);
 }
 
 /**
@@ -998,118 +529,130 @@
  * and allocates the socket buffers. It suppors the chained and ring
  * modes.
  */
-static void init_dma_desc_rings(struct net_device *dev)
+static int init_dma_desc_rings(struct net_device *dev)
 {
 	int i;
 	struct stmmac_priv *priv = netdev_priv(dev);
+	struct sk_buff *skb;
 	unsigned int txsize = priv->dma_tx_size;
 	unsigned int rxsize = priv->dma_rx_size;
-	unsigned int bfsize = 0;
+	unsigned int bfsize;
+	int dis_ic = 0;
+	int des3_as_data_buf = 0;
 
 	/* Set the max buffer size according to the DESC mode
-	 * and the MTU. Note that RING mode allows 16KiB bsize.
-	 */
-	if (priv->mode == STMMAC_RING_MODE)
-		bfsize = priv->hw->ring->set_16kib_bfsize(dev->mtu);
+	 * and the MTU. Note that RING mode allows 16KiB bsize. */
+	bfsize = priv->hw->ring->set_16kib_bfsize(dev->mtu);
 
-	if (bfsize < BUF_SIZE_16KiB)
+	if (bfsize == BUF_SIZE_16KiB)
+		des3_as_data_buf = 1;
+	else
 		bfsize = stmmac_set_bfsize(dev->mtu, priv->dma_buf_sz);
 
 	DBG(probe, INFO, "stmmac: txsize %d, rxsize %d, bfsize %d\n",
 	    txsize, rxsize, bfsize);
 
-	if (priv->extend_desc) {
-		priv->dma_erx = dma_alloc_coherent(priv->device, rxsize *
-						   sizeof(struct
-							  dma_extended_desc),
-						   &priv->dma_rx_phy,
-						   GFP_KERNEL);
-		priv->dma_etx = dma_alloc_coherent(priv->device, txsize *
-						   sizeof(struct
-							  dma_extended_desc),
-						   &priv->dma_tx_phy,
-						   GFP_KERNEL);
-		if ((!priv->dma_erx) || (!priv->dma_etx))
-			return;
-	} else {
-		priv->dma_rx = dma_alloc_coherent(priv->device, rxsize *
+	priv->rx_skbuff_dma = kmalloc(rxsize * sizeof(dma_addr_t), GFP_KERNEL);
+	if (priv->rx_skbuff_dma == NULL)
+		return -ENOMEM;
+
+	priv->rx_skbuff =
+	    kmalloc(sizeof(struct sk_buff *) * rxsize, GFP_KERNEL);
+	if (priv->rx_skbuff == NULL){
+		init_dma_err_cleanup(priv);
+		return -ENOMEM;
+	}
+
+	priv->dma_rx =
+	    (struct dma_desc *)dma_alloc_coherent(priv->device,
+						  rxsize *
 						  sizeof(struct dma_desc),
 						  &priv->dma_rx_phy,
 						  GFP_KERNEL);
-		priv->dma_tx = dma_alloc_coherent(priv->device, txsize *
+	priv->tx_skbuff = kmalloc(sizeof(struct sk_buff *) * txsize,
+				       GFP_KERNEL);
+	if (priv->tx_skbuff == NULL){
+		init_dma_err_cleanup(priv);
+		return -ENOMEM;
+	}
+
+	priv->dma_tx =
+	    (struct dma_desc *)dma_alloc_coherent(priv->device,
+						  txsize *
 						  sizeof(struct dma_desc),
 						  &priv->dma_tx_phy,
 						  GFP_KERNEL);
-		if ((!priv->dma_rx) || (!priv->dma_tx))
-			return;
+
+	if ((priv->dma_rx == NULL) || (priv->dma_tx == NULL)) {
+		init_dma_err_cleanup(priv);
+		pr_err("%s:ERROR allocating the DMA Tx/Rx desc\n", __func__);
+		return -ENOMEM;
 	}
 
-	priv->rx_skbuff_dma = kmalloc_array(rxsize, sizeof(dma_addr_t),
-					    GFP_KERNEL);
-	priv->rx_skbuff = kmalloc_array(rxsize, sizeof(struct sk_buff *),
-					GFP_KERNEL);
-	priv->tx_skbuff_dma = kmalloc_array(txsize, sizeof(dma_addr_t),
-					    GFP_KERNEL);
-	priv->tx_skbuff = kmalloc_array(txsize, sizeof(struct sk_buff *),
-					GFP_KERNEL);
-	if (netif_msg_drv(priv))
-		pr_debug("(%s) dma_rx_phy=0x%08x dma_tx_phy=0x%08x\n", __func__,
-			 (u32) priv->dma_rx_phy, (u32) priv->dma_tx_phy);
+	DBG(probe, INFO, "stmmac (%s) DMA desc: virt addr (Rx %p, "
+	    "Tx %p)\n\tDMA phy addr (Rx 0x%08x, Tx 0x%08x)\n",
+	    dev->name, priv->dma_rx, priv->dma_tx,
+	    (unsigned int)priv->dma_rx_phy, (unsigned int)priv->dma_tx_phy);
 
 	/* RX INITIALIZATION */
-	DBG(probe, INFO, "stmmac: SKB addresses:\nskb\t\tskb data\tdma data\n");
+	DBG(probe, INFO, "stmmac: SKB addresses:\n"
+			 "skb\t\tskb data\tdma data\n");
+
 	for (i = 0; i < rxsize; i++) {
-		struct dma_desc *p;
-		if (priv->extend_desc)
-			p = &((priv->dma_erx + i)->basic);
-		else
-			p = priv->dma_rx + i;
+		struct dma_desc *p = priv->dma_rx + i;
 
-		if (stmmac_init_rx_buffers(priv, p, i))
-			break;
+		skb = __netdev_alloc_skb(dev, bfsize + NET_IP_ALIGN,
+					 GFP_KERNEL);
+		if (unlikely(skb == NULL)) {
+			init_dma_err_cleanup(priv);
+			pr_err("%s: Rx init fails; skb is NULL\n", __func__);
+			return -ENOMEM;
+		}
+		skb_reserve(skb, NET_IP_ALIGN);
+		priv->rx_skbuff[i] = skb;
+		priv->rx_skbuff_dma[i] = dma_map_single(priv->device, skb->data,
+						bfsize, DMA_FROM_DEVICE);
+
+		p->des2 = priv->rx_skbuff_dma[i];
+
+		priv->hw->ring->init_desc3(des3_as_data_buf, p);
 
 		DBG(probe, INFO, "[%p]\t[%p]\t[%x]\n", priv->rx_skbuff[i],
-		    priv->rx_skbuff[i]->data, priv->rx_skbuff_dma[i]);
+			priv->rx_skbuff[i]->data, priv->rx_skbuff_dma[i]);
 	}
 	priv->cur_rx = 0;
 	priv->dirty_rx = (unsigned int)(i - rxsize);
 	priv->dma_buf_sz = bfsize;
 	buf_sz = bfsize;
 
-	/* Setup the chained descriptor addresses */
-	if (priv->mode == STMMAC_CHAIN_MODE) {
-		if (priv->extend_desc) {
-			priv->hw->chain->init(priv->dma_erx, priv->dma_rx_phy,
-					      rxsize, 1);
-			priv->hw->chain->init(priv->dma_etx, priv->dma_tx_phy,
-					      txsize, 1);
-		} else {
-			priv->hw->chain->init(priv->dma_rx, priv->dma_rx_phy,
-					      rxsize, 0);
-			priv->hw->chain->init(priv->dma_tx, priv->dma_tx_phy,
-					      txsize, 0);
-		}
-	}
-
 	/* TX INITIALIZATION */
 	for (i = 0; i < txsize; i++) {
-		struct dma_desc *p;
-		if (priv->extend_desc)
-			p = &((priv->dma_etx + i)->basic);
-		else
-			p = priv->dma_tx + i;
-		p->des2 = 0;
-		priv->tx_skbuff_dma[i] = 0;
 		priv->tx_skbuff[i] = NULL;
+		priv->dma_tx[i].des2 = 0;
 	}
 
+	/* In case of Chained mode this sets the des3 to the next
+	 * element in the chain */
+	priv->hw->ring->init_dma_chain(priv->dma_rx, priv->dma_rx_phy, rxsize);
+	priv->hw->ring->init_dma_chain(priv->dma_tx, priv->dma_tx_phy, txsize);
+
 	priv->dirty_tx = 0;
 	priv->cur_tx = 0;
 
-	stmmac_clear_descriptors(priv);
+	if (priv->use_riwt)
+		dis_ic = 1;
+	/* Clear the Rx/Tx descriptors */
+	priv->hw->desc->init_rx_desc(priv->dma_rx, rxsize, dis_ic);
+	priv->hw->desc->init_tx_desc(priv->dma_tx, txsize);
 
-	if (netif_msg_hw(priv))
-		stmmac_display_rings(priv);
+	if (netif_msg_hw(priv)) {
+		pr_info("RX descriptor ring:\n");
+		display_ring(priv->dma_rx, rxsize);
+		pr_info("TX descriptor ring:\n");
+		display_ring(priv->dma_tx, txsize);
+	}
+
+	return 0;
 }
 
 static void dma_free_rx_skbufs(struct stmmac_priv *priv)
@@ -1132,20 +675,13 @@
 
 	for (i = 0; i < priv->dma_tx_size; i++) {
 		if (priv->tx_skbuff[i] != NULL) {
-			struct dma_desc *p;
-			if (priv->extend_desc)
-				p = &((priv->dma_etx + i)->basic);
-			else
-				p = priv->dma_tx + i;
-
-			if (priv->tx_skbuff_dma[i])
-				dma_unmap_single(priv->device,
-						 priv->tx_skbuff_dma[i],
+			struct dma_desc *p = priv->dma_tx + i;
+			if (p->des2)
+				dma_unmap_single(priv->device, p->des2,
 						 priv->hw->desc->get_tx_len(p),
 						 DMA_TO_DEVICE);
 			dev_kfree_skb_any(priv->tx_skbuff[i]);
 			priv->tx_skbuff[i] = NULL;
-			priv->tx_skbuff_dma[i] = 0;
 		}
 	}
 }
@@ -1156,38 +692,29 @@
 	dma_free_rx_skbufs(priv);
 	dma_free_tx_skbufs(priv);
 
-	/* Free DMA regions of consistent memory previously allocated */
-	if (!priv->extend_desc) {
-		dma_free_coherent(priv->device,
-				  priv->dma_tx_size * sizeof(struct dma_desc),
-				  priv->dma_tx, priv->dma_tx_phy);
-		dma_free_coherent(priv->device,
-				  priv->dma_rx_size * sizeof(struct dma_desc),
-				  priv->dma_rx, priv->dma_rx_phy);
-	} else {
-		dma_free_coherent(priv->device, priv->dma_tx_size *
-				  sizeof(struct dma_extended_desc),
-				  priv->dma_etx, priv->dma_tx_phy);
-		dma_free_coherent(priv->device, priv->dma_rx_size *
-				  sizeof(struct dma_extended_desc),
-				  priv->dma_erx, priv->dma_rx_phy);
-	}
+	/* Free the region of consistent memory previously allocated for
+	 * the DMA */
+	dma_free_coherent(priv->device,
+			  priv->dma_tx_size * sizeof(struct dma_desc),
+			  priv->dma_tx, priv->dma_tx_phy);
+	dma_free_coherent(priv->device,
+			  priv->dma_rx_size * sizeof(struct dma_desc),
+			  priv->dma_rx, priv->dma_rx_phy);
 	kfree(priv->rx_skbuff_dma);
 	kfree(priv->rx_skbuff);
-	kfree(priv->tx_skbuff_dma);
 	kfree(priv->tx_skbuff);
 }
 
 /**
  *  stmmac_dma_operation_mode - HW DMA operation mode
- *  @priv: driver private structure
+ *  @priv : pointer to the private device structure.
  *  Description: it sets the DMA operation mode: tx/rx DMA thresholds
  *  or Store-And-Forward capability.
  */
 static void stmmac_dma_operation_mode(struct stmmac_priv *priv)
 {
 	if (likely(priv->plat->force_sf_dma_mode ||
-		   ((priv->plat->tx_coe) && (!priv->no_csum_insertion)))) {
+		((priv->plat->tx_coe) && (!priv->no_csum_insertion)))) {
 		/*
 		 * In case of GMAC, SF mode can be enabled
 		 * to perform the TX COE in HW. This depends on:
@@ -1195,7 +722,8 @@
 		 * 2) There is no bugged Jumbo frame support
 		 *    that needs to not insert csum in the TDES.
 		 */
-		priv->hw->dma->dma_mode(priv->ioaddr, SF_DMA_MODE, SF_DMA_MODE);
+		priv->hw->dma->dma_mode(priv->ioaddr,
+					SF_DMA_MODE, SF_DMA_MODE);
 		tc = SF_DMA_MODE;
 	} else
 		priv->hw->dma->dma_mode(priv->ioaddr, tc, SF_DMA_MODE);
@@ -1203,7 +731,7 @@
 
 /**
  * stmmac_tx_clean:
- * @priv: driver private structure
+ * @priv: private data pointer
  * Description: it reclaims resources after transmission completes.
  */
 static void stmmac_tx_clean(struct stmmac_priv *priv)
@@ -1218,50 +746,44 @@
 		int last;
 		unsigned int entry = priv->dirty_tx % txsize;
 		struct sk_buff *skb = priv->tx_skbuff[entry];
-		struct dma_desc *p;
-
-		if (priv->extend_desc)
-			p = (struct dma_desc *)(priv->dma_etx + entry);
-		else
-			p = priv->dma_tx + entry;
+		struct dma_desc *p = priv->dma_tx + entry;
 
 		/* Check if the descriptor is owned by the DMA. */
 		if (priv->hw->desc->get_tx_owner(p))
 			break;
 
-		/* Verify tx error by looking at the last segment. */
+		/* Verify tx error by looking at the last segment */
 		last = priv->hw->desc->get_tx_ls(p);
 		if (likely(last)) {
 			int tx_error =
-			    priv->hw->desc->tx_status(&priv->dev->stats,
-						      &priv->xstats, p,
-						      priv->ioaddr);
+				priv->hw->desc->tx_status(&priv->dev->stats,
+							  &priv->xstats, p,
+							  priv->ioaddr);
 			if (likely(tx_error == 0)) {
 				priv->dev->stats.tx_packets++;
 				priv->xstats.tx_pkt_n++;
 			} else
 				priv->dev->stats.tx_errors++;
-
-			stmmac_get_tx_hwtstamp(priv, entry, skb);
 		}
 		TX_DBG("%s: curr %d, dirty %d\n", __func__,
-		       priv->cur_tx, priv->dirty_tx);
+			priv->cur_tx, priv->dirty_tx);
 
-		if (likely(priv->tx_skbuff_dma[entry])) {
-			dma_unmap_single(priv->device,
-					 priv->tx_skbuff_dma[entry],
+		if (likely(p->des2))
+			dma_unmap_single(priv->device, p->des2,
 					 priv->hw->desc->get_tx_len(p),
 					 DMA_TO_DEVICE);
-			priv->tx_skbuff_dma[entry] = 0;
-		}
-		priv->hw->ring->clean_desc3(priv, p);
+		priv->hw->ring->clean_desc3(p);
+
+#ifdef CONFIG_STMMAC_PTP
+		stmmac_ptp_tx_hwtstamp(priv, p, skb);
+#endif
 
 		if (likely(skb != NULL)) {
 			dev_kfree_skb(skb);
 			priv->tx_skbuff[entry] = NULL;
 		}
 
-		priv->hw->desc->release_tx_desc(p, priv->mode);
+		priv->hw->desc->release_tx_desc(p);
 
 		priv->dirty_tx++;
 	}
@@ -1269,7 +791,7 @@
 		     stmmac_tx_avail(priv) > STMMAC_TX_THRESH(priv))) {
 		netif_tx_lock(priv->dev);
 		if (netif_queue_stopped(priv->dev) &&
-		    stmmac_tx_avail(priv) > STMMAC_TX_THRESH(priv)) {
+		     stmmac_tx_avail(priv) > STMMAC_TX_THRESH(priv)) {
 			TX_DBG("%s: restart transmit\n", __func__);
 			netif_wake_queue(priv->dev);
 		}
@@ -1278,7 +800,7 @@
 
 	if ((priv->eee_enabled) && (!priv->tx_path_in_lpi_mode)) {
 		stmmac_enable_eee_mode(priv);
-		mod_timer(&priv->eee_ctrl_timer, STMMAC_LPI_T(eee_timer));
+		mod_timer(&priv->eee_ctrl_timer, STMMAC_LPI_TIMER(eee_timer));
 	}
 	spin_unlock(&priv->tx_lock);
 }
@@ -1293,29 +815,20 @@
 	priv->hw->dma->disable_dma_irq(priv->ioaddr);
 }
 
+
 /**
- * stmmac_tx_err: irq tx error mng function
- * @priv: driver private structure
+ * stmmac_tx_err:
+ * @priv: pointer to the private device structure
  * Description: it cleans the descriptors and restarts the transmission
  * in case of errors.
  */
 static void stmmac_tx_err(struct stmmac_priv *priv)
 {
-	int i;
-	int txsize = priv->dma_tx_size;
 	netif_stop_queue(priv->dev);
 
 	priv->hw->dma->stop_tx(priv->ioaddr);
 	dma_free_tx_skbufs(priv);
-	for (i = 0; i < txsize; i++)
-		if (priv->extend_desc)
-			priv->hw->desc->init_tx_desc(&priv->dma_etx[i].basic,
-						     priv->mode,
-						     (i == txsize - 1));
-		else
-			priv->hw->desc->init_tx_desc(&priv->dma_tx[i],
-						     priv->mode,
-						     (i == txsize - 1));
+	priv->hw->desc->init_tx_desc(priv->dma_tx, priv->dma_tx_size);
 	priv->dirty_tx = 0;
 	priv->cur_tx = 0;
 	priv->hw->dma->start_tx(priv->ioaddr);
@@ -1324,14 +837,6 @@
 	netif_wake_queue(priv->dev);
 }
 
-/**
- * stmmac_dma_interrupt: DMA ISR
- * @priv: driver private structure
- * Description: this is the DMA ISR. It is called by the main ISR.
- * It calls the dwmac dma routine to understand which type of interrupt
- * happened. In case of there is a Normal interrupt and either TX or RX
- * interrupt happened so the NAPI is scheduled.
- */
 static void stmmac_dma_interrupt(struct stmmac_priv *priv)
 {
 	int status;
@@ -1354,16 +859,13 @@
 		stmmac_tx_err(priv);
 }
 
-/**
- * stmmac_mmc_setup: setup the Mac Management Counters (MMC)
- * @priv: driver private structure
- * Description: this masks the MMC irq, in fact, the counters are managed in SW.
- */
 static void stmmac_mmc_setup(struct stmmac_priv *priv)
 {
 	unsigned int mode = MMC_CNTRL_RESET_ON_READ | MMC_CNTRL_COUNTER_RESET |
-	    MMC_CNTRL_PRESET | MMC_CNTRL_FULL_HALF_PRESET;
+			    MMC_CNTRL_PRESET | MMC_CNTRL_FULL_HALF_PRESET;
 
+	/* Mask MMC irq, counters are managed in SW and registers
+	 * are cleared on each READ eventually. */
 	dwmac_mmc_intr_all_mask(priv->ioaddr);
 
 	if (priv->dma_cap.rmon) {
@@ -1377,7 +879,8 @@
 {
 	u32 hwid = priv->hw->synopsys_uid;
 
-	/* Check Synopsys Id (not available on old chips) */
+	/* Only check valid Synopsys Id because old MAC chips
+	 * have no HW registers where get the ID */
 	if (likely(hwid)) {
 		u32 uid = ((hwid & 0x0000ff00) >> 8);
 		u32 synid = (hwid & 0x000000ff);
@@ -1391,24 +894,14 @@
 }
 
 /**
- * stmmac_selec_desc_mode: to select among: normal/alternate/extend descriptors
- * @priv: driver private structure
- * Description: select the Enhanced/Alternate or Normal descriptors.
- * In case of Enhanced/Alternate, it looks at the extended descriptors are
- * supported by the HW cap. register.
+ * stmmac_selec_desc_mode
+ * @priv : private structure
+ * Description: select the Enhanced/Alternate or Normal descriptors
  */
 static void stmmac_selec_desc_mode(struct stmmac_priv *priv)
 {
 	if (priv->plat->enh_desc) {
 		pr_info(" Enhanced/Alternate descriptors\n");
-
-		/* GMAC older than 3.50 has no extended descriptors */
-		if (priv->synopsys_id >= DWMAC_CORE_3_50) {
-			pr_info("\tEnabled extended descriptors\n");
-			priv->extend_desc = 1;
-		} else
-			pr_warn("Extended descriptors not supported\n");
-
 		priv->hw->desc = &enh_desc_ops;
 	} else {
 		pr_info(" Normal descriptors\n");
@@ -1417,8 +910,8 @@
 }
 
 /**
- * stmmac_get_hw_features: get MAC capabilities from the HW cap. register.
- * @priv: driver private structure
+ * stmmac_get_hw_features
+ * @priv : private device pointer
  * Description:
  *  new GMAC chip generations have a new register to indicate the
  *  presence of the optional feature/functions.
@@ -1436,78 +929,69 @@
 		priv->dma_cap.mbps_1000 = (hw_cap & DMA_HW_FEAT_GMIISEL) >> 1;
 		priv->dma_cap.half_duplex = (hw_cap & DMA_HW_FEAT_HDSEL) >> 2;
 		priv->dma_cap.hash_filter = (hw_cap & DMA_HW_FEAT_HASHSEL) >> 4;
-		priv->dma_cap.multi_addr = (hw_cap & DMA_HW_FEAT_ADDMAC) >> 5;
+		priv->dma_cap.multi_addr =
+			(hw_cap & DMA_HW_FEAT_ADDMACADRSEL) >> 5;
 		priv->dma_cap.pcs = (hw_cap & DMA_HW_FEAT_PCSSEL) >> 6;
 		priv->dma_cap.sma_mdio = (hw_cap & DMA_HW_FEAT_SMASEL) >> 8;
 		priv->dma_cap.pmt_remote_wake_up =
-		    (hw_cap & DMA_HW_FEAT_RWKSEL) >> 9;
+			(hw_cap & DMA_HW_FEAT_RWKSEL) >> 9;
 		priv->dma_cap.pmt_magic_frame =
-		    (hw_cap & DMA_HW_FEAT_MGKSEL) >> 10;
+			(hw_cap & DMA_HW_FEAT_MGKSEL) >> 10;
 		/* MMC */
 		priv->dma_cap.rmon = (hw_cap & DMA_HW_FEAT_MMCSEL) >> 11;
-		/* IEEE 1588-2002 */
+		/* IEEE 1588-2002*/
 		priv->dma_cap.time_stamp =
-		    (hw_cap & DMA_HW_FEAT_TSVER1SEL) >> 12;
-		/* IEEE 1588-2008 */
+			(hw_cap & DMA_HW_FEAT_TSVER1SEL) >> 12;
+		/* IEEE 1588-2008*/
 		priv->dma_cap.atime_stamp =
-		    (hw_cap & DMA_HW_FEAT_TSVER2SEL) >> 13;
+			(hw_cap & DMA_HW_FEAT_TSVER2SEL) >> 13;
 		/* 802.3az - Energy-Efficient Ethernet (EEE) */
 		priv->dma_cap.eee = (hw_cap & DMA_HW_FEAT_EEESEL) >> 14;
 		priv->dma_cap.av = (hw_cap & DMA_HW_FEAT_AVSEL) >> 15;
 		/* TX and RX csum */
 		priv->dma_cap.tx_coe = (hw_cap & DMA_HW_FEAT_TXCOESEL) >> 16;
 		priv->dma_cap.rx_coe_type1 =
-		    (hw_cap & DMA_HW_FEAT_RXTYP1COE) >> 17;
+			(hw_cap & DMA_HW_FEAT_RXTYP1COE) >> 17;
 		priv->dma_cap.rx_coe_type2 =
-		    (hw_cap & DMA_HW_FEAT_RXTYP2COE) >> 18;
+			(hw_cap & DMA_HW_FEAT_RXTYP2COE) >> 18;
 		priv->dma_cap.rxfifo_over_2048 =
-		    (hw_cap & DMA_HW_FEAT_RXFIFOSIZE) >> 19;
+			(hw_cap & DMA_HW_FEAT_RXFIFOSIZE) >> 19;
 		/* TX and RX number of channels */
 		priv->dma_cap.number_rx_channel =
-		    (hw_cap & DMA_HW_FEAT_RXCHCNT) >> 20;
+			(hw_cap & DMA_HW_FEAT_RXCHCNT) >> 20;
 		priv->dma_cap.number_tx_channel =
-		    (hw_cap & DMA_HW_FEAT_TXCHCNT) >> 22;
-		/* Alternate (enhanced) DESC mode */
-		priv->dma_cap.enh_desc = (hw_cap & DMA_HW_FEAT_ENHDESSEL) >> 24;
+			(hw_cap & DMA_HW_FEAT_TXCHCNT) >> 22;
+		/* Alternate (enhanced) DESC mode*/
+		priv->dma_cap.enh_desc =
+			(hw_cap & DMA_HW_FEAT_ENHDESSEL) >> 24;
 	}
 
 	return hw_cap;
 }
 
-/**
- * stmmac_check_ether_addr: check if the MAC addr is valid
- * @priv: driver private structure
- * Description:
- * it is to verify if the MAC address is valid, in case of failures it
- * generates a random MAC address
- */
 static void stmmac_check_ether_addr(struct stmmac_priv *priv)
 {
+	/* verify if the MAC address is valid, in case of failures it
+	 * generates a random MAC address */
 	if (!is_valid_ether_addr(priv->dev->dev_addr)) {
 		priv->hw->mac->get_umac_addr((void __iomem *)
 					     priv->dev->base_addr,
 					     priv->dev->dev_addr, 0);
-		if (!is_valid_ether_addr(priv->dev->dev_addr))
+		if  (!is_valid_ether_addr(priv->dev->dev_addr))
 			eth_hw_addr_random(priv->dev);
 	}
-	pr_warn("%s: device MAC address %pM\n", priv->dev->name,
-		priv->dev->dev_addr);
+	pr_warning("%s: device MAC address %pM\n", priv->dev->name,
+						   priv->dev->dev_addr);
 }
 
-/**
- * stmmac_init_dma_engine: DMA init.
- * @priv: driver private structure
- * Description:
- * It inits the DMA invoking the specific MAC/GMAC callback.
- * Some DMA parameters can be passed from the platform;
- * in case of these are not passed a default is kept for the MAC or GMAC.
- */
 static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 {
 	int pbl = DEFAULT_DMA_PBL, fixed_burst = 0, burst_len = 0;
 	int mixed_burst = 0;
-	int atds = 0;
 
+	/* Some DMA parameters can be passed from the platform;
+	 * in case of these are not passed we keep a default
+	 * (good for all the chips) and init the DMA! */
 	if (priv->plat->dma_cfg) {
 		pbl = priv->plat->dma_cfg->pbl;
 		fixed_burst = priv->plat->dma_cfg->fixed_burst;
@@ -1515,16 +999,32 @@
 		burst_len = priv->plat->dma_cfg->burst_len;
 	}
 
-	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
-		atds = 1;
-
 	return priv->hw->dma->init(priv->ioaddr, pbl, fixed_burst, mixed_burst,
 				   burst_len, priv->dma_tx_phy,
-				   priv->dma_rx_phy, atds);
+				   priv->dma_rx_phy);
+}
+
+/**
+ *  stmmac_hw_set_rx_ipc
+ *  @priv : pointer to the private device structure.
+ *  Enables RX IPC offload if the feature is supported in hardware
+ */
+static int stmmac_hw_set_rx_ipc(struct stmmac_priv *priv, bool on)
+{
+	int ret = 0;
+
+	/* Enable the IPC (Checksum Offload) and check if the feature has been
+	 * enabled during the core configuration. */
+	ret = priv->hw->mac->set_rx_ipc(priv->ioaddr, on);
+	if (on == true && !ret) {
+		pr_warning(" RX IPC Checksum Offload not configured.\n");
+		priv->plat->rx_coe = STMMAC_RX_COE_NONE;
+	}
+	return ret;
 }
 
 /**
- * stmmac_tx_timer: mitigation sw timer for tx.
+ * stmmac_tx_timer:
  * @data: data pointer
  * Description:
  * This is the timer handler to directly invoke the stmmac_tx_clean.
@@ -1537,8 +1037,8 @@
 }
 
 /**
- * stmmac_init_tx_coalesce: init tx mitigation options.
- * @priv: driver private structure
+ * stmmac_tx_timer:
+ * @priv: private data structure
  * Description:
  * This inits the transmit coalesce parameters: i.e. timer rate,
  * timer handler and default threshold used for enabling the
@@ -1573,21 +1073,22 @@
 
 	stmmac_check_ether_addr(priv);
 
-	if (priv->pcs != STMMAC_PCS_RGMII && priv->pcs != STMMAC_PCS_TBI &&
-	    priv->pcs != STMMAC_PCS_RTBI) {
-		ret = stmmac_init_phy(dev);
-		if (ret) {
-			pr_err("%s: Cannot attach to PHY (error: %d)\n",
-			       __func__, ret);
-			goto open_error;
-		}
+	ret = stmmac_init_phy(dev);
+	if (unlikely(ret)) {
+		pr_err("%s: Cannot attach to PHY (error: %d)\n", __func__, ret);
+		goto open_error;
 	}
 
 	/* Create and initialize the TX/RX descriptors chains. */
 	priv->dma_tx_size = STMMAC_ALIGN(dma_txsize);
 	priv->dma_rx_size = STMMAC_ALIGN(dma_rxsize);
 	priv->dma_buf_sz = STMMAC_ALIGN(buf_sz);
-	init_dma_desc_rings(dev);
+	ret = init_dma_desc_rings(dev);
+	if (ret < 0){
+		pr_err("%s: DMA initialization failed\n", __func__);
+		goto open_error;
+	}
+	
 
 	/* DMA initialization and SW reset */
 	ret = stmmac_init_dma_engine(priv);
@@ -1608,7 +1109,7 @@
 
 	/* Request the IRQ lines */
 	ret = request_irq(dev->irq, stmmac_interrupt,
-			  IRQF_SHARED, dev->name, dev);
+			 IRQF_SHARED, dev->name, dev);
 	if (unlikely(ret < 0)) {
 		pr_err("%s: ERROR: allocating the IRQ %d (error: %d)\n",
 		       __func__, dev->irq, ret);
@@ -1620,8 +1121,8 @@
 		ret = request_irq(priv->wol_irq, stmmac_interrupt,
 				  IRQF_SHARED, dev->name, dev);
 		if (unlikely(ret < 0)) {
-			pr_err("%s: ERROR: allocating the WoL IRQ %d (%d)\n",
-			       __func__, priv->wol_irq, ret);
+			pr_err("%s: ERROR: allocating the ext WoL IRQ %d "
+			       "(error: %d)\n",	__func__, priv->wol_irq, ret);
 			goto open_error_wolirq;
 		}
 	}
@@ -1643,20 +1144,22 @@
 	/* Set the HW DMA mode and the COE */
 	stmmac_dma_operation_mode(priv);
 
+	/* Enable RX IPC if supported by silicon */
+	ret = stmmac_hw_set_rx_ipc(priv, true);
+
 	/* Extra statistics */
 	memset(&priv->xstats, 0, sizeof(struct stmmac_extra_stats));
 	priv->xstats.threshold = tc;
 
 	stmmac_mmc_setup(priv);
 
-	ret = stmmac_init_ptp(priv);
-	if (ret)
-		pr_warn("%s: failed PTP initialisation\n", __func__);
-
 #ifdef CONFIG_STMMAC_DEBUG_FS
-	ret = stmmac_init_fs(dev);
-	if (ret < 0)
-		pr_warn("%s: failed debugFS registration\n", __func__);
+	if (debugfs_registered == 0){
+		debugfs_registered = 1;
+		ret = stmmac_init_fs(dev);
+		if (ret < 0)
+			pr_warning("%s: failed debugFS registration\n", __func__);
+	}
 #endif
 	/* Start the ball rolling... */
 	DBG(probe, DEBUG, "%s: DMA RX/TX processes started...\n", dev->name);
@@ -1672,8 +1175,7 @@
 	if (priv->phydev)
 		phy_start(priv->phydev);
 
-	priv->tx_lpi_timer = STMMAC_DEFAULT_TWT_LS;
-
+	priv->tx_lpi_timer = STMMAC_DEFAULT_TWT_LS_TIMER;
 	priv->eee_enabled = stmmac_eee_init(priv);
 
 	stmmac_init_tx_coalesce(priv);
@@ -1683,9 +1185,6 @@
 		priv->hw->dma->rx_watchdog(priv->ioaddr, MAX_DMA_RIWT);
 	}
 
-	if (priv->pcs && priv->hw->mac->ctrl_ane)
-		priv->hw->mac->ctrl_ane(priv->ioaddr, 0);
-
 	napi_enable(&priv->napi);
 	netif_start_queue(dev);
 
@@ -1757,25 +1256,21 @@
 #endif
 	clk_disable_unprepare(priv->stmmac_clk);
 
-	stmmac_release_ptp(priv);
-
 	return 0;
 }
 
 /**
- *  stmmac_xmit: Tx entry point of the driver
+ *  stmmac_xmit:
  *  @skb : the socket buffer
  *  @dev : device pointer
- *  Description : this is the tx entry point of the driver.
- *  It programs the chain or the ring and supports oversized frames
- *  and SG feature.
+ *  Description : Tx entry point of the driver.
  */
 static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 	unsigned int txsize = priv->dma_tx_size;
 	unsigned int entry;
-	int i, csum_insertion = 0, is_jumbo = 0;
+	int i, csum_insertion = 0;
 	int nfrags = skb_shinfo(skb)->nr_frags;
 	struct dma_desc *desc, *first;
 	unsigned int nopaged_len = skb_headlen(skb);
@@ -1784,7 +1279,8 @@
 		if (!netif_queue_stopped(dev)) {
 			netif_stop_queue(dev);
 			/* This is a hard error, log it. */
-			pr_err("%s: Tx Ring full when queue awake\n", __func__);
+			pr_err("%s: BUG! Tx Ring full when queue awake\n",
+				__func__);
 		}
 		return NETDEV_TX_BUSY;
 	}
@@ -1798,9 +1294,10 @@
 
 #ifdef STMMAC_XMIT_DEBUG
 	if ((skb->len > ETH_FRAME_LEN) || nfrags)
-		pr_debug("%s: [entry %d]: skb addr %p len: %d nopagedlen: %d\n"
+		pr_debug("stmmac xmit: [entry %d]\n"
+			 "\tskb addr %p - len: %d - nopaged_len: %d\n"
 			 "\tn_frags: %d - ip_summed: %d - %s gso\n"
-			 "\ttx_count_frames %d\n", __func__, entry,
+			 "\ttx_count_frames %d\n", entry,
 			 skb, skb->len, nopaged_len, nfrags, skb->ip_summed,
 			 !skb_is_gso(skb) ? "isn't" : "is",
 			 priv->tx_count_frames);
@@ -1808,11 +1305,7 @@
 
 	csum_insertion = (skb->ip_summed == CHECKSUM_PARTIAL);
 
-	if (priv->extend_desc)
-		desc = (struct dma_desc *)(priv->dma_etx + entry);
-	else
-		desc = priv->dma_tx + entry;
-
+	desc = priv->dma_tx + entry;
 	first = desc;
 
 #ifdef STMMAC_XMIT_DEBUG
@@ -1823,46 +1316,28 @@
 #endif
 	priv->tx_skbuff[entry] = skb;
 
-	/* To program the descriptors according to the size of the frame */
-	if (priv->mode == STMMAC_RING_MODE) {
-		is_jumbo = priv->hw->ring->is_jumbo_frm(skb->len,
-							priv->plat->enh_desc);
-		if (unlikely(is_jumbo))
-			entry = priv->hw->ring->jumbo_frm(priv, skb,
-							  csum_insertion);
+	if (priv->hw->ring->is_jumbo_frm(skb->len, priv->plat->enh_desc)) {
+		entry = priv->hw->ring->jumbo_frm(priv, skb, csum_insertion);
+		desc = priv->dma_tx + entry;
 	} else {
-		is_jumbo = priv->hw->chain->is_jumbo_frm(skb->len,
-							 priv->plat->enh_desc);
-		if (unlikely(is_jumbo))
-			entry = priv->hw->chain->jumbo_frm(priv, skb,
-							   csum_insertion);
-	}
-	if (likely(!is_jumbo)) {
 		desc->des2 = dma_map_single(priv->device, skb->data,
-					    nopaged_len, DMA_TO_DEVICE);
-		priv->tx_skbuff_dma[entry] = desc->des2;
+					nopaged_len, DMA_TO_DEVICE);
 		priv->hw->desc->prepare_tx_desc(desc, 1, nopaged_len,
-						csum_insertion, priv->mode);
-	} else
-		desc = first;
+						csum_insertion);
+	}
 
 	for (i = 0; i < nfrags; i++) {
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		int len = skb_frag_size(frag);
 
 		entry = (++priv->cur_tx) % txsize;
-		if (priv->extend_desc)
-			desc = (struct dma_desc *)(priv->dma_etx + entry);
-		else
-			desc = priv->dma_tx + entry;
+		desc = priv->dma_tx + entry;
 
 		TX_DBG("\t[entry %d] segment len: %d\n", entry, len);
 		desc->des2 = skb_frag_dma_map(priv->device, frag, 0, len,
 					      DMA_TO_DEVICE);
-		priv->tx_skbuff_dma[entry] = desc->des2;
 		priv->tx_skbuff[entry] = NULL;
-		priv->hw->desc->prepare_tx_desc(desc, 0, len, csum_insertion,
-						priv->mode);
+		priv->hw->desc->prepare_tx_desc(desc, 0, len, csum_insertion);
 		wmb();
 		priv->hw->desc->set_tx_owner(desc);
 		wmb();
@@ -1895,14 +1370,11 @@
 
 #ifdef STMMAC_XMIT_DEBUG
 	if (netif_msg_pktdata(priv)) {
-		pr_info("%s: curr %d dirty=%d entry=%d, first=%p, nfrags=%d",
-			__func__, (priv->cur_tx % txsize),
-			(priv->dirty_tx % txsize), entry, first, nfrags);
-		if (priv->extend_desc)
-			stmmac_display_ring((void *)priv->dma_etx, txsize, 1);
-		else
-			stmmac_display_ring((void *)priv->dma_tx, txsize, 0);
-
+		pr_info("stmmac xmit: current=%d, dirty=%d, entry=%d, "
+		       "first=%p, nfrags=%d\n",
+		       (priv->cur_tx % txsize), (priv->dirty_tx % txsize),
+		       entry, first, nfrags);
+		display_ring(priv->dma_tx, txsize);
 		pr_info(">>> frame to be transmitted: ");
 		print_pkt(skb->data, skb->len);
 	}
@@ -1914,15 +1386,7 @@
 
 	dev->stats.tx_bytes += skb->len;
 
-	if (unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
-		     priv->hwts_tx_en)) {
-		/* declare that device is doing timestamping */
-		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-		priv->hw->desc->enable_tx_timestamp(first);
-	}
-
-	if (!priv->hwts_tx_en)
-		skb_tx_timestamp(skb);
+	skb_tx_timestamp(skb);
 
 	priv->hw->dma->enable_dma_transmission(priv->ioaddr);
 
@@ -1931,26 +1395,14 @@
 	return NETDEV_TX_OK;
 }
 
-/**
- * stmmac_rx_refill: refill used skb preallocated buffers
- * @priv: driver private structure
- * Description : this is to reallocate the skb for the reception process
- * that is based on zero-copy.
- */
 static inline void stmmac_rx_refill(struct stmmac_priv *priv)
 {
 	unsigned int rxsize = priv->dma_rx_size;
 	int bfsize = priv->dma_buf_sz;
+	struct dma_desc *p = priv->dma_rx;
 
 	for (; priv->cur_rx - priv->dirty_rx > 0; priv->dirty_rx++) {
 		unsigned int entry = priv->dirty_rx % rxsize;
-		struct dma_desc *p;
-
-		if (priv->extend_desc)
-			p = (struct dma_desc *)(priv->dma_erx + entry);
-		else
-			p = priv->dma_rx + entry;
-
 		if (likely(priv->rx_skbuff[entry] == NULL)) {
 			struct sk_buff *skb;
 
@@ -1964,116 +1416,80 @@
 			    dma_map_single(priv->device, skb->data, bfsize,
 					   DMA_FROM_DEVICE);
 
-			p->des2 = priv->rx_skbuff_dma[entry];
+			(p + entry)->des2 = priv->rx_skbuff_dma[entry];
 
-			priv->hw->ring->refill_desc3(priv, p);
+			if (unlikely(priv->plat->has_gmac))
+				priv->hw->ring->refill_desc3(bfsize, p + entry);
 
 			RX_DBG(KERN_INFO "\trefill entry #%d\n", entry);
 		}
 		wmb();
-		priv->hw->desc->set_rx_owner(p);
+		priv->hw->desc->set_rx_owner(p + entry);
 		wmb();
 	}
 }
 
-/**
- * stmmac_rx_refill: refill used skb preallocated buffers
- * @priv: driver private structure
- * @limit: napi bugget.
- * Description :  this the function called by the napi poll method.
- * It gets all the frames inside the ring.
- */
 static int stmmac_rx(struct stmmac_priv *priv, int limit)
 {
 	unsigned int rxsize = priv->dma_rx_size;
 	unsigned int entry = priv->cur_rx % rxsize;
 	unsigned int next_entry;
 	unsigned int count = 0;
-	int coe = priv->plat->rx_coe;
+	struct dma_desc *p = priv->dma_rx + entry;
+	struct dma_desc *p_next;
 
 #ifdef STMMAC_RX_DEBUG
 	if (netif_msg_hw(priv)) {
 		pr_debug(">>> stmmac_rx: descriptor ring:\n");
-		if (priv->extend_desc)
-			stmmac_display_ring((void *)priv->dma_erx, rxsize, 1);
-		else
-			stmmac_display_ring((void *)priv->dma_rx, rxsize, 0);
+		display_ring(priv->dma_rx, rxsize);
 	}
 #endif
-	while (count < limit) {
+	while (!priv->hw->desc->get_rx_owner(p)) {
 		int status;
-		struct dma_desc *p;
-
-		if (priv->extend_desc)
-			p = (struct dma_desc *)(priv->dma_erx + entry);
-		else
-			p = priv->dma_rx + entry;
 
-		if (priv->hw->desc->get_rx_owner(p))
+		if (count >= limit)
 			break;
 
 		count++;
 
 		next_entry = (++priv->cur_rx) % rxsize;
-		if (priv->extend_desc)
-			prefetch(priv->dma_erx + next_entry);
-		else
-			prefetch(priv->dma_rx + next_entry);
+		p_next = priv->dma_rx + next_entry;
+		prefetch(p_next);
 
 		/* read the status of the incoming frame */
-		status = priv->hw->desc->rx_status(&priv->dev->stats,
-						   &priv->xstats, p);
-		if ((priv->extend_desc) && (priv->hw->desc->rx_extended_status))
-			priv->hw->desc->rx_extended_status(&priv->dev->stats,
-							   &priv->xstats,
-							   priv->dma_erx +
-							   entry);
-		if (unlikely(status == discard_frame)) {
+		status = (priv->hw->desc->rx_status(&priv->dev->stats,
+						    &priv->xstats, p));
+		if (unlikely(status == discard_frame))
 			priv->dev->stats.rx_errors++;
-			if (priv->hwts_rx_en && !priv->extend_desc) {
-				/* DESC2 & DESC3 will be overwitten by device
-				 * with timestamp value, hence reinitialize
-				 * them in stmmac_rx_refill() function so that
-				 * device can reuse it.
-				 */
-				priv->rx_skbuff[entry] = NULL;
-				dma_unmap_single(priv->device,
-						 priv->rx_skbuff_dma[entry],
-						 priv->dma_buf_sz,
-						 DMA_FROM_DEVICE);
-			}
-		} else {
+		else {
 			struct sk_buff *skb;
 			int frame_len;
 
-			frame_len = priv->hw->desc->get_rx_frame_len(p, coe);
-
+			frame_len = priv->hw->desc->get_rx_frame_len(p,
+					priv->plat->rx_coe);
 			/* ACS is set; GMAC core strips PAD/FCS for IEEE 802.3
-			 * Type frames (LLC/LLC-SNAP)
-			 */
+			 * Type frames (LLC/LLC-SNAP) */
 			if (unlikely(status != llc_snap))
 				frame_len -= ETH_FCS_LEN;
 #ifdef STMMAC_RX_DEBUG
 			if (frame_len > ETH_FRAME_LEN)
 				pr_debug("\tRX frame size %d, COE status: %d\n",
-					 frame_len, status);
+					frame_len, status);
 
 			if (netif_msg_hw(priv))
 				pr_debug("\tdesc: %p [entry %d] buff=0x%x\n",
-					 p, entry, p->des2);
+					p, entry, p->des2);
 #endif
 			skb = priv->rx_skbuff[entry];
 			if (unlikely(!skb)) {
 				pr_err("%s: Inconsistent Rx descriptor chain\n",
-				       priv->dev->name);
+					priv->dev->name);
 				priv->dev->stats.rx_dropped++;
 				break;
 			}
 			prefetch(skb->data - NET_IP_ALIGN);
 			priv->rx_skbuff[entry] = NULL;
 
-			stmmac_get_rx_hwtstamp(priv, entry, skb);
-
 			skb_put(skb, frame_len);
 			dma_unmap_single(priv->device,
 					 priv->rx_skbuff_dma[entry],
@@ -2086,7 +1502,10 @@
 #endif
 			skb->protocol = eth_type_trans(skb, priv->dev);
 
-			if (unlikely(!coe))
+#ifdef CONFIG_STMMAC_PTP
+			stmmac_ptp_tx_hwtstamp(priv, priv->dma_rx + entry, skb);
+#endif
+			if (unlikely(!priv->plat->rx_coe))
 				skb_checksum_none_assert(skb);
 			else
 				skb->ip_summed = CHECKSUM_UNNECESSARY;
@@ -2097,6 +1516,7 @@
 			priv->dev->stats.rx_bytes += frame_len;
 		}
 		entry = next_entry;
+		p = p_next;	/* use prefetched values */
 	}
 
 	stmmac_rx_refill(priv);
@@ -2154,16 +1574,18 @@
 
 	/* Don't allow changing the I/O address */
 	if (map->base_addr != dev->base_addr) {
-		pr_warn("%s: can't change I/O address\n", dev->name);
+		pr_warning("%s: can't change I/O address\n", dev->name);
 		return -EOPNOTSUPP;
 	}
 
 	/* Don't allow changing the IRQ */
 	if (map->irq != dev->irq) {
-		pr_warn("%s: not change IRQ number %d\n", dev->name, dev->irq);
+		pr_warning("%s: can't change IRQ number %d\n",
+		       dev->name, dev->irq);
 		return -EOPNOTSUPP;
 	}
 
+	/* ignore other fields */
 	return 0;
 }
 
@@ -2223,7 +1645,7 @@
 }
 
 static netdev_features_t stmmac_fix_features(struct net_device *dev,
-					     netdev_features_t features)
+	netdev_features_t features)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 
@@ -2237,22 +1659,23 @@
 	/* Some GMAC devices have a bugged Jumbo frame support that
 	 * needs to have the Tx COE disabled for oversized frames
 	 * (due to limited buffer sizes). In this case we disable
-	 * the TX csum insertionin the TDES and not use SF.
-	 */
+	 * the TX csum insertionin the TDES and not use SF. */
 	if (priv->plat->bugged_jumbo && (dev->mtu > ETH_DATA_LEN))
 		features &= ~NETIF_F_ALL_CSUM;
 
+	stmmac_hw_set_rx_ipc(priv, features & NETIF_F_RXCSUM);
+
 	return features;
 }
 
-/**
- *  stmmac_interrupt - main ISR
- *  @irq: interrupt number.
- *  @dev_id: to pass the net device pointer.
- *  Description: this is the main driver interrupt service routine.
- *  It calls the DMA ISR and also the core ISR to manage PMT, MMC, LPI
- *  interrupts.
- */
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+	#define mask_pvm(x) qrk_pci_pvm_mask(x)
+	#define unmask_pvm(x) qrk_pci_pvm_unmask(x)
+#else
+	#define mask_pvm(x)
+	#define unmask_pvm(x)
+#endif
+
 static irqreturn_t stmmac_interrupt(int irq, void *dev_id)
 {
 	struct net_device *dev = (struct net_device *)dev_id;
@@ -2263,30 +1686,49 @@
 		return IRQ_NONE;
 	}
 
+	mask_pvm(priv->pdev);
+
 	/* To handle GMAC own interrupts */
 	if (priv->plat->has_gmac) {
-		int status = priv->hw->mac->host_irq_status((void __iomem *)
-							    dev->base_addr,
-							    &priv->xstats);
+		int status = priv->hw->mac->host_irq_status(priv);
+
 		if (unlikely(status)) {
+			if (status & core_mmc_tx_irq)
+				priv->xstats.mmc_tx_irq_n++;
+			if (status & core_mmc_rx_irq)
+				priv->xstats.mmc_rx_irq_n++;
+			if (status & core_mmc_rx_csum_offload_irq)
+				priv->xstats.mmc_rx_csum_offload_irq_n++;
+			if (status & core_irq_receive_pmt_irq)
+				priv->xstats.irq_receive_pmt_irq_n++;
+
 			/* For LPI we need to save the tx status */
-			if (status & CORE_IRQ_TX_PATH_IN_LPI_MODE)
+			if (status & core_irq_tx_path_in_lpi_mode) {
+				priv->xstats.irq_tx_path_in_lpi_mode_n++;
 				priv->tx_path_in_lpi_mode = true;
-			if (status & CORE_IRQ_TX_PATH_EXIT_LPI_MODE)
+			}
+			if (status & core_irq_tx_path_exit_lpi_mode) {
+				priv->xstats.irq_tx_path_exit_lpi_mode_n++;
 				priv->tx_path_in_lpi_mode = false;
+			}
+			if (status & core_irq_rx_path_in_lpi_mode)
+				priv->xstats.irq_rx_path_in_lpi_mode_n++;
+			if (status & core_irq_rx_path_exit_lpi_mode)
+				priv->xstats.irq_rx_path_exit_lpi_mode_n++;
 		}
 	}
 
 	/* To handle DMA interrupts */
 	stmmac_dma_interrupt(priv);
 
+	unmask_pvm(priv->pdev);
+
 	return IRQ_HANDLED;
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
 /* Polling receive - used by NETCONSOLE and other diagnostic tools
- * to allow network I/O with interrupts disabled.
- */
+ * to allow network I/O with interrupts disabled. */
 static void stmmac_poll_controller(struct net_device *dev)
 {
 	disable_irq(dev->irq);
@@ -2302,29 +1744,28 @@
  *  a proprietary structure used to pass information to the driver.
  *  @cmd: IOCTL command
  *  Description:
- *  Currently it supports the phy_mii_ioctl(...) and HW time stamping.
+ *  Currently there are no special functionality supported in IOCTL, just the
+ *  phy_mii_ioctl(...) can be invoked.
  */
 static int stmmac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
-	int ret = -EOPNOTSUPP;
+	int ret;
 
 	if (!netif_running(dev))
 		return -EINVAL;
 
+	if (!priv->phydev)
+		return -EINVAL;
+
 	switch (cmd) {
-	case SIOCGMIIPHY:
-	case SIOCGMIIREG:
-	case SIOCSMIIREG:
-		if (!priv->phydev)
-			return -EINVAL;
-		ret = phy_mii_ioctl(priv->phydev, rq, cmd);
-		break;
+#ifdef CONFIG_STMMAC_PTP
 	case SIOCSHWTSTAMP:
-		ret = stmmac_hwtstamp_ioctl(dev, rq);
+		ret = stmmac_ptp_hwtstamp_ioctl(priv, rq, cmd);
 		break;
+#endif
 	default:
-		break;
+		ret = phy_mii_ioctl(priv->phydev, rq, cmd);
 	}
 
 	return ret;
@@ -2335,51 +1776,40 @@
 static struct dentry *stmmac_rings_status;
 static struct dentry *stmmac_dma_cap;
 
-static void sysfs_display_ring(void *head, int size, int extend_desc,
-			       struct seq_file *seq)
+static int stmmac_sysfs_ring_read(struct seq_file *seq, void *v)
 {
+	struct tmp_s {
+		u64 a;
+		unsigned int b;
+		unsigned int c;
+	};
 	int i;
-	struct dma_extended_desc *ep = (struct dma_extended_desc *)head;
-	struct dma_desc *p = (struct dma_desc *)head;
+	struct net_device *dev = seq->private;
+	struct stmmac_priv *priv = netdev_priv(dev);
 
-	for (i = 0; i < size; i++) {
-		u64 x;
-		if (extend_desc) {
-			x = *(u64 *) ep;
-			seq_printf(seq, "%d [0x%x]: 0x%x 0x%x 0x%x 0x%x\n",
-				   i, (unsigned int)virt_to_phys(ep),
-				   (unsigned int)x, (unsigned int)(x >> 32),
-				   ep->basic.des2, ep->basic.des3);
-			ep++;
-		} else {
-			x = *(u64 *) p;
-			seq_printf(seq, "%d [0x%x]: 0x%x 0x%x 0x%x 0x%x\n",
-				   i, (unsigned int)virt_to_phys(ep),
-				   (unsigned int)x, (unsigned int)(x >> 32),
-				   p->des2, p->des3);
-			p++;
-		}
+	seq_printf(seq, "=======================\n");
+	seq_printf(seq, " RX descriptor ring\n");
+	seq_printf(seq, "=======================\n");
+
+	for (i = 0; i < priv->dma_rx_size; i++) {
+		struct tmp_s *x = (struct tmp_s *)(priv->dma_rx + i);
+		seq_printf(seq, "[%d] DES0=0x%x DES1=0x%x BUF1=0x%x BUF2=0x%x",
+			   i, (unsigned int)(x->a),
+			   (unsigned int)((x->a) >> 32), x->b, x->c);
 		seq_printf(seq, "\n");
 	}
-}
 
-static int stmmac_sysfs_ring_read(struct seq_file *seq, void *v)
-{
-	struct net_device *dev = seq->private;
-	struct stmmac_priv *priv = netdev_priv(dev);
-	unsigned int txsize = priv->dma_tx_size;
-	unsigned int rxsize = priv->dma_rx_size;
+	seq_printf(seq, "\n");
+	seq_printf(seq, "=======================\n");
+	seq_printf(seq, "  TX descriptor ring\n");
+	seq_printf(seq, "=======================\n");
 
-	if (priv->extend_desc) {
-		seq_printf(seq, "Extended RX descriptor ring:\n");
-		sysfs_display_ring((void *)priv->dma_erx, rxsize, 1, seq);
-		seq_printf(seq, "Extended TX descriptor ring:\n");
-		sysfs_display_ring((void *)priv->dma_etx, txsize, 1, seq);
-	} else {
-		seq_printf(seq, "RX descriptor ring:\n");
-		sysfs_display_ring((void *)priv->dma_rx, rxsize, 0, seq);
-		seq_printf(seq, "TX descriptor ring:\n");
-		sysfs_display_ring((void *)priv->dma_tx, txsize, 0, seq);
+	for (i = 0; i < priv->dma_tx_size; i++) {
+		struct tmp_s *x = (struct tmp_s *)(priv->dma_tx + i);
+		seq_printf(seq, "[%d] DES0=0x%x DES1=0x%x BUF1=0x%x BUF2=0x%x",
+			   i, (unsigned int)(x->a),
+			   (unsigned int)((x->a) >> 32), x->b, x->c);
+		seq_printf(seq, "\n");
 	}
 
 	return 0;
@@ -2484,8 +1914,8 @@
 
 	/* Entry to report DMA RX/TX rings */
 	stmmac_rings_status = debugfs_create_file("descriptors_status",
-						  S_IRUGO, stmmac_fs_dir, dev,
-						  &stmmac_rings_status_fops);
+					   S_IRUGO, stmmac_fs_dir, dev,
+					   &stmmac_rings_status_fops);
 
 	if (!stmmac_rings_status || IS_ERR(stmmac_rings_status)) {
 		pr_info("ERROR creating stmmac ring debugfs file\n");
@@ -2517,6 +1947,21 @@
 }
 #endif /* CONFIG_STMMAC_DEBUG_FS */
 
+#ifdef STMMAC_VLAN_HASH
+static int stmmac_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	return priv->hw->mac->vlan_rx_add_vid(priv, vid);
+}
+
+static int stmmac_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	return priv->hw->mac->vlan_rx_kill_vid(priv, vid);
+}
+
+#endif
+
 static const struct net_device_ops stmmac_netdev_ops = {
 	.ndo_open = stmmac_open,
 	.ndo_start_xmit = stmmac_xmit,
@@ -2527,6 +1972,10 @@
 	.ndo_tx_timeout = stmmac_tx_timeout,
 	.ndo_do_ioctl = stmmac_ioctl,
 	.ndo_set_config = stmmac_config,
+#ifdef STMMAC_VLAN_HASH
+	.ndo_vlan_rx_add_vid = stmmac_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid = stmmac_vlan_rx_kill_vid,
+#endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = stmmac_poll_controller,
 #endif
@@ -2535,7 +1984,7 @@
 
 /**
  *  stmmac_hw_init - Init the MAC device
- *  @priv: driver private structure
+ *  @priv : pointer to the private device structure.
  *  Description: this function detects which MAC device
  *  (GMAC/MAC10-100) has to attached, checks the HW capability
  *  (if supported) and sets the driver's features (for example
@@ -2544,7 +1993,7 @@
  */
 static int stmmac_hw_init(struct stmmac_priv *priv)
 {
-	int ret;
+	int ret = 0;
 	struct mac_device_info *mac;
 
 	/* Identify the MAC HW device */
@@ -2559,23 +2008,12 @@
 
 	priv->hw = mac;
 
+	/* To use the chained or ring mode */
+	priv->hw->ring = &ring_mode_ops;
+
 	/* Get and dump the chip ID */
 	priv->synopsys_id = stmmac_get_synopsys_id(priv);
 
-	/* To use alternate (extended) or normal descriptor structures */
-	stmmac_selec_desc_mode(priv);
-
-	/* To use the chained or ring mode */
-	if (chain_mode) {
-		priv->hw->chain = &chain_mode_ops;
-		pr_info(" Chain mode enabled\n");
-		priv->mode = STMMAC_CHAIN_MODE;
-	} else {
-		priv->hw->ring = &ring_mode_ops;
-		pr_info(" Ring mode enabled\n");
-		priv->mode = STMMAC_RING_MODE;
-	}
-
 	/* Get the HW capability (new GMAC newer than 3.50a) */
 	priv->hw_cap_support = stmmac_get_hw_features(priv);
 	if (priv->hw_cap_support) {
@@ -2599,11 +2037,10 @@
 	} else
 		pr_info(" No HW DMA feature register supported");
 
-	ret = priv->hw->mac->rx_ipc(priv->ioaddr);
-	if (!ret) {
-		pr_warn(" RX IPC Checksum Offload not configured.\n");
-		priv->plat->rx_coe = STMMAC_RX_COE_NONE;
-	}
+	/* Select the enhnaced/normal descriptor structures */
+	stmmac_selec_desc_mode(priv);
+
+	ret = stmmac_hw_set_rx_ipc(priv, true);
 
 	if (priv->plat->rx_coe)
 		pr_info(" RX Checksum Offload Engine supported (type %d)\n",
@@ -2616,7 +2053,7 @@
 		device_set_wakeup_capable(priv->device, 1);
 	}
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -2657,15 +2094,12 @@
 	stmmac_verify_args();
 
 	/* Override with kernel parameters if supplied XXX CRS XXX
-	 * this needs to have multiple instances
-	 */
+	 * this needs to have multiple instances */
 	if ((phyaddr >= 0) && (phyaddr <= 31))
 		priv->plat->phy_addr = phyaddr;
 
 	/* Init MAC and get the capabilities */
-	ret = stmmac_hw_init(priv);
-	if (ret)
-		goto error_free_netdev;
+	stmmac_hw_init(priv);
 
 	ndev->netdev_ops = &stmmac_netdev_ops;
 
@@ -2675,8 +2109,14 @@
 	ndev->watchdog_timeo = msecs_to_jiffies(watchdog);
 #ifdef STMMAC_VLAN_TAG_USED
 	/* Both mac100 and gmac support receive VLAN tag detection */
-	ndev->features |= NETIF_F_HW_VLAN_CTAG_RX;
+	ndev->features |= NETIF_F_HW_VLAN_RX;
 #endif
+#ifdef STMMAC_VLAN_HASH
+	ndev->features |= NETIF_F_HW_VLAN_FILTER;
+	ndev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			    NETIF_F_RXCSUM;
+#endif
+
 	priv->msg_enable = netif_msg_init(debug, default_msg_level);
 
 	if (flow_ctrl)
@@ -2705,7 +2145,7 @@
 
 	priv->stmmac_clk = clk_get(priv->device, STMMAC_RESOURCE_NAME);
 	if (IS_ERR(priv->stmmac_clk)) {
-		pr_warn("%s: warning: cannot get CSR clock\n", __func__);
+		pr_warning("%s: warning: cannot get CSR clock\n", __func__);
 		goto error_clk_get;
 	}
 
@@ -2720,17 +2160,16 @@
 	else
 		priv->clk_csr = priv->plat->clk_csr;
 
-	stmmac_check_pcs_mode(priv);
+#ifdef CONFIG_STMMAC_PTP
+	stmmac_ptp_init(ndev, device);
+#endif
 
-	if (priv->pcs != STMMAC_PCS_RGMII && priv->pcs != STMMAC_PCS_TBI &&
-	    priv->pcs != STMMAC_PCS_RTBI) {
-		/* MDIO bus Registration */
-		ret = stmmac_mdio_register(ndev);
-		if (ret < 0) {
-			pr_debug("%s: MDIO bus (id: %d) registration failed",
-				 __func__, priv->plat->bus_id);
-			goto error_mdio_register;
-		}
+	/* MDIO bus Registration */
+	ret = stmmac_mdio_register(ndev);
+	if (ret < 0) {
+		pr_debug("%s: MDIO bus (id: %d) registration failed",
+			 __func__, priv->plat->bus_id);
+		goto error_mdio_register;
 	}
 
 	return priv;
@@ -2741,7 +2180,9 @@
 	unregister_netdev(ndev);
 error_netdev_register:
 	netif_napi_del(&priv->napi);
-error_free_netdev:
+#ifdef CONFIG_STMMAC_PTP
+	stmmac_ptp_remove(priv);
+#endif
 	free_netdev(ndev);
 
 	return NULL;
@@ -2757,16 +2198,18 @@
 {
 	struct stmmac_priv *priv = netdev_priv(ndev);
 
-	pr_info("%s:\n\tremoving driver", __func__);
+	pr_info("%s:\n\tremoving driver\n", __func__);
 
 	priv->hw->dma->stop_rx(priv->ioaddr);
 	priv->hw->dma->stop_tx(priv->ioaddr);
 
 	stmmac_set_mac(priv->ioaddr, false);
-	if (priv->pcs != STMMAC_PCS_RGMII && priv->pcs != STMMAC_PCS_TBI &&
-	    priv->pcs != STMMAC_PCS_RTBI)
-		stmmac_mdio_unregister(ndev);
+	stmmac_mdio_unregister(ndev);
 	netif_carrier_off(ndev);
+
+#ifdef CONFIG_STMMAC_PTP
+	stmmac_ptp_remove(priv);
+#endif
 	unregister_netdev(ndev);
 	free_netdev(ndev);
 
@@ -2777,6 +2220,7 @@
 int stmmac_suspend(struct net_device *ndev)
 {
 	struct stmmac_priv *priv = netdev_priv(ndev);
+	int dis_ic = 0;
 	unsigned long flags;
 
 	if (!ndev || !netif_running(ndev))
@@ -2790,13 +2234,18 @@
 	netif_device_detach(ndev);
 	netif_stop_queue(ndev);
 
+	if (priv->use_riwt)
+		dis_ic = 1;
+
 	napi_disable(&priv->napi);
 
 	/* Stop TX/RX DMA */
 	priv->hw->dma->stop_tx(priv->ioaddr);
 	priv->hw->dma->stop_rx(priv->ioaddr);
-
-	stmmac_clear_descriptors(priv);
+	/* Clear the Rx/Tx descriptors */
+	priv->hw->desc->init_rx_desc(priv->dma_rx, priv->dma_rx_size,
+				     dis_ic);
+	priv->hw->desc->init_tx_desc(priv->dma_tx, priv->dma_tx_size);
 
 	/* Enable Power down mode by programming the PMT regs */
 	if (device_may_wakeup(priv->device))
@@ -2824,8 +2273,7 @@
 	 * automatically as soon as a magic packet or a Wake-up frame
 	 * is received. Anyway, it's better to manually clear
 	 * this bit because it can generate problems while resuming
-	 * from another devices (e.g. serial console).
-	 */
+	 * from another devices (e.g. serial console). */
 	if (device_may_wakeup(priv->device))
 		priv->hw->mac->pmt(priv->ioaddr, 0);
 	else
@@ -2933,12 +2381,9 @@
 		} else if (!strncmp(opt, "pause:", 6)) {
 			if (kstrtoint(opt + 6, 0, &pause))
 				goto err;
-		} else if (!strncmp(opt, "eee_timer:", 10)) {
+		} else if (!strncmp(opt, "eee_timer:", 6)) {
 			if (kstrtoint(opt + 10, 0, &eee_timer))
 				goto err;
-		} else if (!strncmp(opt, "chain_mode:", 11)) {
-			if (kstrtoint(opt + 11, 0, &chain_mode))
-				goto err;
 		}
 	}
 	return 0;
@@ -2949,7 +2394,7 @@
 }
 
 __setup("stmmaceth=", stmmac_cmdline_opt);
-#endif /* MODULE */
+#endif
 
 MODULE_DESCRIPTION("STMMAC 10/100/1000 Ethernet device driver");
 MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>"); 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 064eaac..f7afcad 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -23,31 +23,193 @@
   Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
 *******************************************************************************/
 
+#include <linux/dmi.h>
 #include <linux/pci.h>
+#include <linux/platform_data/quark.h>
 #include "stmmac.h"
 
-struct plat_stmmacenet_data plat_dat;
-struct stmmac_mdio_bus_data mdio_data;
-struct stmmac_dma_cfg dma_cfg;
-
-static void stmmac_default_data(void)
-{
-	memset(&plat_dat, 0, sizeof(struct plat_stmmacenet_data));
-	plat_dat.bus_id = 1;
-	plat_dat.phy_addr = 0;
-	plat_dat.interface = PHY_INTERFACE_MODE_GMII;
-	plat_dat.clk_csr = 2;	/* clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */
-	plat_dat.has_gmac = 1;
-	plat_dat.force_sf_dma_mode = 1;
-
-	mdio_data.phy_reset = NULL;
-	mdio_data.phy_mask = 0;
-	plat_dat.mdio_bus_data = &mdio_data;
-
-	dma_cfg.pbl = 32;
-	dma_cfg.burst_len = DMA_AXI_BLEN_256;
-	plat_dat.dma_cfg = &dma_cfg;
+/* List of supported PCI device IDs */
+#define STMMAC_VENDOR_ID 0x700
+#define STMMAC_DEVICE_ID 0x1108
+#define STMMAC_QUARK_ID 0x0937
+#define MAX_INTERFACES	 0x02
+
+#if defined (CONFIG_INTEL_QUARK_X1000_SOC)
+static int enable_msi = 1;
+#else
+static int enable_msi = 0;
+#endif
+module_param(enable_msi, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
+static int bus_id = 1;
+static char stmmac_mac_data[MAX_INTERFACES][ETH_ALEN];
+
+struct stmmac_qrk_mac_data {
+	int phy_addr;
+	int bus_id;
+	const char * name;	
+};
+
+static struct stmmac_qrk_mac_data phy_data [] = {
+	{
+		.phy_addr	= -1,			/* not connected */
+		.bus_id		= 1,
+		.name		= "QuarkEmulation",
+	},
+	{
+		.phy_addr 	= 1,
+		.bus_id		= 2,
+		.name		= "QuarkEmulation",
+	},
+	{
+		.phy_addr	= 3,
+		.bus_id		= 1,
+		.name 		= "ClantonPeakSVP",
+	},
+	{
+		.phy_addr 	= 1,
+		.bus_id		= 2,
+		.name 		= "ClantonPeakSVP",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name 		= "KipsBay",
+	},
+	{
+		.phy_addr 	= -1,			/* not connected */
+		.bus_id		= 2,
+		.name 		= "KipsBay",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name 		= "CrossHill",
+	},
+	{
+		.phy_addr 	= 1,
+		.bus_id		= 2,
+		.name 		= "CrossHill",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name 		= "ClantonHill",
+	},
+	{
+		.phy_addr 	= 1,
+		.bus_id		= 2,
+		.name 		= "ClantonHill",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name 		= "Galileo",
+	},
+	{
+		.phy_addr 	= -1,			/* not connected */
+		.bus_id		= 2,
+		.name 		= "Galileo",
+	},
+};
+
+
+static int stmmac_find_phy_addr(int mdio_bus_id)
+{
+	int i = 0;
+	const char * board_name = dmi_get_system_info(DMI_BOARD_NAME);
+	if (board_name == NULL)
+		return -1;
+
+	for (; i < sizeof(phy_data)/sizeof(struct stmmac_qrk_mac_data); i++){
+		if ((!strcmp(phy_data[i].name, board_name)) &&
+			phy_data[i].bus_id == mdio_bus_id)
+			return phy_data[i].phy_addr;
+	}
+
+	return -1;
+}
+
+static int stmmac_default_data(struct plat_stmmacenet_data *plat_dat,
+			       int mdio_bus_id, const struct pci_device_id *id)
+{
+	int phy_addr = 0;
+	memset(plat_dat, 0, sizeof(struct plat_stmmacenet_data));
+
+	plat_dat->mdio_bus_data = kzalloc(sizeof(struct stmmac_mdio_bus_data),
+					GFP_KERNEL);
+	if (plat_dat->mdio_bus_data == NULL)
+		return -ENOMEM;
+
+	plat_dat->dma_cfg = kzalloc(sizeof(struct stmmac_dma_cfg),GFP_KERNEL);
+	if (plat_dat->dma_cfg == NULL)
+		return -ENOMEM;
+
+	if (id->device ==  STMMAC_QUARK_ID) {
+
+		phy_addr = stmmac_find_phy_addr(mdio_bus_id);
+		if (phy_addr == -1)
+			return -ENODEV;
+
+		plat_dat->bus_id = mdio_bus_id;
+		plat_dat->phy_addr = phy_addr;
+		plat_dat->interface = PHY_INTERFACE_MODE_RMII;
+		/* clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */
+		plat_dat->clk_csr = 2;
+		plat_dat->has_gmac = 1;
+		plat_dat->force_sf_dma_mode = 1;
+
+		plat_dat->mdio_bus_data->phy_reset = NULL;
+		plat_dat->mdio_bus_data->phy_mask = 0;
+
+		plat_dat->dma_cfg->pbl = 16;
+		plat_dat->dma_cfg->fixed_burst = 1;
+		plat_dat->dma_cfg->burst_len = DMA_AXI_BLEN_256;
+
+	} else {
+
+		plat_dat->bus_id = mdio_bus_id;
+		plat_dat->phy_addr = phy_addr;
+		plat_dat->interface = PHY_INTERFACE_MODE_GMII;
+		/* clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */
+		plat_dat->clk_csr = 2;
+		plat_dat->has_gmac = 1;
+		plat_dat->force_sf_dma_mode = 1;
+
+		plat_dat->mdio_bus_data->phy_reset = NULL;
+		plat_dat->mdio_bus_data->phy_mask = 0;
+
+		plat_dat->dma_cfg->pbl = 32;
+		plat_dat->dma_cfg->burst_len = DMA_AXI_BLEN_256;
+
+	}
+
+	return 0;
+}
+
+#if 0
+/**
+ * stmmac_pci_find_mac
+ *
+ * @prive: pointer to private stmmac structure
+ * @mdio_bus_id : MDIO bus identifier used to find the platform MAC id
+ *
+ * Attempt to find MAC in platform data. If not found then driver will generate
+ * a random one for itself in any case
+ */
+void stmmac_pci_find_mac (struct stmmac_priv * priv, unsigned int mdio_bus_id)
+{
+	unsigned int id = mdio_bus_id - 1;
+	if (priv == NULL || id >= MAX_INTERFACES)
+		return;
+
+	if (intel_qrk_plat_get_mac(PLAT_DATA_MAC0+id,
+		(char*)&stmmac_mac_data[id]) == 0){
+		memcpy(priv->dev->dev_addr, &stmmac_mac_data[id], ETH_ALEN);
+	}
 }
+#endif
 
 /**
  * stmmac_pci_probe
@@ -67,8 +229,21 @@
 	int ret = 0;
 	void __iomem *addr = NULL;
 	struct stmmac_priv *priv = NULL;
+	struct plat_stmmacenet_data *plat_dat = NULL;
 	int i;
 
+        plat_dat = kmalloc(sizeof(struct plat_stmmacenet_data), GFP_KERNEL);
+        if (plat_dat == NULL){
+                ret = -ENOMEM;
+                goto err_out_map_failed;
+        }
+
+	/* return -ENODEV for non existing PHY, stop probing here  */
+        ret = stmmac_default_data(plat_dat, bus_id, id);
+        if (ret != 0)
+                goto err_platdata;
+
+
 	/* Enable pci device */
 	ret = pci_enable_device(pdev);
 	if (ret) {
@@ -88,7 +263,7 @@
 			continue;
 		addr = pci_iomap(pdev, i, 0);
 		if (addr == NULL) {
-			pr_err("%s: ERROR: cannot map register memory aborting",
+			pr_err("%s: ERROR: cannot map register memory, aborting",
 			       __func__);
 			ret = -EIO;
 			goto err_out_map_failed;
@@ -96,31 +271,51 @@
 		break;
 	}
 	pci_set_master(pdev);
+	if(enable_msi == 1){
+		pci_enable_msi(pdev);
+		pr_info("stmmac MSI mode enabled");
+	}
 
-	stmmac_default_data();
+	pr_info("Vendor 0x%04x Device 0x%04x\n",
+		id->vendor, id->device);
 
-	priv = stmmac_dvr_probe(&(pdev->dev), &plat_dat, addr);
+	priv = stmmac_dvr_probe(&(pdev->dev), plat_dat, addr);
 	if (!priv) {
 		pr_err("%s: main driver probe failed", __func__);
-		ret = -ENODEV;
 		goto err_out;
 	}
+#if 0
+	stmmac_pci_find_mac(priv, bus_id);
+#endif
 	priv->dev->irq = pdev->irq;
 	priv->wol_irq = pdev->irq;
-
+	priv->irqmode_msi = enable_msi;
+	priv->pdev = pdev;
+	#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	priv->lpi_irq = -ENXIO;
+	#endif
 	pci_set_drvdata(pdev, priv->dev);
 
 	pr_debug("STMMAC platform driver registration completed");
+	bus_id++;
 
 	return 0;
 
 err_out:
 	pci_clear_master(pdev);
-err_out_map_failed:
 	pci_release_regions(pdev);
 err_out_req_reg_failed:
 	pci_disable_device(pdev);
-
+err_platdata:
+	if (plat_dat != NULL){
+		if (plat_dat->dma_cfg != NULL)
+			kfree (plat_dat->dma_cfg);
+		if (plat_dat->mdio_bus_data != NULL)
+			kfree (plat_dat->mdio_bus_data);
+		kfree(plat_dat);
+	}
+err_out_map_failed:
+	bus_id++;
 	return ret;
 }
 
@@ -139,6 +334,21 @@
 	stmmac_dvr_remove(ndev);
 
 	pci_set_drvdata(pdev, NULL);
+
+	if(enable_msi == 1) {
+		if(pci_dev_msi_enabled(pdev)) {
+			pci_disable_msi(pdev);
+		}
+	}
+
+	if (priv->plat != NULL) {
+		if (priv->plat->dma_cfg != NULL)
+			kfree (priv->plat->dma_cfg);
+		if (priv->plat->mdio_bus_data != NULL)
+			kfree (priv->plat->mdio_bus_data);
+		kfree(priv->plat);
+	}
+
 	pci_iounmap(pdev, priv->ioaddr);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
@@ -168,12 +378,10 @@
 }
 #endif
 
-#define STMMAC_VENDOR_ID 0x700
-#define STMMAC_DEVICE_ID 0x1108
-
 static DEFINE_PCI_DEVICE_TABLE(stmmac_id_table) = {
 	{PCI_DEVICE(STMMAC_VENDOR_ID, STMMAC_DEVICE_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_MAC)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, STMMAC_QUARK_ID)},
 	{}
 };
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
index 0000000..8552d0c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
@@ -19,193 +19,705 @@
   The full GNU General Public License is included in this distribution in
   the file called "COPYING".
 
-  Author: Rayagond Kokatanur <rayagond@vayavyalabs.com>
+  Contact Information::w
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
 *******************************************************************************/
 #include "stmmac.h"
-#include "stmmac_ptp.h"
+#include "dwmac1000.h"
+#include <linux/export.h>
+#include <linux/net_tstamp.h>
+
+/* PPSCMD0 */
+#define STMMAC_PPSCMD_NONE		0x00	/* No command */
+#define STMMAC_PPSCMD_START_SINGLE	0x01	/* Start single pulse */
+#define STMMAC_PPSCMD_START_PULSE	0x02	/* Start pulse train */
+#define STMMAC_PPSCMD_START_CANCEL	0x03	/* Cancel start */
+#define STMMAC_PPSCMD_STOP_PULSE_ATTIME	0x04	/* Stop pulse train at time */
+#define STMMAC_PPSCMD_STOP_PULSE_IMMED	0x05	/* Stop pulse train immediate */
+#define STMMAC_PPSCMD_STOP_CANCEL	0x06	/* Stop cancel pulse train */
+
+#define STMMAC_PTP_OVERFLOW_CHECK_ENABLED	(u32)(1)
+#define STMMAC_PTP_PPS_ENABLED			(u32)(1 << 1)
+#define STMMAC_PTP_HWTS_TX_EN			(u32)(1 << 2)
+#define STMMAC_PTP_HWTS_RX_EN			(u32)(1 << 3)
+
+#ifndef NSECS_PER_SEC
+#define NSECS_PER_SEC 1000000000ULL
+#endif
+
+/*
+ *  Structure of STMMAC timer registers
+ *
+ *           GMAC_TS_HWSEC    GMAC_ST_SEC     GMAC_ST_NSEC 
+ *         +--------------+ +--------------+ +---+---+------+
+ *  STMMAC |      16      | |      32      | |      32      |
+ *         +--------------+ +--------------+ +---+---+------+
+ *
+ *  The counter for the STMMAC is 80 bits
+ *   - HWSEC == overflow value for ST_SEC => 130 years to overflow (optional)
+ *   - ST_SEC == seconds
+ *   - ST_NSEC == nanoseconds
+ */
 
 /**
- * stmmac_adjust_freq
+ * stmmac_ptp_read - read raw cycle counter (to be used by time counter)
+ * @cc - the cyclecounter structure
  *
- * @ptp: pointer to ptp_clock_info structure
- * @ppb: desired period change in parts ber billion
+ * this function reads the cyclecounter registers and is called by the
+ * cyclecounter structure used to construct a ns counter from the
+ * arbitrary fixed point registers
+ */
+static cycle_t stmmac_ptp_read(const struct cyclecounter *ccnt)
+{
+	struct stmmac_priv *priv =
+		container_of(ccnt, struct stmmac_priv, ccnt);
+	cycle_t stamp = 0;
+
+	stamp = (u64)readl(priv->ioaddr + GMAC_ST_NSEC);
+	stamp |= (u64)readl(priv->ioaddr + GMAC_ST_SEC) << 32;
+
+	return stamp;
+}
+
+/**
+ * stmmac_ptp_adjfreq
+ * @ptp - the ptp clock structure
+ * @ppb - parts per billion adjustment from base
  *
- * Description: this function will adjust the frequency of hardware clock.
+ * adjust the frequency of the ptp cycle counter by the
+ * indicated ppb from the base frequency.
  */
-static int stmmac_adjust_freq(struct ptp_clock_info *ptp, s32 ppb)
+static int stmmac_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+	return 0;
+}
+
+/**
+ * stmmac_ptp_adjtime
+ * @ptp - the ptp clock structure
+ * @delta - offset to adjust the cycle counter by
+ *
+ * adjust the timer by resetting the timecounter structure.
+ */
+static int stmmac_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
 {
 	struct stmmac_priv *priv =
-	    container_of(ptp, struct stmmac_priv, ptp_clock_ops);
+		container_of(ptp, struct stmmac_priv, ptp_caps);
 	unsigned long flags;
-	u32 diff, addend;
-	int neg_adj = 0;
-	u64 adj;
+	u64 now;
 
-	if (ppb < 0) {
-		neg_adj = 1;
-		ppb = -ppb;
-	}
+	spin_lock_irqsave(&priv->tmreg_lock, flags);
+
+	now = timecounter_read(&priv->tcnt);
+	now += delta;
 
-	addend = priv->default_addend;
-	adj = addend;
-	adj *= ppb;
-	diff = div_u64(adj, 1000000000ULL);
-	addend = neg_adj ? (addend - diff) : (addend + diff);
+	/* reset the timecounter */
+	timecounter_init(&priv->tcnt,
+			 &priv->ccnt,
+			 now);
+
+	spin_unlock_irqrestore(&priv->tmreg_lock, flags);
+	return 0;
+}
 
-	spin_lock_irqsave(&priv->ptp_lock, flags);
+/**
+ * stmmac_ptp_gettime
+ * @ptp - the ptp clock structure
+ * @ts - timespec structure to hold the current time value
+ *
+ * read the timecounter and return the correct value on ns,
+ * after converting it into a struct timespec.
+ */
+static int stmmac_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
+{
+	struct stmmac_priv *priv =
+		container_of(ptp, struct stmmac_priv, ptp_caps);
+	u64 ns;
+        u32 remainder;
+        unsigned long flags;
 
-	priv->hw->ptp->config_addend(priv->ioaddr, addend);
+        spin_lock_irqsave(&priv->tmreg_lock, flags);
+        ns = timecounter_read(&priv->tcnt);
+        spin_unlock_irqrestore(&priv->tmreg_lock, flags);
 
-	spin_unlock_irqrestore(&priv->lock, flags);
+        ts->tv_sec = div_u64_rem(ns, 1000000000ULL, &remainder);
+        ts->tv_nsec = remainder;
 
 	return 0;
 }
 
 /**
- * stmmac_adjust_time
- *
- * @ptp: pointer to ptp_clock_info structure
- * @delta: desired change in nanoseconds
+ * stmmac_ptp_settime
+ * @ptp - the ptp clock structure
+ * @ts - the timespec containing the new time for the cycle counter
  *
- * Description: this function will shift/adjust the hardware clock time.
+ * reset the timecounter to use a new base value instead of the kernel
+ * wall timer value.
  */
-static int stmmac_adjust_time(struct ptp_clock_info *ptp, s64 delta)
+static int stmmac_ptp_settime(struct ptp_clock_info *ptp,
+			     const struct timespec *ts)
 {
 	struct stmmac_priv *priv =
-	    container_of(ptp, struct stmmac_priv, ptp_clock_ops);
+		container_of(ptp, struct stmmac_priv, ptp_caps);
+	u64 ns;
 	unsigned long flags;
-	u32 sec, nsec;
-	u32 quotient, reminder;
-	int neg_adj = 0;
 
-	if (delta < 0) {
-		neg_adj = 1;
-		delta = -delta;
-	}
+	ns = ts->tv_sec * 1000000000ULL;
+	ns += ts->tv_nsec;
 
-	quotient = div_u64_rem(delta, 1000000000ULL, &reminder);
-	sec = quotient;
-	nsec = reminder;
+	/* reset the timecounter */
+	spin_lock_irqsave(&priv->tmreg_lock, flags);
+	timecounter_init(&priv->tcnt, &priv->ccnt, ns);
+	spin_unlock_irqrestore(&priv->tmreg_lock, flags);
 
-	spin_lock_irqsave(&priv->ptp_lock, flags);
+	return 0;
+}
 
-	priv->hw->ptp->adjust_systime(priv->ioaddr, sec, nsec, neg_adj);
+/**
+ * stmmac_ptp_enable
+ * @ptp - the ptp clock structure
+ * @rq - the requested feature to change
+ * @on - whether to enable or disable the feature
+ *
+ * enable (or disable) ancillary features of the phc subsystem.
+ * our driver only supports the PPS feature on the X540
+ */
+static int stmmac_ptp_enable(struct ptp_clock_info *ptp,
+			    struct ptp_clock_request *rq, int on)
+{
+	struct stmmac_priv *priv =
+		container_of(ptp, struct stmmac_priv, ptp_caps);
+	uint32_t reg = 0;
 
-	spin_unlock_irqrestore(&priv->lock, flags);
+	/**
+	 * When enabling PPS functionality in STMMAC we need to unmask the
+	 * interrupt mask reg and enable the TSTRIG bit in the timestamp control
+	 * reg
+	 */
+	if (rq->type == PTP_CLK_REQ_PPS) {
+		if (on){
+			priv->hwts |= STMMAC_PTP_PPS_ENABLED;
+
+			/* Enable TSTRIG */
+			reg = readl(priv->ioaddr + GMAC_TS_CTRL);
+			reg |= GMAC_TS_CTRL_TSTRIG;
+			writel(reg, priv->ioaddr + GMAC_TS_CTRL);
+			wmb();
+
+			/* Unmask interrupt */
+			reg = readl(priv->ioaddr + GMAC_INT_MASK);
+			printk(KERN_INFO "%s[on] read interrupt mask 0x%08x\n", __func__, reg);
+			reg &= ~GMAC_INT_MASK_TSIM;
+			printk(KERN_INFO "%s[on] write interrupt mask 0x%08x\n", __func__, reg);
+			writel(reg, priv->ioaddr + GMAC_INT_MASK);
+			wmb();
+
+		} else {
+			/* Mask interrupt */
+			reg = readl(priv->ioaddr + GMAC_INT_MASK);
+			printk(KERN_INFO "%s[off] read interrupt mask 0x%08x\n", __func__, reg);
+			reg |= GMAC_INT_MASK_TSIM;
+			printk(KERN_INFO "%s[off] write interrupt mask 0x%08x\n", __func__, reg);
+			writel(reg, priv->ioaddr + GMAC_INT_MASK);
+			wmb();
+
+			/* Disable TSTRIG */
+			reg = readl(priv->ioaddr + GMAC_TS_CTRL);
+			reg &= ~GMAC_TS_CTRL_TSTRIG;
+			writel(reg, priv->ioaddr + GMAC_TS_CTRL);
+			wmb();
+
+			priv->hwts &=
+				~STMMAC_PTP_PPS_ENABLED;
+		}
+		return 0;
+	}
 
-	return 0;
+	return -ENOTSUPP;
 }
 
 /**
- * stmmac_get_time
+ * stmmac_ptp_check_pps_event
+ * @priv - the private priv structure
  *
- * @ptp: pointer to ptp_clock_info structure
- * @ts: pointer to hold time/result
+ * This function is called by the interrupt routine when checking for
+ * interrupts. It will check and handle a pps event.
+ */
+void stmmac_ptp_check_pps_event(struct stmmac_priv *priv)
+{
+	struct ptp_clock_event event;
+	event.type = PTP_CLOCK_PPS;
+
+	/* Make sure ptp clock is valid, and PPS event enabled */
+	if (!priv->ptp_clock ||
+	    !(priv->hwts & STMMAC_PTP_PPS_ENABLED)){
+		return;
+	}
+
+	ptp_clock_event(priv->ptp_clock, &event);
+}
+
+#if 0
+/**
+ * stmmac_ptp_overflow_check - delayed work to detect SYSTIME overflow
+ * @work: structure containing information about this work task
  *
- * Description: this function will read the current time from the
- * hardware clock and store it in @ts.
+ * this work function is scheduled to continue reading the timecounter
+ * in order to prevent missing when the system time registers wrap
+ * around. This needs to be run approximately twice a minute when no
+ * PTP activity is occurring.
  */
-static int stmmac_get_time(struct ptp_clock_info *ptp, struct timespec *ts)
+void stmmac_ptp_overflow_check(struct stmmac_priv *priv)
 {
-	struct stmmac_priv *priv =
-	    container_of(ptp, struct stmmac_priv, ptp_clock_ops);
-	unsigned long flags;
-	u64 ns;
-	u32 reminder;
+	unsigned long elapsed_jiffies = priv->last_overflow_check - jiffies;
+	struct timespec ts;
 
-	spin_lock_irqsave(&priv->ptp_lock, flags);
+	if ((priv->hwts & STMMAC_PTP_OVERFLOW_CHECK_ENABLED) &&
+	    (elapsed_jiffies >= STMMAC_OVERFLOW_PERIOD)) {
+		stmmac_ptp_gettime(&priv->ptp_caps, &ts);
+		priv->last_overflow_check = jiffies;
+	}
+}
+#endif
 
-	ns = priv->hw->ptp->get_systime(priv->ioaddr);
+/**
+ * stmmac_ptp_tx_hwtstamp - utility function which checks for TX time stamp
+ * @q_vector: structure containing interrupt and ring information
+ * @skb: particular skb to send timestamp with
+ *
+ * if the timestamp is valid, we convert it into the timecounter ns
+ * value, then store that result into the shhwtstamps structure which
+ * is passed up the network stack
+ */
+void stmmac_ptp_tx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *pdma,
+			   struct sk_buff *skb)
+{
+	/* Sanity check input */
+	if (unlikely(priv == NULL || pdma == NULL || skb == NULL)){
+		return;
+	}
 
-	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+	if(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP){
+		struct skb_shared_hwtstamps shhwtstamps;
+		u64 ns;
+		u64 regval;
+		unsigned long flags;
+
+		regval = (u64)pdma->ts_lo;
+		regval |= (u64)pdma->ts_hi << 32;
+
+		spin_lock_irqsave(&priv->tmreg_lock, flags);
+		ns = timecounter_cyc2time(&priv->tcnt, regval);
+		spin_unlock_irqrestore(&priv->tmreg_lock, flags);
+
+		memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+		shhwtstamps.hwtstamp = ns_to_ktime(ns);
+		skb_tstamp_tx(skb, &shhwtstamps);
+	}
+}
 
-	ts->tv_sec = div_u64_rem(ns, 1000000000ULL, &reminder);
-	ts->tv_nsec = reminder;
+/**
+ * stmmac_ptp_rx_hwtstamp - utility function which checks for RX time stamp
+ * @q_vector: structure containing interrupt and ring information
+ * @skb: particular skb to send timestamp with
+ *
+ * if the timestamp is valid, we convert it into the timecounter ns
+ * value, then store that result into the shhwtstamps structure which
+ * is passed up the network stack
+ */
+void stmmac_ptp_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *pdma,
+			   struct sk_buff *skb)
+{
+	/* Sanity check input */
+	if (unlikely(priv == NULL || pdma == NULL || skb == NULL)){
+		return;
+	}
 
-	return 0;
+	if(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP){
+		struct skb_shared_hwtstamps shhwtstamps;
+		u64 ns;
+		u64 regval;
+		unsigned long flags;
+
+		regval = (u64)pdma->ts_lo;
+		regval |= (u64)pdma->ts_hi << 32;
+
+		spin_lock_irqsave(&priv->tmreg_lock, flags);
+		ns = timecounter_cyc2time(&priv->tcnt, regval);
+		spin_unlock_irqrestore(&priv->tmreg_lock, flags);
+
+		memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+		shhwtstamps.hwtstamp = ns_to_ktime(ns);
+	}
 }
 
 /**
- * stmmac_set_time
+ * ixgbe_ptp_hwtstamp_ioctl - control hardware time stamping
+ * @priv: pointer to priv struct
+ * @ifreq: ioctl data
+ * @cmd: particular ioctl requested
  *
- * @ptp: pointer to ptp_clock_info structure
- * @ts: time value to set
+ * Outgoing time stamping can be enabled and disabled. Play nice and
+ * disable it when requested, although it shouldn't case any overhead
+ * when no packet needs it. At most one packet in the queue may be
+ * marked for time stamping, otherwise it would be impossible to tell
+ * for sure to which packet the hardware time stamp belongs.
  *
- * Description: this function will set the current time on the
- * hardware clock.
+ * Incoming time stamping has to be configured via the hardware
+ * filters. Not all combinations are supported, in particular event
+ * type has to be specified. Matching the kind of event packet is
+ * not supported, with the exception of "all V2 events regardless of
+ * level 2 or 4".
  */
-static int stmmac_set_time(struct ptp_clock_info *ptp,
-			   const struct timespec *ts)
+int stmmac_ptp_hwtstamp_ioctl(struct stmmac_priv *priv,
+			     struct ifreq *ifr, int cmd)
 {
-	struct stmmac_priv *priv =
-	    container_of(ptp, struct stmmac_priv, ptp_clock_ops);
-	unsigned long flags;
+	struct hwtstamp_config config;
+//	struct stmmac_priv *priv = netdev_priv(netdev);
+	u32 tsctl = 0;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	/* reserved for future extensions */
+	if (config.flags)
+		return -EINVAL;
+
+	/* Snapshot the reg - preserve Timestamp Interrupt Trigger Enable */
+	tsctl = readl(priv->ioaddr + GMAC_TS_CTRL) & GMAC_TS_CTRL_TSTRIG;
+
+	/* TX */
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		priv->hwts &= ~STMMAC_PTP_HWTS_TX_EN;
+		printk(KERN_INFO "%s set TX PTP en false\n", __func__);
+		break;
+	case HWTSTAMP_TX_ON:
+		priv->hwts |= STMMAC_PTP_HWTS_TX_EN;
+		printk(KERN_INFO "%s set TX PTP en true\n", __func__);
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	/* RX */
+	priv->hwts |= STMMAC_PTP_HWTS_RX_EN;
 
-	spin_lock_irqsave(&priv->ptp_lock, flags);
+	switch (config.rx_filter) {
 
-	priv->hw->ptp->init_systime(priv->ioaddr, ts->tv_sec, ts->tv_nsec);
+	
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+		/* 
+		 * V1_L4 UDP any event 
+		 * SYNC, Follow_Up, Delay_Req, Delay_Resp,
+		 * Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
+		 *
+		 * SNAPTYPSEL=1, TSMSTRENA=x, TSEVNTENA=0, TSVER2ENA=0, IPV4=1 
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL1 | GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V1_L4_EVENT \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+		/*
+		 * V1_L4 Master
+		 * Delay_Req
+		 *
+		 * SNAPTYPSEL=0, TSMSTRENA=1, TSEVNTENA=1, TSVER2ENA=0, IPV4=1
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSMSTRENA;
+		tsctl |= GMAC_TS_CTRL_TSEVNTENA | GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+		/*
+		 * V1_L4 Slave
+		 * Sync
+		 *
+ 		 * SNAPTYPSEL=0, TSMSTRENA=0, TSEVNTENA=1, TSVER2ENA=0, IPV4=1
+		 */ 
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSEVNTENA;
+		tsctl |= GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V1_L4_SYNC \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+		/*
+		 * V2_L4 UDP any event 
+		 * SYNC, Follow_Up, Delay_Req, Delay_Resp,
+		 * Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
+		 *
+		 * SNAPTYPSEL=1, TSMSTRENA=x, TSEVNTENA=0, TSVER2ENA=1, IPV4=1 
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL1 | GMAC_TS_CTRL_TSVER2ENA | GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_L4_EVENT \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+		/*
+		 * V2_L4 Master
+		 * Delay_Req
+		 *
+		 * SNAPTYPSEL=0, TSMSTRENA=1, TSEVNTENA=1, TSVER2ENA=1, IPV4=1
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSMSTRENA;
+		tsctl |= GMAC_TS_CTRL_TSEVNTENA | GMAC_TS_CTRL_TSVER2ENA;
+		tsctl |= GMAC_TS_CTRL_TSIPV4ENA;
+
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+		/*
+		 * V2_L4 Slave
+		 * Sync
+		 *
+ 		 * SNAPTYPSEL=0, TSMSTRENA=0, TSEVNTENA=1, TSVER2ENA=1, IPV4=1
+		 */ 
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSVER2ENA | GMAC_TS_CTRL_TSEVNTENA;
+		tsctl |= GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_L4_SYNC \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+		/*
+		 * V2_L2 Ethernet any event
+		 * SYNC, Follow_Up, Delay_Req, Delay_Resp,
+		 * Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
+		 *
+		 * SNAPTYPSEL=1, TSMSTRENA=x, TSEVNTENA=0, TSVER2ENA=1,TSIPENA=1
+		 * TSIPENA=1
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL1 | GMAC_TS_CTRL_TSVER2ENA | GMAC_TS_CTRL_TSIPENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_L2_EVENT \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+		/*
+		 * V2_L2 Master
+		 * Delay_Req
+		 *
+		 * SNAPTYPSEL=0, TSMSTRENA=1, TSEVNTENA=1, TSVER2ENA=1,TSIPENA=1
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSMSTRENA;
+		tsctl |= GMAC_TS_CTRL_TSEVNTENA | GMAC_TS_CTRL_TSVER2ENA;
+		tsctl |= GMAC_TS_CTRL_TSIPENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ \n", __func__);
+		break;
+	
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+		/*
+		 * V2_L2 Slave
+		 * Sync
+		 *
+ 		 * SNAPTYPSEL=0, TSMSTRENA=0, TSEVNTENA=1, TSVER2ENA=1,
+ 		 * TSIPENA=1 
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSVER2ENA;
+		tsctl |= GMAC_TS_CTRL_TSEVNTENA | GMAC_TS_CTRL_TSIPENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_L2_SYNC \n", __func__);
+		break;
+	
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+		/*
+		 * V2_L2 Ethernet any event
+		 * SYNC, Follow_Up, Delay_Req, Delay_Resp,
+		 * Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
+		 *
+		 * SNAPTYPSEL=1, TSMSTRENA=x, TSEVNTENA=0, TSVER2ENA=1
+		 * TSIPENA=1, TSIPV4ENA=1
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL1 | GMAC_TS_CTRL_TSVER2ENA;
+		tsctl |= GMAC_TS_CTRL_TSIPENA | GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_EVENT \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		/*
+		 * V2_L2_L4 Master 
+		 * Delay_Req
+		 *
+		 * SNAPTYPSEL=0, TSMSTRENA=1, TSEVNTENA=1,
+		 * TSVER2ENA=1,TSIPENA=1, TSIPV4ENA=1
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSMSTRENA;
+		tsctl |= GMAC_TS_CTRL_TSEVNTENA | GMAC_TS_CTRL_TSVER2ENA;
+		tsctl |= GMAC_TS_CTRL_TSIPENA | GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_DELAY_REQ \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+		/* 
+		 * V2_L2_L4 Slave
+		 * Sync
+		 *
+ 		 * SNAPTYPSEL=0, TSMSTRENA=0, TSEVNTENA=1, TSVER2ENA=1,
+ 		 * TSIPENA=1, TSIPV4ENA=1 
+		 */
+		tsctl |= GMAC_TS_CTRL_SNTYPSEL0 | GMAC_TS_CTRL_TSVER2ENA;
+		tsctl |= GMAC_TS_CTRL_TSEVNTENA | GMAC_TS_CTRL_TSIPENA;
+		tsctl |= GMAC_TS_CTRL_TSIPV4ENA;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_PTP_V2_SYNC \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_ALL:
+		/*
+		 * V2_L2_L4 Ethernet any event
+		 *
+		 * SYNC, Follow_Up, Delay_Req, Delay_Resp,
+		 * Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
+		 *
+		 * GMAC_TS_CTRL_TSENALL
+		 */
+		tsctl |= GMAC_TS_CTRL_TSENALL;
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_ALL \n", __func__);
+		break;
+
+	case HWTSTAMP_FILTER_NONE:
+		printk(KERN_INFO "%s HWTSTAMP_FILTER_NONE  \n", __func__);
+		priv->hwts &= ~STMMAC_PTP_HWTS_RX_EN;
+		break;
+
+	default:
+		printk(KERN_INFO "%s error ioctl rx type %d \n", __func__, config.rx_filter);
+		/* bad/unknown parameter */
+		return -ERANGE;
+	}
 
-	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+	/* Set the TS CTRL reg */
+	tsctl |= GMAC_TS_CTRL_TSENA;
+	writel(tsctl, priv->ioaddr + GMAC_TS_CTRL);
+	wmb();
 
-	return 0;
+	printk(KERN_INFO "%s sync ts_ctl @ value 0x%08x\n", __func__, tsctl);
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+		-EFAULT : 0;
 }
 
-static int stmmac_enable(struct ptp_clock_info *ptp,
-			 struct ptp_clock_request *rq, int on)
+
+#define DEFAULT_PTP_CLK 50
+
+/**
+ * stmmac_ptp_init_timestamp - initialise the PTP clock
+ * @priv - pointer to the priv structure
+ *
+ * This function initialises the PTP clock consistent with the method spelled
+ * out in the Snopsys documentation
+ */
+static void stmmac_ptp_init_timestamp(struct stmmac_priv *priv)
 {
-	return -EOPNOTSUPP;
+	unsigned long tsctl = GMAC_TS_CTRL_TSENA, flags = 0;
+	uint8_t ssinc = 0;
+
+	/* Enable TS */	
+	writel(tsctl, priv->ioaddr + GMAC_TS_CTRL);
+	wmb();
+
+	/* Write SSINC - number of nano seconds to increment on each clock */
+	if(ssinc == 0){
+		ssinc = DEFAULT_PTP_CLK;
+	}
+	ssinc = 1000/ssinc;
+	writel(ssinc, priv->ioaddr + GMAC_SS_INC);
+	wmb();
+
+	printk(KERN_INFO "%s setting PTP_CLK to 0x%02x\n", __func__, ssinc);
+
+	/* Reset system time registers to zero */
+	writel(0x00000000, priv->ioaddr + GMAC_ST_SEC);
+	writel(0x00000000, priv->ioaddr + GMAC_ST_NSEC);
+	wmb();
+
+	/* Set TSINT to latch values in ST_SEC and ST_NSEC */
+	tsctl |= GMAC_TS_CTRL_TSINT;
+	writel(tsctl, priv->ioaddr + GMAC_TS_CTRL);
+	wmb();
+	printk(KERN_INFO "%s tsctl == 0x%08lx (TSINIT | TSENA)\n", __func__, tsctl);
+
+	spin_lock_irqsave(&priv->tmreg_lock, flags);
+
+	/* Init timecounter */
+	memset(&priv->ccnt, 0, sizeof(priv->ccnt));
+	priv->ccnt.read = stmmac_ptp_read;
+	priv->ccnt.mask = CLOCKSOURCE_MASK(64);
+	priv->ccnt.mult = 1;
+	priv->ccnt.shift = 0;
+
+	/* reset the ns time counter */
+	timecounter_init(&priv->tcnt, &priv->ccnt,
+			 ktime_to_ns(ktime_get_real()));
+
+	spin_unlock_irqrestore(&priv->tmreg_lock, flags);
 }
 
-/* structure describing a PTP hardware clock */
-static struct ptp_clock_info stmmac_ptp_clock_ops = {
-	.owner = THIS_MODULE,
-	.name = "stmmac_ptp_clock",
-	.max_adj = 62500000,
-	.n_alarm = 0,
-	.n_ext_ts = 0,
-	.n_per_out = 0,
-	.pps = 0,
-	.adjfreq = stmmac_adjust_freq,
-	.adjtime = stmmac_adjust_time,
-	.gettime = stmmac_get_time,
-	.settime = stmmac_set_time,
-	.enable = stmmac_enable,
-};
-
-/**
- * stmmac_ptp_register
- * @priv: driver private structure
- * Description: this function will register the ptp clock driver
- * to kernel. It also does some house keeping work.
+/**
+ * stmmac_ptp_init
+ * @priv - the stmmac private priv structure
+ *
+ * This function performs the required steps for enabling ptp
+ * support. If ptp support has already been loaded it simply calls the
+ * cyclecounter init routine and exits.
  */
-int stmmac_ptp_register(struct stmmac_priv *priv)
+void stmmac_ptp_init(struct net_device *ndev, struct device * pdev)
 {
-	spin_lock_init(&priv->ptp_lock);
-	priv->ptp_clock_ops = stmmac_ptp_clock_ops;
+	struct stmmac_priv *priv = netdev_priv(ndev);
 
-	priv->ptp_clock = ptp_clock_register(&priv->ptp_clock_ops,
-					     priv->device);
+	/* Ensure the timestamp interrupt is masked */
+	writel(GMAC_INT_MASK_TSIM, priv->ioaddr + GMAC_INT_MASK);
+
+	/* Fill out PTP callback contents */
+	snprintf(priv->ptp_caps.name, 16, "%pm", ndev->dev_addr);
+	priv->ptp_caps.owner = THIS_MODULE;
+	priv->ptp_caps.max_adj = 0;	/* Cannot be adjusted */
+	priv->ptp_caps.n_alarm = 0;
+	priv->ptp_caps.n_ext_ts = 0;
+	priv->ptp_caps.n_per_out = 0;
+	priv->ptp_caps.pps = 0;
+	priv->ptp_caps.adjfreq = stmmac_ptp_adjfreq;
+	priv->ptp_caps.adjtime = stmmac_ptp_adjtime;
+	priv->ptp_caps.gettime = stmmac_ptp_gettime;
+	priv->ptp_caps.settime = stmmac_ptp_settime;
+	priv->ptp_caps.enable = stmmac_ptp_enable;
+
+	spin_lock_init(&priv->tmreg_lock);
+
+	stmmac_ptp_init_timestamp(priv);
+
+	/* Init to default state */
+//	priv->hwts = STMMAC_PTP_OVERFLOW_CHECK_ENABLED;
+
+	priv->ptp_clock = ptp_clock_register(&priv->ptp_caps, pdev);
 	if (IS_ERR(priv->ptp_clock)) {
 		priv->ptp_clock = NULL;
-		pr_err("ptp_clock_register() failed on %s\n", priv->dev->name);
-	} else
-		pr_debug("Added PTP HW clock successfully on %s\n",
-			 priv->dev->name);
+		printk(KERN_ERR "%s ptp_clock_reg failed!\n", __func__);
+	} else {
+		printk(KERN_INFO "%s ptp_clock_reg success!\n", __func__);
+	}
 
-	return 0;
+	return;
 }
 
 /**
- * stmmac_ptp_unregister
- * @priv: driver private structure
- * Description: this function will remove/unregister the ptp clock driver
- * from the kernel.
+ * stmmac_ptp_remove - disable ptp device and stop the overflow check
+ * @priv: pointer to priv struct
+ *
+ * this function stops the ptp support, and cancels the delayed work.
  */
-void stmmac_ptp_unregister(struct stmmac_priv *priv)
+void stmmac_ptp_remove(struct stmmac_priv *priv)
 {
-	if (priv->ptp_clock) {
+	/* Ensure the timestamp interrupt is masked */
+	writel(GMAC_INT_MASK_TSIM, priv->ioaddr + GMAC_INT_MASK);
+
+	/* stop the overflow check task */
+//	priv->hwts &= ~STMMAC_PTP_OVERFLOW_CHECK_ENABLED;
+
+	if (priv->ptp_clock != NULL) {
 		ptp_clock_unregister(priv->ptp_clock);
-		pr_debug("Removed PTP HW clock successfully on %s\n",
-			 priv->dev->name);
+		priv->ptp_clock = NULL;
+		printk(KERN_INFO "%s removed ptp_clock\n", __func__);
 	}
 }
+
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1164930..c959209 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -470,14 +470,6 @@
 	 */
 	void (*txtstamp)(struct phy_device *dev, struct sk_buff *skb, int type);
 
-	/* Some devices (e.g. qnap TS-119P II) require PHY register changes to
-	 * enable Wake on LAN, so set_wol is provided to be called in the
-	 * ethernet driver's set_wol function. */
-	int (*set_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
-
-	/* See set_wol, but for checking whether Wake on LAN is enabled. */
-	void (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
-
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)
@@ -529,13 +521,13 @@
 int phy_device_register(struct phy_device *phy);
 int phy_init_hw(struct phy_device *phydev);
 struct phy_device * phy_attach(struct net_device *dev,
-		const char *bus_id, phy_interface_t interface);
+		const char *bus_id, u32 flags, phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
-		void (*handler)(struct net_device *),
+		void (*handler)(struct net_device *), u32 flags,
 		phy_interface_t interface);
 struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
-		void (*handler)(struct net_device *),
+		void (*handler)(struct net_device *), u32 flags,
 		phy_interface_t interface);
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
@@ -584,8 +576,6 @@
 int phy_get_eee_err(struct phy_device *phydev);
 int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data);
 int phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data);
-int phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
-void phy_ethtool_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
 
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
diff --git a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c
index b75f4b2..aaccd3a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c
@@ -79,8 +79,8 @@
 	struct net_device_stats *stats = (struct net_device_stats *)data;
 
 	if (unlikely(p->des01.rx.last_descriptor == 0)) {
-		pr_warn("%s: Oversized frame spanned multiple buffers\n",
-			__func__);
+		pr_warning("ndesc Error: Oversized Ethernet "
+			   "frame spanned multiple buffers\n");
 		stats->rx_length_errors++;
 		return discard_frame;
 	}
@@ -122,28 +122,30 @@
 	return ret;
 }
 
-static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,
-			       int end)
+static void ndesc_init_rx_desc(struct dma_desc *p, unsigned int ring_size,
+			       int disable_rx_ic)
 {
-	p->des01.rx.own = 1;
-	p->des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
-
-	if (mode == STMMAC_CHAIN_MODE)
-		ndesc_rx_set_on_chain(p, end);
-	else
-		ndesc_rx_set_on_ring(p, end);
-
-	if (disable_rx_ic)
-		p->des01.rx.disable_ic = 1;
+	int i;
+	for (i = 0; i < ring_size; i++) {
+		p->des01.rx.own = 1;
+		p->des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
+
+		ndesc_rx_set_on_ring_chain(p, (i == ring_size - 1));
+
+		if (disable_rx_ic)
+			p->des01.rx.disable_ic = 1;
+		p++;
+	}
 }
 
-static void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)
+static void ndesc_init_tx_desc(struct dma_desc *p, unsigned int ring_size)
 {
-	p->des01.tx.own = 0;
-	if (mode == STMMAC_CHAIN_MODE)
-		ndesc_tx_set_on_chain(p, end);
-	else
-		ndesc_tx_set_on_ring(p, end);
+	int i;
+	for (i = 0; i < ring_size; i++) {
+		p->des01.tx.own = 0;
+		ndesc_tx_set_on_ring_chain(p, (i == (ring_size - 1)));
+		p++;
+	}
 }
 
 static int ndesc_get_tx_owner(struct dma_desc *p)
@@ -171,25 +173,19 @@
 	return p->des01.tx.last_segment;
 }
 
-static void ndesc_release_tx_desc(struct dma_desc *p, int mode)
+static void ndesc_release_tx_desc(struct dma_desc *p)
 {
 	int ter = p->des01.tx.end_ring;
 
 	memset(p, 0, offsetof(struct dma_desc, des2));
-	if (mode == STMMAC_CHAIN_MODE)
-		ndesc_end_tx_desc_on_chain(p, ter);
-	else
-		ndesc_end_tx_desc_on_ring(p, ter);
+	ndesc_end_tx_desc(p, ter);
 }
 
 static void ndesc_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,
-				  int csum_flag, int mode)
+				  int csum_flag)
 {
 	p->des01.tx.first_segment = is_fs;
-	if (mode == STMMAC_CHAIN_MODE)
-		norm_set_tx_desc_len_on_chain(p, len);
-	else
-		norm_set_tx_desc_len_on_ring(p, len);
+	norm_set_tx_desc_len(p, len);
 
 	if (likely(csum_flag))
 		p->des01.tx.checksum_insertion = cic_full;
@@ -219,39 +215,6 @@
 		return p->des01.rx.frame_length;
 }
 
-static void ndesc_enable_tx_timestamp(struct dma_desc *p)
-{
-	p->des01.tx.time_stamp_enable = 1;
-}
-
-static int ndesc_get_tx_timestamp_status(struct dma_desc *p)
-{
-	return p->des01.tx.time_stamp_status;
-}
-
-static u64 ndesc_get_timestamp(void *desc, u32 ats)
-{
-	struct dma_desc *p = (struct dma_desc *)desc;
-	u64 ns;
-
-	ns = p->des2;
-	/* convert high/sec time stamp value to nanosecond */
-	ns += p->des3 * 1000000000ULL;
-
-	return ns;
-}
-
-static int ndesc_get_rx_timestamp_status(void *desc, u32 ats)
-{
-	struct dma_desc *p = (struct dma_desc *)desc;
-
-	if ((p->des2 == 0xffffffff) && (p->des3 == 0xffffffff))
-		/* timestamp is corrupted, hence don't store it */
-		return 0;
-	else
-		return 1;
-}
-
 const struct stmmac_desc_ops ndesc_ops = {
 	.tx_status = ndesc_get_tx_status,
 	.rx_status = ndesc_get_rx_status,
@@ -268,8 +231,4 @@
 	.set_tx_owner = ndesc_set_tx_owner,
 	.set_rx_owner = ndesc_set_rx_owner,
 	.get_rx_frame_len = ndesc_get_rx_frame_len,
-	.enable_tx_timestamp = ndesc_enable_tx_timestamp,
-	.get_tx_timestamp_status = ndesc_get_tx_timestamp_status,
-	.get_timestamp = ndesc_get_timestamp,
-	.get_rx_timestamp_status = ndesc_get_rx_timestamp_status,
 };
diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h
index 1164930..c959209 100644
--- a/drivers/net/ethernet/stmicro/stmmac/descs.h
+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h
@@ -24,7 +24,6 @@
 #ifndef __DESCS_H__
 #define __DESCS_H__
 
-/* Basic descriptor structure for normal and alternate descriptors */
 struct dma_desc {
 	union {
 		/* Receive descriptor */
@@ -61,7 +60,7 @@
 		} rx;
 		struct {
 			/* RDES0 */
-			u32 rx_mac_addr:1;
+			u32 payload_csum_error:1;
 			u32 crc_error:1;
 			u32 dribbling:1;
 			u32 error_gmii:1;
@@ -206,57 +205,13 @@
 	#endif
 };
 
-/* Extended descriptor structure (supported by new SYNP GMAC generations) */
-struct dma_extended_desc {
-	struct dma_desc basic;
-	union {
-		struct {
-			u32 ip_payload_type:3;
-			u32 ip_hdr_err:1;
-			u32 ip_payload_err:1;
-			u32 ip_csum_bypassed:1;
-			u32 ipv4_pkt_rcvd:1;
-			u32 ipv6_pkt_rcvd:1;
-			u32 msg_type:4;
-			u32 ptp_frame_type:1;
-			u32 ptp_ver:1;
-			u32 timestamp_dropped:1;
-			u32 reserved:1;
-			u32 av_pkt_rcvd:1;
-			u32 av_tagged_pkt_rcvd:1;
-			u32 vlan_tag_priority_val:3;
-			u32 reserved3:3;
-			u32 l3_filter_match:1;
-			u32 l4_filter_match:1;
-			u32 l3_l4_filter_no_match:2;
-			u32 reserved4:4;
-		} erx;
-		struct {
-			u32 reserved;
-		} etx;
-	} des4;
-	unsigned int des5;	/* Reserved */
-	unsigned int des6;	/* Tx/Rx Timestamp Low */
-	unsigned int des7;	/* Tx/Rx Timestamp High */
-};
-
 /* Transmit checksum insertion control */
 enum tdes_csum_insertion {
 	cic_disabled = 0,	/* Checksum Insertion Control */
 	cic_only_ip = 1,	/* Only IP header */
-	/* IP header but pseudoheader is not calculated */
-	cic_no_pseudoheader = 2,
+	cic_no_pseudoheader = 2,	/* IP header but pseudoheader
+					 * is not calculated */
 	cic_full = 3,		/* IP header and pseudoheader */
 };
 
-/* Extended RDES4 definitions */
-#define RDES_EXT_NO_PTP			0
-#define RDES_EXT_SYNC			0x1
-#define RDES_EXT_FOLLOW_UP		0x2
-#define RDES_EXT_DELAY_REQ		0x3
-#define RDES_EXT_DELAY_RESP		0x4
-#define RDES_EXT_PDELAY_REQ		0x5
-#define RDES_EXT_PDELAY_RESP		0x6
-#define RDES_EXT_PDELAY_FOLLOW_UP	0x7
-
 #endif /* __DESCS_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
index 1164930..c959209 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
@@ -1,148 +0,0 @@
-/*******************************************************************************
-  Copyright (C) 2013  Vayavya Labs Pvt Ltd
-
-  This implements all the API for managing HW timestamp & PTP.
-
-  This program is free software; you can redistribute it and/or modify it
-  under the terms and conditions of the GNU General Public License,
-  version 2, as published by the Free Software Foundation.
-
-  This program is distributed in the hope it will be useful, but WITHOUT
-  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-  more details.
-
-  You should have received a copy of the GNU General Public License along with
-  this program; if not, write to the Free Software Foundation, Inc.,
-  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-
-  The full GNU General Public License is included in this distribution in
-  the file called "COPYING".
-
-  Author: Rayagond Kokatanur <rayagond@vayavyalabs.com>
-  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
-*******************************************************************************/
-
-#include <linux/io.h>
-#include <linux/delay.h>
-#include "common.h"
-#include "stmmac_ptp.h"
-
-static void stmmac_config_hw_tstamping(void __iomem *ioaddr, u32 data)
-{
-	writel(data, ioaddr + PTP_TCR);
-}
-
-static void stmmac_config_sub_second_increment(void __iomem *ioaddr)
-{
-	u32 value = readl(ioaddr + PTP_TCR);
-	unsigned long data;
-
-	/* Convert the ptp_clock to nano second
-	 * formula = (1/ptp_clock) * 1000000000
-	 * where, ptp_clock = 50MHz.
-	 */
-	data = (1000000000ULL / 50000000);
-
-	/* 0.465ns accuracy */
-	if (value & PTP_TCR_TSCTRLSSR)
-		data = (data * 100) / 465;
-
-	writel(data, ioaddr + PTP_SSIR);
-}
-
-static int stmmac_init_systime(void __iomem *ioaddr, u32 sec, u32 nsec)
-{
-	int limit;
-	u32 value;
-
-	writel(sec, ioaddr + PTP_STSUR);
-	writel(nsec, ioaddr + PTP_STNSUR);
-	/* issue command to initialize the system time value */
-	value = readl(ioaddr + PTP_TCR);
-	value |= PTP_TCR_TSINIT;
-	writel(value, ioaddr + PTP_TCR);
-
-	/* wait for present system time initialize to complete */
-	limit = 10;
-	while (limit--) {
-		if (!(readl(ioaddr + PTP_TCR) & PTP_TCR_TSINIT))
-			break;
-		mdelay(10);
-	}
-	if (limit < 0)
-		return -EBUSY;
-
-	return 0;
-}
-
-static int stmmac_config_addend(void __iomem *ioaddr, u32 addend)
-{
-	u32 value;
-	int limit;
-
-	writel(addend, ioaddr + PTP_TAR);
-	/* issue command to update the addend value */
-	value = readl(ioaddr + PTP_TCR);
-	value |= PTP_TCR_TSADDREG;
-	writel(value, ioaddr + PTP_TCR);
-
-	/* wait for present addend update to complete */
-	limit = 10;
-	while (limit--) {
-		if (!(readl(ioaddr + PTP_TCR) & PTP_TCR_TSADDREG))
-			break;
-		mdelay(10);
-	}
-	if (limit < 0)
-		return -EBUSY;
-
-	return 0;
-}
-
-static int stmmac_adjust_systime(void __iomem *ioaddr, u32 sec, u32 nsec,
-				 int add_sub)
-{
-	u32 value;
-	int limit;
-
-	writel(sec, ioaddr + PTP_STSUR);
-	writel(((add_sub << PTP_STNSUR_ADDSUB_SHIFT) | nsec),
-		ioaddr + PTP_STNSUR);
-	/* issue command to initialize the system time value */
-	value = readl(ioaddr + PTP_TCR);
-	value |= PTP_TCR_TSUPDT;
-	writel(value, ioaddr + PTP_TCR);
-
-	/* wait for present system time adjust/update to complete */
-	limit = 10;
-	while (limit--) {
-		if (!(readl(ioaddr + PTP_TCR) & PTP_TCR_TSUPDT))
-			break;
-		mdelay(10);
-	}
-	if (limit < 0)
-		return -EBUSY;
-
-	return 0;
-}
-
-static u64 stmmac_get_systime(void __iomem *ioaddr)
-{
-	u64 ns;
-
-	ns = readl(ioaddr + PTP_STNSR);
-	/* convert sec time value to nanosecond */
-	ns += readl(ioaddr + PTP_STSR) * 1000000000ULL;
-
-	return ns;
-}
-
-const struct stmmac_hwtimestamp stmmac_ptp = {
-	.config_hw_tstamping = stmmac_config_hw_tstamping,
-	.init_systime = stmmac_init_systime,
-	.config_sub_second_increment = stmmac_config_sub_second_increment,
-	.config_addend = stmmac_config_addend,
-	.adjust_systime = stmmac_adjust_systime,
-	.get_systime = stmmac_get_systime,
-};
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 064eaac..f7afcad 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -463,6 +510,33 @@
 }
 
 /**
+ * phy_force_reduction - reduce PHY speed/duplex settings by one step
+ * @phydev: target phy_device struct
+ *
+ * Description: Reduces the speed/duplex settings by one notch,
+ *   in this order--
+ *   1000/FULL, 1000/HALF, 100/FULL, 100/HALF, 10/FULL, 10/HALF.
+ *   The function bottoms out at 10/HALF.
+ */
+static void phy_force_reduction(struct phy_device *phydev)
+{
+	int idx;
+
+	idx = phy_find_setting(phydev->speed, phydev->duplex);
+
+	idx++;
+
+	idx = phy_find_valid(idx, phydev->supported);
+
+	phydev->speed = settings[idx].speed;
+	phydev->duplex = settings[idx].duplex;
+
+	pr_info("Trying %d/%s\n",
+		phydev->speed, DUPLEX_FULL == phydev->duplex ? "FULL" : "HALF");
+}
+
+
+/**
  * phy_error - enter HALTED state for this PHY device
  * @phydev: target phy_device struct
  *
@@ -791,11 +865,30 @@
 				phydev->adjust_link(phydev->attached_dev);
 
 			} else if (0 == phydev->link_timeout--) {
+				int idx;
+
 				needs_aneg = 1;
 				/* If we have the magic_aneg bit,
 				 * we try again */
 				if (phydev->drv->flags & PHY_HAS_MAGICANEG)
 					break;
+
+				/* The timer expired, and we still
+				 * don't have a setting, so we try
+				 * forcing it until we find one that
+				 * works, starting from the fastest speed,
+				 * and working our way down */
+				idx = phy_find_valid(0, phydev->supported);
+
+				phydev->speed = settings[idx].speed;
+				phydev->duplex = settings[idx].duplex;
+
+				phydev->autoneg = AUTONEG_DISABLE;
+
+				pr_info("Trying %d/%s\n",
+					phydev->speed,
+					DUPLEX_FULL == phydev->duplex ?
+					"FULL" : "HALF");
 			}
 			break;
 		case PHY_NOLINK:
@@ -820,8 +913,10 @@
 				phydev->state = PHY_RUNNING;
 				netif_carrier_on(phydev->attached_dev);
 			} else {
-				if (0 == phydev->link_timeout--)
+				if (0 == phydev->link_timeout--) {
+					phy_force_reduction(phydev);
 					needs_aneg = 1;
+				}
 			}
 
 			phydev->adjust_link(phydev->attached_dev);
@@ -1044,7 +1139,7 @@
 		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
 		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
 		idx = phy_find_setting(phydev->speed, phydev->duplex);
-		if (!(lp & adv & settings[idx].setting))
+		if ((lp & adv & settings[idx].setting))
 			goto eee_exit;
 
 		if (clk_stop_enable) {
@@ -1140,19 +1235,3 @@
 	return 0;
 }
 EXPORT_SYMBOL(phy_ethtool_set_eee);
-
-int phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
-{
-	if (phydev->drv->set_wol)
-		return phydev->drv->set_wol(phydev, wol);
-
-	return -EOPNOTSUPP;
-}
-EXPORT_SYMBOL(phy_ethtool_set_wol);
-
-void phy_ethtool_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
-{
-	if (phydev->drv->get_wol)
-		phydev->drv->get_wol(phydev, wol);
-}
-EXPORT_SYMBOL(phy_ethtool_get_wol);
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 064eaac..f7afcad 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -44,13 +44,13 @@
 
 void phy_device_free(struct phy_device *phydev)
 {
-	put_device(&phydev->dev);
+	kfree(phydev);
 }
 EXPORT_SYMBOL(phy_device_free);
 
 static void phy_device_release(struct device *dev)
 {
-	kfree(to_phy_device(dev));
+	phy_device_free(to_phy_device(dev));
 }
 
 static struct phy_driver genphy_driver;
@@ -201,8 +201,6 @@
 	   there's no driver _already_ loaded. */
 	request_module(MDIO_MODULE_PREFIX MDIO_ID_FMT, MDIO_ID_ARGS(phy_id));
 
-	device_initialize(&dev->dev);
-
 	return dev;
 }
 EXPORT_SYMBOL(phy_device_create);
@@ -365,9 +363,9 @@
 	/* Run all of the fixups for this PHY */
 	phy_scan_fixups(phydev);
 
-	err = device_add(&phydev->dev);
+	err = device_register(&phydev->dev);
 	if (err) {
-		pr_err("PHY %d failed to add\n", phydev->addr);
+		pr_err("phy %d failed to register\n", phydev->addr);
 		goto out;
 	}
 
@@ -418,15 +416,16 @@
  * @dev: the network device to connect
  * @phydev: the pointer to the phy device
  * @handler: callback function for state change notifications
+ * @flags: PHY device's dev_flags
  * @interface: PHY device's interface
  */
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
-		       void (*handler)(struct net_device *),
+		       void (*handler)(struct net_device *), u32 flags,
 		       phy_interface_t interface)
 {
 	int rc;
 
-	rc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);
+	rc = phy_attach_direct(dev, phydev, flags, interface);
 	if (rc)
 		return rc;
 
@@ -444,6 +443,7 @@
  * @dev: the network device to connect
  * @bus_id: the id string of the PHY device to connect
  * @handler: callback function for state change notifications
+ * @flags: PHY device's dev_flags
  * @interface: PHY device's interface
  *
  * Description: Convenience function for connecting ethernet
@@ -455,7 +455,7 @@
  *   the desired functionality.
  */
 struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
-		void (*handler)(struct net_device *),
+		void (*handler)(struct net_device *), u32 flags,
 		phy_interface_t interface)
 {
 	struct phy_device *phydev;
@@ -471,7 +471,7 @@
 	}
 	phydev = to_phy_device(d);
 
-	rc = phy_connect_direct(dev, phydev, handler, interface);
+	rc = phy_connect_direct(dev, phydev, handler, flags, interface);
 	if (rc)
 		return ERR_PTR(rc);
 
@@ -576,13 +576,14 @@
  * phy_attach - attach a network device to a particular PHY device
  * @dev: network device to attach
  * @bus_id: Bus ID of PHY device to attach
+ * @flags: PHY device's dev_flags
  * @interface: PHY device's interface
  *
  * Description: Same as phy_attach_direct() except that a PHY bus_id
  *     string is passed instead of a pointer to a struct phy_device.
  */
 struct phy_device *phy_attach(struct net_device *dev,
-		const char *bus_id, phy_interface_t interface)
+		const char *bus_id, u32 flags, phy_interface_t interface)
 {
 	struct bus_type *bus = &mdio_bus_type;
 	struct phy_device *phydev;
@@ -598,7 +599,7 @@
 	}
 	phydev = to_phy_device(d);
 
-	rc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);
+	rc = phy_attach_direct(dev, phydev, flags, interface);
 	if (rc)
 		return ERR_PTR(rc);
 
1.7.4.1

