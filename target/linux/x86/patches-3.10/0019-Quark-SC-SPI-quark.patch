From xxxx Mon Sep 17 00:00:00 2001
From: Dan O'Donovan <danielx.o'donovan@intel.com>
Date: Thu, 13 Feb 2014 16:41:02 +0000
Subject: [PATCH 19/21] Quark SC SPI

---
 drivers/spi/Kconfig            |   39 ++-
 drivers/spi/Makefile           |    1 +
 drivers/spi/spi-gpio.c         |    2 +-
 drivers/spi/spi-pxa2xx-pci.c   |  129 ++++-
 drivers/spi/spi-pxa2xx.c       | 1290 +++++++++++++++++++++++++++-------------
 include/linux/pxa2xx_ssp.h     |   25 +
 include/linux/spi/pxa2xx_spi.h |   15 +-
 include/linux/spi/spi.h        |    2 +
 8 files changed, 1078 insertions(+), 425 deletions(-)

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 2e188e1..71358a6 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -35,6 +35,14 @@ config SPI_DEBUG
 	  Say "yes" to enable debug messaging (like dev_dbg and pr_debug),
 	  sysfs, and debugfs support in SPI controller and protocol drivers.
 
+config GEN3_SPI
+        bool "Intel Media SOC SPI support"
+        depends on SPI && ARCH_GEN3 && INTEL_QUARK_X1000_SOC
+        default y
+        help
+          This option enables Intel Media SOC SPI support.
+          For Quark this option depends on INTEL_QUARK_X1000_SOC.
+
 #
 # MASTER side ... talking to discrete SPI slave chips including microcontrollers
 #
@@ -74,7 +82,15 @@ config SPI_ATMEL
 	  This selects a driver for the Atmel SPI Controller, present on
 	  many AT32 (AVR32) and AT91 (ARM) chips.
 
-config SPI_BFIN5XX
+config SPI_CE5XX_SPI_FLASH
+        tristate "CE5XX SPI FLASH"
+        depends on ARCH_GEN3 && HW_MUTEXES
+        default y
+        help
+          This selects a driver for CE5XX Serial Flash controler
+
+
+config SPI_BFIN
 	tristate "SPI controller driver for ADI Blackfin5xx"
 	depends on BLACKFIN
 	help
@@ -302,14 +318,23 @@ config SPI_PXA2XX
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
-	depends on (ARCH_PXA || PCI || ACPI) && GENERIC_HARDIRQS
+	depends on (ARCH_PXA || (X86_32 && PCI)) && EXPERIMENTAL
 	select PXA_SSP if ARCH_PXA
 	help
-	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
+	  This enables using a PXA2xx or Intel CE4100/CE4200/CE5300 port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
 	  additional documentation can be found a Documentation/spi/pxa2xx.
 
 config SPI_PXA2XX_PCI
-	def_tristate SPI_PXA2XX && PCI
+        tristate "Intel CE SPI PCI adapter"
+	depends on SPI_PXA2XX && X86_32 && PCI && GEN3_SPI
+	help
+	  This driver supports the Intel CE SPI master controller and acts
+	  as the PCI-SPI glue code for PXA's driver
+
+config SPI_CE5XX_SPI_SLAVE
+	tristate "CE5XX SPI SLAVE"
+	help
+	  This selects a driver for CE5XX SPI Slave controler, it is emudulated into a spi device
 
 config SPI_RSPI
 	tristate "Renesas RSPI controller"
@@ -471,6 +496,14 @@ config SPI_DW_MMIO
 	depends on SPI_DESIGNWARE && HAVE_CLK
 
 #
+# Bring out the LPC_SCH SPI block
+#
+
+config SPI_LPC_SCH
+	tristate "LPC SCH Legacy SPI controller"
+	depends on LPC_SCH
+
+#
 # There are lots of SPI device types, with sensors and memory
 # being probably the most widely used ones.
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 64e970b..b67de97 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
 obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
 obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-midpci.o
 spi-dw-midpci-objs			:= spi-dw-pci.o spi-dw-mid.o
+obj-$(CONFIG_SPI_LPC_SCH)		+= spi-lpc-sch.o
 obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
 obj-$(CONFIG_SPI_FALCON)		+= spi-falcon.o
 obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-lib.o
@@ -50,10 +49,7 @@
 obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
 obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
 obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
-spi-pxa2xx-platform-objs		:= spi-pxa2xx.o
-spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_PXADMA)	+= spi-pxa2xx-pxadma.o
-spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_DMA)	+= spi-pxa2xx-dma.o
-obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
+obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx.o
 obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
 obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
diff --git a/drivers/spi/spi-pxa2xx-pci.c b/drivers/spi/spi-pxa2xx-pci.c
index cf95587..5250cd9 100644
--- a/drivers/spi/spi-pxa2xx-pci.c
+++ b/drivers/spi/spi-pxa2xx-pci.c
@@ -7,71 +7,269 @@
 #include <linux/of_device.h>
 #include <linux/module.h>
 #include <linux/spi/pxa2xx_spi.h>
+#include <linux/irq.h>
+#include <linux/platform_data/quark.h>
+
+/* defined here to avoid including arch/x86/pci/intel_media_proc_gen3.c */
+#define CE3100_SOC_DEVICE_ID 0x2E50
+#define CE4100_SOC_DEVICE_ID 0x0708
+#define CE4200_SOC_DEVICE_ID 0x0709
+#define CE5300_SOC_DEVICE_ID 0x0C40
+#define CE2600_SOC_DEVICE_ID 0x0931
+
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
+#define CE4200_NUM_SPI_MASTER 1
+#else
+#define CE4200_NUM_SPI_MASTER 2
+#endif
+
+#define CE4X00_SPI_MAX_SPEED  1843200
+
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+#define CE4200_NUM_CHIPSELECT 2
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
+#define CE5X00_SPI_MAX_SPEED  3500000
+#else
+#define CE5X00_SPI_MAX_SPEED  50000000
+#endif
+#else
+#define CE4200_NUM_CHIPSELECT 4
+#define CE5X00_SPI_MAX_SPEED  5000000
+#endif
+
+#define SPI_CE_DEBUG
+
+static int interface;
+
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+static int enable_msi = 1;
+#else
+static int enable_msi;
+#endif
+module_param(enable_msi, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
+struct ce4100_info {
+	struct ssp_device ssp;
+	struct platform_device *spi_pdev;
+};
+
+static DEFINE_MUTEX(ssp_lock);
+static LIST_HEAD(ssp_list);
+
+struct ssp_device *pxa_ssp_request(int port, const char *label)
+{
+	struct ssp_device *ssp = NULL;
+
+	mutex_lock(&ssp_lock);
+
+	list_for_each_entry(ssp, &ssp_list, node) {
+		if (ssp->port_id == port && ssp->use_count == 0) {
+			ssp->use_count++;
+			ssp->label = label;
+			break;
+		}
+	}
+
+	mutex_unlock(&ssp_lock);
+
+	if (&ssp->node == &ssp_list)
+		return NULL;
+
+	return ssp;
+}
+EXPORT_SYMBOL_GPL(pxa_ssp_request);
+
+void pxa_ssp_free(struct ssp_device *ssp)
+{
+	mutex_lock(&ssp_lock);
+	if (ssp->use_count) {
+		ssp->use_count--;
+		ssp->label = NULL;
+	} else
+		dev_err(&ssp->pdev->dev, "device already free\n");
+	mutex_unlock(&ssp_lock);
+}
+EXPORT_SYMBOL_GPL(pxa_ssp_free);
 
 static int ce4100_spi_probe(struct pci_dev *dev,
 		const struct pci_device_id *ent)
 {
-	struct platform_device_info pi;
 	int ret;
+	resource_size_t phys_beg;
+	resource_size_t phys_len;
+	struct ce4100_info *spi_info = NULL;
 	struct platform_device *pdev;
 	struct pxa2xx_spi_master spi_pdata;
 	struct ssp_device *ssp;
+	unsigned int id;
 
-	ret = pcim_enable_device(dev);
+	ret = pci_enable_device(dev);
 	if (ret)
 		return ret;
 
-	ret = pcim_iomap_regions(dev, 1 << 0, "PXA2xx SPI");
-	if (ret)
+	phys_beg = pci_resource_start(dev, 0);
+	phys_len = pci_resource_len(dev, 0);
+
+	if (!request_mem_region(phys_beg, phys_len,
+				"CE4100 SPI")) {
+		dev_err(&dev->dev, "Can't request register space.\n");
+		ret = -EBUSY;
 		return ret;
+	}
 
+	pdev = platform_device_alloc("pxa2xx-spi", dev->devfn);
+	if (!pdev) {
+		ret = -ENOMEM;
+		goto err_release_mem_region;
+	}
+	spi_info = kzalloc(sizeof(*spi_info), GFP_KERNEL);
+	if (!spi_info) {
+		ret = -ENOMEM;
+		goto err_platform_device_put;
+	}
 	memset(&spi_pdata, 0, sizeof(spi_pdata));
-	spi_pdata.num_chipselect = dev->devfn;
+	spi_pdata.num_chipselect = CE4200_NUM_CHIPSELECT;
+
+	ret = platform_device_add_data(pdev, &spi_pdata, sizeof(spi_pdata));
+	if (ret)
+		goto err_free_spi_info;
 
-	ssp = &spi_pdata.ssp;
+	pdev->id = interface;
+	pdev->dev.parent = &dev->dev;
+#ifdef CONFIG_OF
+	pdev->dev.of_node = dev->dev.of_node;
+#endif
+	ssp = &spi_info->ssp;
+	ssp->pcidev = dev;
 	ssp->phys_base = pci_resource_start(dev, 0);
-	ssp->mmio_base = pcim_iomap_table(dev)[0];
+	ssp->mmio_base = ioremap(phys_beg, phys_len);
 	if (!ssp->mmio_base) {
-		dev_err(&dev->dev, "failed to ioremap() registers\n");
-		return -EIO;
+		dev_err(&pdev->dev, "failed to ioremap() registers\n");
+		ret = -EIO;
+		goto err_ioremap;
+	}
+	pci_set_master(dev);
+	if (enable_msi == 1) {
+		ret = pci_enable_msi(dev);
+		if (ret) {
+			dev_err(&dev->dev, "failed to allocate MSI entry\n");
+			goto err_dev_add;
+		}
 	}
+
 	ssp->irq = dev->irq;
-	ssp->port_id = dev->devfn;
-	ssp->type = PXA25x_SSP;
+	ssp->port_id = pdev->id;
 
-	memset(&pi, 0, sizeof(pi));
-	pi.parent = &dev->dev;
-	pi.name = "pxa2xx-spi";
-	pi.id = ssp->port_id;
-	pi.data = &spi_pdata;
-	pi.size_data = sizeof(spi_pdata);
-
-	pdev = platform_device_register_full(&pi);
-	if (IS_ERR(pdev))
-		return PTR_ERR(pdev);
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	id = CE5300_SOC_DEVICE_ID;
+#else
+	intelce_get_soc_info(&id, NULL);
+#endif
+	switch (id) {
+	case CE5300_SOC_DEVICE_ID:
+		ssp->type = CE5X00_SSP;
+		break;
+	case CE4200_SOC_DEVICE_ID:
+	default:
+		ssp->type = CE4100_SSP;
+		break;
+	}
+	mutex_lock(&ssp_lock);
+	list_add(&ssp->node, &ssp_list);
+	mutex_unlock(&ssp_lock);
 
-	pci_set_drvdata(dev, pdev);
+	pci_set_drvdata(dev, spi_info);
 
-	return 0;
+	spi_info->spi_pdev = pdev;
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto err_dev_add;
+
+	interface++;
+
+	return ret;
+
+err_dev_add:
+	pci_set_drvdata(dev, NULL);
+	mutex_lock(&ssp_lock);
+	list_del(&ssp->node);
+	mutex_unlock(&ssp_lock);
+	iounmap(ssp->mmio_base);
+err_ioremap:
+
+err_free_spi_info:
+	kfree(spi_info);
+
+err_platform_device_put:
+	platform_device_put(pdev);
+
+err_release_mem_region:
+	release_mem_region(phys_beg, phys_len);
+	return ret;
 }
 
 static void ce4100_spi_remove(struct pci_dev *dev)
 {
-	struct platform_device *pdev = pci_get_drvdata(dev);
+	struct ce4100_info *spi_info;
+	struct ssp_device *ssp;
+
+	spi_info = pci_get_drvdata(dev);
+	ssp = &spi_info->ssp;
+	platform_device_unregister(spi_info->spi_pdev);
+
+	iounmap(ssp->mmio_base);
+	release_mem_region(pci_resource_start(dev, 0),
+			pci_resource_len(dev, 0));
+
+	mutex_lock(&ssp_lock);
+	list_del(&ssp->node);
+	mutex_unlock(&ssp_lock);
+
+	if (enable_msi == 1) {
+		if (pci_dev_msi_enabled(dev))
+			pci_disable_msi(dev);
+	}
 
-	platform_device_unregister(pdev);
+	pci_set_drvdata(dev, NULL);
+	pci_disable_device(dev);
+	kfree(spi_info);
 }
 
+
+#ifdef CONFIG_PM
+static int ce4XXX_spi_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	pci_save_state(dev);
+	pci_set_power_state(dev, pci_choose_state(dev, state));
+	return 0;
+}
+
+static int ce4XXX_spi_resume(struct pci_dev *dev)
+{
+	pci_set_power_state(dev, PCI_D0);
+	pci_restore_state(dev);
+
+	return 0;
+}
+#endif
+
 static DEFINE_PCI_DEVICE_TABLE(ce4100_spi_devices) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2e6a) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0935) },
 	{ },
 };
+
 MODULE_DEVICE_TABLE(pci, ce4100_spi_devices);
 
 static struct pci_driver ce4100_spi_driver = {
 	.name           = "ce4100_spi",
 	.id_table       = ce4100_spi_devices,
 	.probe          = ce4100_spi_probe,
+#ifdef CONFIG_PM
+	.suspend        = ce4XXX_spi_suspend,
+	.resume         = ce4XXX_spi_resume,
+#endif
 	.remove         = ce4100_spi_remove,
 };
  
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index 5c8c4f5..4860e85 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs
- * Copyright (C) 2013, Intel Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,24 +21,24 @@
 #include <linux/device.h>
 #include <linux/ioport.h>
 #include <linux/errno.h>
-#include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/spi/pxa2xx_spi.h>
+#include <linux/dma-mapping.h>
 #include <linux/spi/spi.h>
-#include <linux/workqueue.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 #include <linux/gpio.h>
 #include <linux/slab.h>
-#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
 #include <linux/pm_runtime.h>
-#include <linux/acpi.h>
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+#include <asm/qrk.h>
+#endif
 
-#include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/delay.h>
 
-#include "spi-pxa2xx.h"
 
 MODULE_AUTHOR("Stephen Street");
 MODULE_DESCRIPTION("PXA2xx SSP SPI Controller");
@@ -50,6 +49,15 @@
 
 #define TIMOUT_DFLT		1000
 
+#define DMA_INT_MASK		(DCSR_ENDINTR | DCSR_STARTINTR | DCSR_BUSERR)
+#define RESET_DMA_CHANNEL	(DCSR_NODESC | DMA_INT_MASK)
+#define IS_DMA_ALIGNED(x)	((((u32)(x)) & 0x07) == 0)
+#define MAX_DMA_LEN		8191
+#define DMA_ALIGNMENT		8
+
+#define CE5X00_FIFO_DEPTH    32
+#define CE4X00_FIFO_DEPTH    4
+
 /*
  * for testing SSCR1 changes that require SSP restart, basically
  * everything except the service and interrupt enables, the pxa270 developer
@@ -58,115 +66,232 @@
  * service and interrupt enables
  */
 #define SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \
-				| SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \
-				| SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \
-				| SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR \
-				| SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS \
-				| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
-
-#define LPSS_RX_THRESH_DFLT	64
-#define LPSS_TX_LOTHRESH_DFLT	160
-#define LPSS_TX_HITHRESH_DFLT	224
-
-/* Offset from drv_data->lpss_base */
-#define SSP_REG			0x0c
-#define SPI_CS_CONTROL		0x18
-#define SPI_CS_CONTROL_SW_MODE	BIT(0)
-#define SPI_CS_CONTROL_CS_HIGH	BIT(1)
-
-static bool is_lpss_ssp(const struct driver_data *drv_data)
-{
-	return drv_data->ssp_type == LPSS_SSP;
-}
-
-/*
- * Read and write LPSS SSP private registers. Caller must first check that
- * is_lpss_ssp() returns true before these can be called.
- */
-static u32 __lpss_ssp_read_priv(struct driver_data *drv_data, unsigned offset)
-{
-	WARN_ON(!drv_data->lpss_base);
-	return readl(drv_data->lpss_base + offset);
-}
-
-static void __lpss_ssp_write_priv(struct driver_data *drv_data,
-				  unsigned offset, u32 value)
-{
-	WARN_ON(!drv_data->lpss_base);
-	writel(value, drv_data->lpss_base + offset);
-}
-
-/*
- * lpss_ssp_setup - perform LPSS SSP specific setup
- * @drv_data: pointer to the driver private data
- *
- * Perform LPSS SSP specific setup. This function must be called first if
- * one is going to use LPSS SSP private registers.
- */
-static void lpss_ssp_setup(struct driver_data *drv_data)
-{
-	unsigned offset = 0x400;
-	u32 value, orig;
-
-	if (!is_lpss_ssp(drv_data))
-		return;
-
-	/*
-	 * Perform auto-detection of the LPSS SSP private registers. They
-	 * can be either at 1k or 2k offset from the base address.
-	 */
-	orig = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
+			   | SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR	\
+			   | SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL	\
+			   | SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR	\
+			   | SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS		\
+			   | SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
+
+#define CE5X00_SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR	\
+				  | SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \
+				  | SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \
+				  | SSCR1_IFS | CE5X00_SSCR1_STRF	\
+				  | CE5X00_SSCR1_EFWR			\
+				  | CE5X00_SSCR1_RFT | CE5X00_SSCR1_TFT \
+				  | SSCR1_MWDS				\
+				  | SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
+
+
+#define DEFINE_SSP_REG(reg, off)				\
+	static inline u32 read_##reg(void const __iomem *p)	\
+	{ return __raw_readl(p + (off)); }			\
+								\
+	static inline void write_##reg(u32 v, void __iomem *p)	\
+	{ __raw_writel(v, p + (off)); }
+
+DEFINE_SSP_REG(sscr0, 0x00)
+DEFINE_SSP_REG(sscr1, 0x04)
+DEFINE_SSP_REG(sssr, 0x08)
+DEFINE_SSP_REG(ssitr, 0x0c)
+DEFINE_SSP_REG(ssdr, 0x10)
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+DEFINE_SSP_REG(dds_rate, 0x28) /* SSTO unused for qrk */
+#endif
+DEFINE_SSP_REG(ssto, 0x28)
+DEFINE_SSP_REG(sspsp, 0x2c)
 
-	value = orig | SPI_CS_CONTROL_SW_MODE;
-	writel(value, drv_data->ioaddr + offset + SPI_CS_CONTROL);
-	value = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
-	if (value != (orig | SPI_CS_CONTROL_SW_MODE)) {
-		offset = 0x800;
-		goto detection_done;
-	}
+#define START_STATE ((void *)0)
+#define RUNNING_STATE ((void *)1)
+#define DONE_STATE ((void *)2)
+#define ERROR_STATE ((void *)-1)
+
+#define QUEUE_RUNNING 0
+#define QUEUE_STOPPED 1
+
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+#define DDS_MAX     0x800000
+#define DDS_666666  0x666666
+#define DDS_400000  0x400000
+#define DDS_200000  0x200000
+#define DDS_100000  0x100000
+#define DDS_80000   0x80000
+#define DDS_40000   0x40000
+#define DDS_20000   0x20000
+#define DDS_10000   0x10000
+#define DDS_8000    0x8000
+
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU)
+/* these values are different on emulations where system clock is 14mhz */
+#define FSYS              14 /* mhz */
+#define BITRATE_50MHZ     3500000
+#define BITRATE_40MHZ     2800000
+#define BITRATE_25MHZ     1750000
+#define BITRATE_20MHZ     1400000
+#define BITRATE_16667KHZ  1167000
+#define BITRATE_13333KHZ  933000
+#define BITRATE_12500KHZ  875000
+#define BITRATE_10MHZ     700000
+#define BITRATE_8MHZ      560000
+#define BITRATE_6250KHZ   438000
+#define BITRATE_5MHZ      350000
+#define BITRATE_4MHZ      280000
+#define BITRATE_3125KHZ   219000
+#define BITRATE_2500KHZ   175000
+#define BITRATE_2MHZ      140000
+#define BITRATE_1563KHZ   109000
+#define BITRATE_1250KHZ   88000
+#define BITRATE_1MHZ      70000
+#define BITRATE_800KHZ    56000
+#define BITRATE_781KHZ    54688
+#define BITRATE_625KHZ    43750
+#define BITRATE_500KHZ    35000
+#define BITRATE_400KHZ    28000
+#define BITRATE_390KHZ	  27344
+#define BITRATE_250KHZ	  17500
+#define BITRATE_200KHZ	  14000
+#define BITRATE_195KHZ    13672
+#define BITRATE_125KHZ    8750
+#define BITRATE_100KHZ    7000
+#define BITRATE_50KHZ     3500
+#define BITRATE_25KHZ     1750
+#define BITRATE_10KHZ     701
+#define BITRATE_5KHZ      353
+#define BITRATE_1KHZ      70
+#define BITRATE_MAX       BITRATE_50MHZ
+#define BITRATE_MIN       BITRATE_1KHZ
 
-	value &= ~SPI_CS_CONTROL_SW_MODE;
-	writel(value, drv_data->ioaddr + offset + SPI_CS_CONTROL);
-	value = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
-	if (value != orig) {
-		offset = 0x800;
-		goto detection_done;
-	}
+#else
 
-detection_done:
-	/* Now set the LPSS base */
-	drv_data->lpss_base = drv_data->ioaddr + offset;
+#define BITRATE_50MHZ     50000000
+#define BITRATE_40MHZ     40000000
+#define BITRATE_25MHZ     25000000
+#define BITRATE_20MHZ     20000000
+#define BITRATE_16667KHZ  16667000
+#define BITRATE_13333KHZ  13333000
+#define BITRATE_12500KHZ  12500000
+#define BITRATE_10MHZ     10000000
+#define BITRATE_8MHZ      8000000
+#define BITRATE_6250KHZ   6250000
+#define BITRATE_5MHZ      5000000
+#define BITRATE_4MHZ      4000000
+#define BITRATE_3125KHZ   3125000
+#define BITRATE_2500KHZ   2500000
+#define BITRATE_2MHZ      2000000
+#define BITRATE_1563KHZ   1563000
+#define BITRATE_1250KHZ   1250000
+#define BITRATE_1MHZ      1000000
+#define BITRATE_800KHZ    800000
+#define BITRATE_781KHZ    781250
+#define BITRATE_625KHZ    625000
+#define BITRATE_500KHZ    500000
+#define BITRATE_400KHZ    400000
+#define BITRATE_390KHZ    390625
+#define BITRATE_250KHZ    250000
+#define BITRATE_200KHZ    200000
+#define BITRATE_195KHZ    195313
+#define BITRATE_125KHZ    125000
+#define BITRATE_100KHZ    100000
+#define BITRATE_50KHZ     50000
+#define BITRATE_25KHZ     25000
+#define BITRATE_10KHZ     10016
+#define BITRATE_5KHZ      5040
+#define BITRATE_1KHZ      1000
+#define BITRATE_MIN       BITRATE_1KHZ
+#define BITRATE_MAX       BITRATE_50MHZ
+#define FSYS              200 /* mhz */
+
+#endif /* #if defined(CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU) */
+
+#endif /* CONFIG_INTEL_QUARK_X1000_SOC */
+
+struct driver_data {
+	/* Driver model hookup */
+	struct platform_device *pdev;
 
-	/* Enable software chip select control */
-	value = SPI_CS_CONTROL_SW_MODE | SPI_CS_CONTROL_CS_HIGH;
-	__lpss_ssp_write_priv(drv_data, SPI_CS_CONTROL, value);
+	/* SSP Info */
+	struct ssp_device *ssp;
 
-	/* Enable multiblock DMA transfers */
-	if (drv_data->master_info->enable_dma)
-		__lpss_ssp_write_priv(drv_data, SSP_REG, 1);
-}
+	/* SPI framework hookup */
+	enum pxa_ssp_type ssp_type;
+	struct spi_master *master;
 
-static void lpss_ssp_cs_control(struct driver_data *drv_data, bool enable)
-{
-	u32 value;
+	/* PXA hookup */
+	struct pxa2xx_spi_master *master_info;
 
-	if (!is_lpss_ssp(drv_data))
-		return;
+	/* DMA setup stuff */
+	int rx_channel;
+	int tx_channel;
+	u32 *null_dma_buf;
+
+	/* SSP register addresses */
+	void __iomem *ioaddr;
+	u32 ssdr_physical;
+
+	/* SSP masks*/
+	u32 dma_cr1;
+	u32 int_cr1;
+	u32 clear_sr;
+	u32 mask_sr;
+
+	/* Message per-transfer pump */
+	struct tasklet_struct pump_transfers;
+
+	/* Current message transfer state info */
+	struct spi_message *cur_msg;
+	struct spi_transfer *cur_transfer;
+	struct chip_data *cur_chip;
+	size_t len;
+	void *tx;
+	void *tx_end;
+	void *rx;
+	void *rx_end;
+	int dma_mapped;
+	dma_addr_t rx_dma;
+	dma_addr_t tx_dma;
+	size_t rx_map_len;
+	size_t tx_map_len;
+	u8 n_bytes;
+	u32 dma_width;
+	int (*write)(struct driver_data *drv_data);
+	int (*read)(struct driver_data *drv_data);
+	irqreturn_t (*transfer_handler)(struct driver_data *drv_data);
+	void (*cs_control)(u32 command);
+};
 
-	value = __lpss_ssp_read_priv(drv_data, SPI_CS_CONTROL);
-	if (enable)
-		value &= ~SPI_CS_CONTROL_CS_HIGH;
-	else
-		value |= SPI_CS_CONTROL_CS_HIGH;
-	__lpss_ssp_write_priv(drv_data, SPI_CS_CONTROL, value);
-}
+struct chip_data {
+	u32 cr0;
+	u32 cr1;
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	u32 dds_rate;
+#endif
+	u32 psp;
+	u32 timeout;
+	u8 n_bytes;
+	u32 dma_width;
+	u32 dma_burst_size;
+	u32 threshold;
+	u32 dma_threshold;
+	u8 enable_dma;
+	u8 bits_per_word;
+	u32 speed_hz;
+	union {
+		int gpio_cs;
+		unsigned int frm;
+	};
+	int gpio_cs_inverted;
+	int (*write)(struct driver_data *drv_data);
+	int (*read)(struct driver_data *drv_data);
+	void (*cs_control)(u32 command);
+};
 
 static void cs_assert(struct driver_data *drv_data)
 {
 	struct chip_data *chip = drv_data->cur_chip;
 
-	if (drv_data->ssp_type == CE4100_SSP) {
-		write_SSSR(drv_data->cur_chip->frm, drv_data->ioaddr);
+	if (drv_data->ssp_type == CE4100_SSP ||
+	    (drv_data->ssp_type == CE5X00_SSP &&
+	     (!gpio_is_valid(chip->gpio_cs)))) {
+		write_sssr(drv_data->cur_chip->frm, drv_data->ioaddr);
 		return;
 	}
 
@@ -175,60 +300,99 @@
 		return;
 	}
 
-	if (gpio_is_valid(chip->gpio_cs)) {
+	if (gpio_is_valid(chip->gpio_cs))
 		gpio_set_value(chip->gpio_cs, chip->gpio_cs_inverted);
-		return;
-	}
-
-	lpss_ssp_cs_control(drv_data, true);
 }
 
 static void cs_deassert(struct driver_data *drv_data)
 {
 	struct chip_data *chip = drv_data->cur_chip;
 
-	if (drv_data->ssp_type == CE4100_SSP)
+	if (drv_data->ssp_type == CE4100_SSP ||
+	    (drv_data->ssp_type == CE5X00_SSP
+	     && (!gpio_is_valid(chip->gpio_cs)))) {
 		return;
-
+	}
 	if (chip->cs_control) {
 		chip->cs_control(PXA2XX_CS_DEASSERT);
 		return;
 	}
 
-	if (gpio_is_valid(chip->gpio_cs)) {
+	if (gpio_is_valid(chip->gpio_cs))
 		gpio_set_value(chip->gpio_cs, !chip->gpio_cs_inverted);
-		return;
-	}
+}
+
+static void write_sssr_cs(struct driver_data *drv_data, u32 val)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	if (drv_data->ssp_type == CE4100_SSP
+	    || drv_data->ssp_type == CE5X00_SSP)
+		val |= read_sssr(reg) & SSSR_ALT_FRM_MASK;
+
+	write_sssr(val, reg);
+}
 
-	lpss_ssp_cs_control(drv_data, false);
+static int pxa25x_ssp_comp(struct driver_data *drv_data)
+{
+	if (drv_data->ssp_type == PXA25x_SSP)
+		return 1;
+	if (drv_data->ssp_type == CE4100_SSP)
+		return 1;
+#ifdef CONFIG_GEN3_SPI
+	if (drv_data->ssp_type == CE5X00_SSP)
+		return 2;
+#endif
+	return 0;
 }
 
-int pxa2xx_spi_flush(struct driver_data *drv_data)
+static int flush(struct driver_data *drv_data)
 {
 	unsigned long limit = loops_per_jiffy << 1;
 
 	void __iomem *reg = drv_data->ioaddr;
 
 	do {
-		while (read_SSSR(reg) & SSSR_RNE) {
-			read_SSDR(reg);
-		}
-	} while ((read_SSSR(reg) & SSSR_BSY) && --limit);
-	write_SSSR_CS(drv_data, SSSR_ROR);
+		while (read_sssr(reg) & SSSR_RNE)
+			read_ssdr(reg);
+	} while ((read_sssr(reg) & SSSR_BSY) && --limit);
+	write_sssr_cs(drv_data, SSSR_ROR);
 
 	return limit;
 }
 
+#ifdef CONFIG_GEN3_SPI
+static void wait_till_not_busy(struct driver_data *drv_data)
+{
+	/*
+	 * Most cases, the BSY bit will be cleared in very short time.
+	 * But if the controller is set to the slowest speed, the BSY
+	 * bit waitting time will increase a lot.
+	 * Here, we set the wait time to 100ms is to deal with such corner case,
+	 * but in real world, there is almost no one will use the slowest
+	 * speed to transfer data, which means there is no need to add more
+	 * complex code to to deal with the slowest speed case.
+	 */
+	unsigned long end = jiffies + 1 + usecs_to_jiffies(100000);
+	void __iomem *reg = drv_data->ioaddr;
+	while (time_before(jiffies, end)) {
+		if (!(read_sssr(reg) & SSSR_BSY))
+			return;
+	}
+	pr_err("SPI MASTER keeps busy for 100ms after a read/write!\n");
+}
+#endif
+
 static int null_writer(struct driver_data *drv_data)
 {
 	void __iomem *reg = drv_data->ioaddr;
 	u8 n_bytes = drv_data->n_bytes;
 
-	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
-		|| (drv_data->tx == drv_data->tx_end))
+	if ((!(read_sssr(reg) & SSSR_TNF))
+	    || (drv_data->tx == drv_data->tx_end))
 		return 0;
 
-	write_SSDR(0, reg);
+	write_ssdr(0, reg);
 	drv_data->tx += n_bytes;
 
 	return 1;
@@ -239,9 +403,9 @@
 	void __iomem *reg = drv_data->ioaddr;
 	u8 n_bytes = drv_data->n_bytes;
 
-	while ((read_SSSR(reg) & SSSR_RNE)
+	while ((read_sssr(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
-		read_SSDR(reg);
+		read_ssdr(reg);
 		drv_data->rx += n_bytes;
 	}
 
@@ -252,11 +416,11 @@
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
-		|| (drv_data->tx == drv_data->tx_end))
+	if ((!(read_sssr(reg) & SSSR_TNF))
+	    || (drv_data->tx == drv_data->tx_end))
 		return 0;
 
-	write_SSDR(*(u8 *)(drv_data->tx), reg);
+	write_ssdr(*(u8 *)(drv_data->tx), reg);
 	++drv_data->tx;
 
 	return 1;
@@ -266,9 +430,9 @@
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	while ((read_SSSR(reg) & SSSR_RNE)
-		&& (drv_data->rx < drv_data->rx_end)) {
-		*(u8 *)(drv_data->rx) = read_SSDR(reg);
+	while ((read_sssr(reg) & SSSR_RNE)
+	       && (drv_data->rx < drv_data->rx_end)) {
+		*(u8 *)(drv_data->rx) = read_ssdr(reg);
 		++drv_data->rx;
 	}
 
@@ -279,11 +443,11 @@
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
-		|| (drv_data->tx == drv_data->tx_end))
+	if ((!(read_sssr(reg) & SSSR_TNF))
+	    || (drv_data->tx == drv_data->tx_end))
 		return 0;
 
-	write_SSDR(*(u16 *)(drv_data->tx), reg);
+	write_ssdr(*(u16 *)(drv_data->tx), reg);
 	drv_data->tx += 2;
 
 	return 1;
@@ -293,9 +457,9 @@
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	while ((read_SSSR(reg) & SSSR_RNE)
-		&& (drv_data->rx < drv_data->rx_end)) {
-		*(u16 *)(drv_data->rx) = read_SSDR(reg);
+	while ((read_sssr(reg) & SSSR_RNE)
+	       && (drv_data->rx < drv_data->rx_end)) {
+		*(u16 *)(drv_data->rx) = read_ssdr(reg);
 		drv_data->rx += 2;
 	}
 
@@ -306,11 +470,11 @@
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
-		|| (drv_data->tx == drv_data->tx_end))
+	if ((!(read_sssr(reg) & SSSR_TNF))
+	    || (drv_data->tx == drv_data->tx_end))
 		return 0;
 
-	write_SSDR(*(u32 *)(drv_data->tx), reg);
+	write_ssdr(*(u32 *)(drv_data->tx), reg);
 	drv_data->tx += 4;
 
 	return 1;
@@ -320,16 +484,16 @@
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	while ((read_SSSR(reg) & SSSR_RNE)
-		&& (drv_data->rx < drv_data->rx_end)) {
-		*(u32 *)(drv_data->rx) = read_SSDR(reg);
+	while ((read_sssr(reg) & SSSR_RNE)
+	       && (drv_data->rx < drv_data->rx_end)) {
+		*(u32 *)(drv_data->rx) = read_ssdr(reg);
 		drv_data->rx += 4;
 	}
 
 	return drv_data->rx == drv_data->rx_end;
 }
 
-void *pxa2xx_spi_next_transfer(struct driver_data *drv_data)
+static void *next_transfer(struct driver_data *drv_data)
 {
 	struct spi_message *msg = drv_data->cur_msg;
 	struct spi_transfer *trans = drv_data->cur_transfer;
@@ -345,19 +509,84 @@
 		return DONE_STATE;
 }
 
+static int map_dma_buffers(struct driver_data *drv_data)
+{
+	struct spi_message *msg = drv_data->cur_msg;
+	struct device *dev = &msg->spi->dev;
+
+	if (!drv_data->cur_chip->enable_dma)
+		return 0;
+
+	if (msg->is_dma_mapped)
+		return  drv_data->rx_dma && drv_data->tx_dma;
+
+	if (!IS_DMA_ALIGNED(drv_data->rx) || !IS_DMA_ALIGNED(drv_data->tx))
+		return 0;
+
+	/* Modify setup if rx buffer is null */
+	if (drv_data->rx == NULL) {
+		*drv_data->null_dma_buf = 0;
+		drv_data->rx = drv_data->null_dma_buf;
+		drv_data->rx_map_len = 4;
+	} else
+		drv_data->rx_map_len = drv_data->len;
+
+
+	/* Modify setup if tx buffer is null */
+	if (drv_data->tx == NULL) {
+		*drv_data->null_dma_buf = 0;
+		drv_data->tx = drv_data->null_dma_buf;
+		drv_data->tx_map_len = 4;
+	} else
+		drv_data->tx_map_len = drv_data->len;
+
+	/* Stream map the tx buffer. Always do DMA_TO_DEVICE first
+	 * so we flush the cache *before* invalidating it, in case
+	 * the tx and rx buffers overlap.
+	 */
+	drv_data->tx_dma = dma_map_single(dev, drv_data->tx,
+					drv_data->tx_map_len, DMA_TO_DEVICE);
+	if (dma_mapping_error(dev, drv_data->tx_dma))
+		return 0;
+
+	/* Stream map the rx buffer */
+	drv_data->rx_dma = dma_map_single(dev, drv_data->rx,
+					drv_data->rx_map_len, DMA_FROM_DEVICE);
+	if (dma_mapping_error(dev, drv_data->rx_dma)) {
+		dma_unmap_single(dev, drv_data->tx_dma,
+					drv_data->tx_map_len, DMA_TO_DEVICE);
+		return 0;
+	}
+
+	return 1;
+}
+
+static void unmap_dma_buffers(struct driver_data *drv_data)
+{
+	struct device *dev;
+
+	if (!drv_data->dma_mapped)
+		return;
+
+	if (!drv_data->cur_msg->is_dma_mapped) {
+		dev = &drv_data->cur_msg->spi->dev;
+		dma_unmap_single(dev, drv_data->rx_dma,
+					drv_data->rx_map_len, DMA_FROM_DEVICE);
+		dma_unmap_single(dev, drv_data->tx_dma,
+					drv_data->tx_map_len, DMA_TO_DEVICE);
+	}
+
+	drv_data->dma_mapped = 0;
+}
+
 /* caller already set message->status; dma and pio irqs are blocked */
 static void giveback(struct driver_data *drv_data)
 {
-	struct spi_transfer* last_transfer;
-	struct spi_message *msg;
-
-	msg = drv_data->cur_msg;
-	drv_data->cur_msg = NULL;
-	drv_data->cur_transfer = NULL;
+	struct spi_transfer *last_transfer;
 
-	last_transfer = list_entry(msg->transfers.prev,
-					struct spi_transfer,
-					transfer_list);
+	last_transfer = list_entry(drv_data->cur_msg->transfers.prev,
+				   struct spi_transfer,
+				   transfer_list);
 
 	/* Delay if requested before any change in chip select */
 	if (last_transfer->delay_usecs)
@@ -376,25 +605,181 @@
 		 * time with the following tests unless this was hinted.
 		 *
 		 * We cannot postpone this until pump_messages, because
-		 * after calling msg->complete (below) the driver that
-		 * sent the current message could be unloaded, which
-		 * could invalidate the cs_control() callback...
+		 * after calling spi_finalize_current_message (below) the
+		 * driver that sent the current message could be unloaded,
+		 * which could invalidate the cs_control() callback...
 		 */
-
 		/* get a pointer to the next message, if any */
 		next_msg = spi_get_next_queued_message(drv_data->master);
 
 		/* see if the next and current messages point
 		 * to the same chip
 		 */
-		if (next_msg && next_msg->spi != msg->spi)
+		if (next_msg && next_msg->spi != drv_data->cur_msg->spi)
 			next_msg = NULL;
-		if (!next_msg || msg->state == ERROR_STATE)
+		if (!next_msg || drv_data->cur_msg->state == ERROR_STATE)
 			cs_deassert(drv_data);
 	}
 
-	spi_finalize_current_message(drv_data->master);
+	drv_data->cur_msg = NULL;
+	drv_data->cur_transfer = NULL;
 	drv_data->cur_chip = NULL;
+	spi_finalize_current_message(drv_data->master);
+}
+
+static int wait_ssp_rx_stall(void const __iomem *ioaddr)
+{
+	unsigned long limit = loops_per_jiffy << 1;
+
+	while ((read_sssr(ioaddr) & SSSR_BSY) && --limit)
+		cpu_relax();
+
+	return limit;
+}
+
+static int wait_dma_channel_stop(int channel)
+{
+	unsigned long limit = loops_per_jiffy << 1;
+
+	while (!(DCSR(channel) & DCSR_STOPSTATE) && --limit)
+		cpu_relax();
+
+	return limit;
+}
+
+static void dma_error_stop(struct driver_data *drv_data, const char *msg)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	/* Stop and reset */
+	DCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;
+	DCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;
+	write_sssr_cs(drv_data, drv_data->clear_sr);
+	write_sscr1(read_sscr1(reg) & ~drv_data->dma_cr1, reg);
+	if (!pxa25x_ssp_comp(drv_data))
+		write_ssto(0, reg);
+	flush(drv_data);
+	write_sscr0(read_sscr0(reg) & ~SSCR0_SSE, reg);
+
+	unmap_dma_buffers(drv_data);
+
+	dev_err(&drv_data->pdev->dev, "%s\n", msg);
+
+	drv_data->cur_msg->state = ERROR_STATE;
+	tasklet_schedule(&drv_data->pump_transfers);
+}
+
+static void dma_transfer_complete(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+	struct spi_message *msg = drv_data->cur_msg;
+
+	/* Clear and disable interrupts on SSP and DMA channels*/
+	write_sscr1(read_sscr1(reg) & ~drv_data->dma_cr1, reg);
+	write_sssr_cs(drv_data, drv_data->clear_sr);
+	DCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;
+	DCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;
+
+	if (wait_dma_channel_stop(drv_data->rx_channel) == 0)
+		dev_err(&drv_data->pdev->dev,
+			"dma_handler: dma rx channel stop failed\n");
+
+	if (wait_ssp_rx_stall(drv_data->ioaddr) == 0)
+		dev_err(&drv_data->pdev->dev,
+			"dma_transfer: ssp rx stall failed\n");
+
+	unmap_dma_buffers(drv_data);
+
+	/* update the buffer pointer for the amount completed in dma */
+	drv_data->rx += drv_data->len -
+			(DCMD(drv_data->rx_channel) & DCMD_LENGTH);
+
+	/* read trailing data from fifo, it does not matter how many
+	 * bytes are in the fifo just read until buffer is full
+	 * or fifo is empty, which ever occurs first */
+	drv_data->read(drv_data);
+
+	/* return count of what was actually read */
+	msg->actual_length += drv_data->len -
+				(drv_data->rx_end - drv_data->rx);
+
+	/* Transfer delays and chip select release are
+	 * handled in pump_transfers or giveback
+	 */
+
+	/* Move to next transfer */
+	msg->state = next_transfer(drv_data);
+
+	/* Schedule transfer tasklet */
+	tasklet_schedule(&drv_data->pump_transfers);
+}
+
+static void dma_handler(int channel, void *data)
+{
+	struct driver_data *drv_data = data;
+	u32 irq_status = DCSR(channel) & DMA_INT_MASK;
+
+	if (irq_status & DCSR_BUSERR) {
+
+		if (channel == drv_data->tx_channel)
+			dma_error_stop(drv_data,
+					"dma_handler: "
+					"bad bus address on tx channel");
+		else
+			dma_error_stop(drv_data,
+					"dma_handler: "
+					"bad bus address on rx channel");
+		return;
+	}
+
+	/* PXA255x_SSP has no timeout interrupt, wait for tailing bytes */
+	if ((channel == drv_data->tx_channel)
+		&& (irq_status & DCSR_ENDINTR)
+		&& (drv_data->ssp_type == PXA25x_SSP)) {
+
+		/* Wait for rx to stall */
+		if (wait_ssp_rx_stall(drv_data->ioaddr) == 0)
+			dev_err(&drv_data->pdev->dev,
+				"dma_handler: ssp rx stall failed\n");
+
+		/* finish this transfer, start the next */
+		dma_transfer_complete(drv_data);
+	}
+}
+
+static irqreturn_t dma_transfer(struct driver_data *drv_data)
+{
+	u32 irq_status;
+	void __iomem *reg = drv_data->ioaddr;
+
+	irq_status = read_sssr(reg) & drv_data->mask_sr;
+	if (irq_status & SSSR_ROR) {
+		dma_error_stop(drv_data, "dma_transfer: fifo overrun");
+		return IRQ_HANDLED;
+	}
+
+	/* Check for false positive timeout */
+	if ((irq_status & SSSR_TINT)
+		&& (DCSR(drv_data->tx_channel) & DCSR_RUN)) {
+		write_sssr(SSSR_TINT, reg);
+		return IRQ_HANDLED;
+	}
+
+	if (irq_status & SSSR_TINT || drv_data->rx == drv_data->rx_end) {
+
+		/* Clear and disable timeout interrupt, do the rest in
+		 * dma_transfer_complete */
+		if (!pxa25x_ssp_comp(drv_data))
+			write_ssto(0, reg);
+
+		/* finish this transfer, start the next */
+		dma_transfer_complete(drv_data);
+
+		return IRQ_HANDLED;
+	}
+
+	/* Opps problem detected */
+	return IRQ_NONE;
 }
 
 static void reset_sccr1(struct driver_data *drv_data)
@@ -403,23 +788,26 @@
 	struct chip_data *chip = drv_data->cur_chip;
 	u32 sccr1_reg;
 
-	sccr1_reg = read_SSCR1(reg) & ~drv_data->int_cr1;
-	sccr1_reg &= ~SSCR1_RFT;
+	sccr1_reg = read_sscr1(reg) & ~drv_data->int_cr1;
+	if (drv_data->ssp_type == CE5X00_SSP)
+		sccr1_reg &= ~CE5X00_SSCR1_RFT;
+	else
+		sccr1_reg &= ~SSCR1_RFT;
 	sccr1_reg |= chip->threshold;
-	write_SSCR1(sccr1_reg, reg);
+	write_sscr1(sccr1_reg, reg);
 }
 
-static void int_error_stop(struct driver_data *drv_data, const char* msg)
+static void int_error_stop(struct driver_data *drv_data, const char *msg)
 {
 	void __iomem *reg = drv_data->ioaddr;
 
 	/* Stop and reset SSP */
-	write_SSSR_CS(drv_data, drv_data->clear_sr);
+	write_sssr_cs(drv_data, drv_data->clear_sr);
 	reset_sccr1(drv_data);
 	if (!pxa25x_ssp_comp(drv_data))
-		write_SSTO(0, reg);
-	pxa2xx_spi_flush(drv_data);
-	write_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);
+		write_ssto(0, reg);
+	flush(drv_data);
+	write_sscr0(read_sscr0(reg) & ~SSCR0_SSE, reg);
 
 	dev_err(&drv_data->pdev->dev, "%s\n", msg);
 
@@ -432,10 +820,10 @@
 	void __iomem *reg = drv_data->ioaddr;
 
 	/* Stop SSP */
-	write_SSSR_CS(drv_data, drv_data->clear_sr);
+	write_sssr_cs(drv_data, drv_data->clear_sr);
 	reset_sccr1(drv_data);
 	if (!pxa25x_ssp_comp(drv_data))
-		write_SSTO(0, reg);
+		write_ssto(0, reg);
 
 	/* Update total byte transferred return count actual bytes read */
 	drv_data->cur_msg->actual_length += drv_data->len -
@@ -446,20 +834,22 @@
 	 */
 
 	/* Move to next transfer */
-	drv_data->cur_msg->state = pxa2xx_spi_next_transfer(drv_data);
+	drv_data->cur_msg->state = next_transfer(drv_data);
 
 	/* Schedule transfer tasklet */
 	tasklet_schedule(&drv_data->pump_transfers);
 }
 
+#ifndef CONFIG_GEN3_SPI
+
 static irqreturn_t interrupt_transfer(struct driver_data *drv_data)
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	u32 irq_mask = (read_SSCR1(reg) & SSCR1_TIE) ?
+	u32 irq_mask = (read_sscr1(reg) & SSCR1_TIE) ?
 			drv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;
 
-	u32 irq_status = read_SSSR(reg) & irq_mask;
+	u32 irq_status = read_sssr(reg) & irq_mask;
 
 	if (irq_status & SSSR_ROR) {
 		int_error_stop(drv_data, "interrupt_transfer: fifo overrun");
@@ -467,7 +857,7 @@
 	}
 
 	if (irq_status & SSSR_TINT) {
-		write_SSSR(SSSR_TINT, reg);
+		write_sssr_cs(drv_data, SSSR_TINT);
 		if (drv_data->read(drv_data)) {
 			int_transfer_complete(drv_data);
 			return IRQ_HANDLED;
@@ -488,10 +878,12 @@
 	}
 
 	if (drv_data->tx == drv_data->tx_end) {
-		u32 bytes_left;
+#ifndef CONFIG_GEN3_SPI
+		u32 bytes_left = 0;
+#endif
 		u32 sccr1_reg;
 
-		sccr1_reg = read_SSCR1(reg);
+		sccr1_reg = read_sscr1(reg);
 		sccr1_reg &= ~SSCR1_TIE;
 
 		/*
@@ -499,13 +891,13 @@
 		 * remaining RX bytes.
 		 */
 		if (pxa25x_ssp_comp(drv_data)) {
-
+#ifndef CONFIG_GEN3_SPI
 			sccr1_reg &= ~SSCR1_RFT;
 
 			bytes_left = drv_data->rx_end - drv_data->rx;
 			switch (drv_data->n_bytes) {
 			case 4:
-				bytes_left >>= 1;
+				bytes_left >>= 2;
 			case 2:
 				bytes_left >>= 1;
 			}
@@ -514,33 +906,198 @@
 				bytes_left = RX_THRESH_DFLT;
 
 			sccr1_reg |= SSCR1_RxTresh(bytes_left);
+#endif
+		}
+		write_sscr1(sccr1_reg, reg);
+#ifdef CONFIG_GEN3_SPI
+		if (!wait_ssp_rx_stall(reg)) {
+			int_error_stop(drv_data,
+				       "interrupt_transfer: rx stall failed");
+			return IRQ_HANDLED;
+		}
+
+		if (!drv_data->read(drv_data)) {
+			int_error_stop(drv_data,
+				       "interrupt_transfer: "
+				       "trailing byte read failed");
+			return IRQ_HANDLED;
 		}
-		write_SSCR1(sccr1_reg, reg);
+
+		int_transfer_complete(drv_data);
+#endif
+
 	}
 
 	/* We did something */
 	return IRQ_HANDLED;
 }
+#else
+#ifdef WANT_TO_USE_THIS
+static int is_txfifo_empty(struct driver_data *drv_data, u32 tfl_mask)
+{
+	void __iomem *reg = drv_data->ioaddr;
+	u32 sssr = read_sssr(reg);
+	u32 tx_fifo_entry = 0;
+	tx_fifo_entry = (sssr & tfl_mask)>>8;
+	if ((sssr & SSSR_TNF) && (!tx_fifo_entry))
+		return 1;
+	return 0;
+}
+#endif
 
-static irqreturn_t ssp_int(int irq, void *dev_id)
+static void pxa2xx_update_tx_threshold(struct driver_data *drv_data,
+				       u32 threshold)
 {
-	struct driver_data *drv_data = dev_id;
 	void __iomem *reg = drv_data->ioaddr;
-	u32 sccr1_reg;
-	u32 mask = drv_data->mask_sr;
-	u32 status;
+	u32 sscr1_reg = 0;
+	sscr1_reg = read_sscr1(reg);
+	sscr1_reg |= SSCR1_TIE;
+	if (drv_data->ssp_type == CE5X00_SSP) {
+		sscr1_reg &= ~CE5X00_SSCR1_TFT;
+		sscr1_reg |= CE5X00_SSCR1_TxTresh(threshold);
+	} else {
+		sscr1_reg &= ~SSCR1_TFT;
+		sscr1_reg |= SSCR1_TxTresh(threshold);
+	}
+
+	write_sscr1(sscr1_reg, reg);
+}
+
+static void pxa2xx_mask_intr(void __iomem *reg, u32 intr)
+{
+	u32 mask;
+	mask = read_sscr1(reg) & ~intr;
+	write_sscr1(mask, reg);
+}
 
+static void pxa2xx_unmask_intr(void __iomem *reg, u32 intr)
+{
+	u32 mask;
+	mask = read_sscr1(reg) | intr;
+	write_sscr1(mask, reg);
+}
+
+static irqreturn_t interrupt_transfer(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	u32 tx_count;
+	u32 irq_mask = (read_sscr1(reg) & SSCR1_TIE) ?
+			drv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;
+
+	int left;
+
+	u32 tmp_sssr = read_sssr(reg);
+	u32 irq_status = tmp_sssr & irq_mask;
 	/*
-	 * The IRQ might be shared with other peripherals so we must first
-	 * check that are we RPM suspended or not. If we are we assume that
-	 * the IRQ was not for us (we shouldn't be RPM suspended when the
-	 * interrupt is enabled).
+	 * Transmit FIFO Level Depth/MASK/Default value
 	 */
-	if (pm_runtime_suspended(&drv_data->pdev->dev))
+	u32 fifo_depth, sssr_tfl_mask, sscr1_tft_mask, tfl_default;
+
+	/*
+	 * Check whether the irq is valid spi interrupt
+	 */
+	if (!(tmp_sssr & (SSSR_TFS | SSSR_RFS | SSSR_ROR)))
 		return IRQ_NONE;
 
-	sccr1_reg = read_SSCR1(reg);
-	status = read_SSSR(reg);
+	switch (drv_data->ssp_type) {
+	case CE4100_SSP:
+		fifo_depth = CE4X00_FIFO_DEPTH;
+		sssr_tfl_mask = SSSR_TFL_MASK;
+		sscr1_tft_mask = SSCR1_TFT;
+		tfl_default = TX_THRESH_DFLT;
+		break;
+	case CE5X00_SSP:
+		fifo_depth  = CE5X00_FIFO_DEPTH;
+		sssr_tfl_mask = CE5X00_SSSR_TFL_MASK;
+		sscr1_tft_mask = CE5X00_SSCR1_TFT;
+		tfl_default = TX_THRESH_CE5X00_DFLT;
+		break;
+	default:
+		int_error_stop(drv_data, "Unsupported spi contoller type");
+		return IRQ_HANDLED;
+	}
+
+
+	if (irq_status & SSSR_ROR) {
+		int_error_stop(drv_data, "interrupt_transfer: fifo overrun");
+		return IRQ_HANDLED;
+	}
+
+
+	if (irq_status & SSSR_TINT) {
+		write_sssr_cs(drv_data, SSSR_TINT);
+		if (drv_data->read(drv_data)) {
+			int_transfer_complete(drv_data);
+			return IRQ_HANDLED;
+		}
+	}
+
+
+	if (irq_status & SSSR_TFS) {
+
+		/*
+		 * Mask the Transmit interrupt
+		 */
+		pxa2xx_mask_intr(reg, SSCR1_TIE);
+
+		left = (drv_data->tx_end - drv_data->tx) / drv_data->n_bytes;
+
+		tmp_sssr = read_sssr(reg);
+		tmp_sssr = (tmp_sssr & sssr_tfl_mask)>>8;
+		/*
+		 * Choose the correct tx_count to fill the Tx fifo and
+		 * avoid the Rx Fifo overrun
+		 */
+		tx_count =  (fifo_depth - 1) - tmp_sssr;
+
+		if (left <= tx_count) {
+			if (left > 0) {
+				drv_data->read(drv_data);
+				pxa2xx_update_tx_threshold(drv_data, 1);
+				while ((left) > 0) {
+					left--;
+					drv_data->write(drv_data);
+				}
+				pxa2xx_unmask_intr(reg, SSCR1_TIE);
+				return IRQ_HANDLED;
+			} else {
+				/*
+				 * Tx transfer is done now,
+				 * Read data when controller is not busy.
+				 */
+				wait_till_not_busy(drv_data);
+				drv_data->read(drv_data);
+				pxa2xx_unmask_intr(reg, SSCR1_TIE);
+				int_transfer_complete(drv_data);
+				return IRQ_HANDLED;
+			}
+		} else {
+			left = (left > tx_count) ? tx_count : left;
+			drv_data->read(drv_data);
+			while ((left) > 0) {
+				left--;
+				drv_data->write(drv_data);
+			}
+			pxa2xx_unmask_intr(reg, SSCR1_TIE);
+			return IRQ_HANDLED;
+		}
+	}
+	/* We did something */
+	return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t ssp_int(int irq, void *dev_id)
+{
+	struct driver_data *drv_data = dev_id;
+	void __iomem *reg = drv_data->ioaddr;
+	u32 sccr1_reg = read_sscr1(reg);
+	u32 mask = drv_data->mask_sr;
+	u32 status;
+	irqreturn_t ret;
+
+	status = read_sssr(reg);
 
 	/* Ignore possible writes if we don't need to write */
 	if (!(sccr1_reg & SSCR1_TIE))
@@ -549,36 +1106,311 @@
 	if (!(status & mask))
 		return IRQ_NONE;
 
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	mask_pvm(drv_data->ssp->pcidev);
+#endif
 	if (!drv_data->cur_msg) {
 
-		write_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);
-		write_SSCR1(read_SSCR1(reg) & ~drv_data->int_cr1, reg);
+		write_sscr0(read_sscr0(reg) & ~SSCR0_SSE, reg);
+		write_sscr1(read_sscr1(reg) & ~drv_data->int_cr1, reg);
 		if (!pxa25x_ssp_comp(drv_data))
-			write_SSTO(0, reg);
-		write_SSSR_CS(drv_data, drv_data->clear_sr);
-
-		dev_err(&drv_data->pdev->dev, "bad message state "
-			"in interrupt handler\n");
+			write_ssto(0, reg);
+		write_sssr_cs(drv_data, drv_data->clear_sr);
 
+		dev_err(&drv_data->pdev->dev,
+			"bad message state in interrupt handler\n");
 		/* Never fail */
 		return IRQ_HANDLED;
 	}
+	ret = drv_data->transfer_handler(drv_data);
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	unmask_pvm(drv_data->ssp->pcidev);
+#endif
+	return ret;
+}
+
+static int set_dma_burst_and_threshold(struct chip_data *chip,
+				struct spi_device *spi,
+				u8 bits_per_word, u32 *burst_code,
+				u32 *threshold)
+{
+	struct pxa2xx_spi_chip *chip_info =
+			(struct pxa2xx_spi_chip *)spi->controller_data;
+	int bytes_per_word;
+	int burst_bytes;
+	int thresh_words;
+	int req_burst_size;
+	int retval = 0;
+
+	/* Set the threshold (in registers) to equal the same amount of data
+	 * as represented by burst size (in bytes).  The computation below
+	 * is (burst_size rounded up to nearest 8 byte, word or long word)
+	 * divided by (bytes/register); the tx threshold is the inverse of
+	 * the rx, so that there will always be enough data in the rx fifo
+	 * to satisfy a burst, and there will always be enough space in the
+	 * tx fifo to accept a burst (a tx burst will overwrite the fifo if
+	 * there is not enough space), there must always remain enough empty
+	 * space in the rx fifo for any data loaded to the tx fifo.
+	 * Whenever burst_size (in bytes) equals bits/word, the fifo threshold
+	 * will be 8, or half the fifo;
+	 * The threshold can only be set to 2, 4 or 8, but not 16, because
+	 * to burst 16 to the tx fifo, the fifo would have to be empty;
+	 * however, the minimum fifo trigger level is 1, and the tx will
+	 * request service when the fifo is at this level, with only 15 spaces.
+	 */
+
+	/* find bytes/word */
+	if (bits_per_word <= 8)
+		bytes_per_word = 1;
+	else if (bits_per_word <= 16)
+		bytes_per_word = 2;
+	else
+		bytes_per_word = 4;
+
+	/* use struct pxa2xx_spi_chip->dma_burst_size if available */
+	if (chip_info)
+		req_burst_size = chip_info->dma_burst_size;
+	else {
+		switch (chip->dma_burst_size) {
+		default:
+			/* if the default burst size is not set,
+			 * do it now */
+			chip->dma_burst_size = DCMD_BURST8;
+		case DCMD_BURST8:
+			req_burst_size = 8;
+			break;
+		case DCMD_BURST16:
+			req_burst_size = 16;
+			break;
+		case DCMD_BURST32:
+			req_burst_size = 32;
+			break;
+		}
+	}
+	if (req_burst_size <= 8) {
+		*burst_code = DCMD_BURST8;
+		burst_bytes = 8;
+	} else if (req_burst_size <= 16) {
+		if (bytes_per_word == 1) {
+			/* don't burst more than 1/2 the fifo */
+			*burst_code = DCMD_BURST8;
+			burst_bytes = 8;
+			retval = 1;
+		} else {
+			*burst_code = DCMD_BURST16;
+			burst_bytes = 16;
+		}
+	} else {
+		if (bytes_per_word == 1) {
+			/* don't burst more than 1/2 the fifo */
+			*burst_code = DCMD_BURST8;
+			burst_bytes = 8;
+			retval = 1;
+		} else if (bytes_per_word == 2) {
+			/* don't burst more than 1/2 the fifo */
+			*burst_code = DCMD_BURST16;
+			burst_bytes = 16;
+			retval = 1;
+		} else {
+			*burst_code = DCMD_BURST32;
+			burst_bytes = 32;
+		}
+	}
+
+	thresh_words = burst_bytes / bytes_per_word;
 
-	return drv_data->transfer_handler(drv_data);
+	/* thresh_words will be between 2 and 8 */
+	*threshold = (SSCR1_RxTresh(thresh_words) & SSCR1_RFT)
+			| (SSCR1_TxTresh(16-thresh_words) & SSCR1_TFT);
+
+	return retval;
+}
+#ifdef CONFIG_GEN3_SPI
+/* this returns the value of DDS_FREQ not Input_Clock
+   DDS_FREQ = Input_Clock ( DDS_CLK_RATEdec / 2^24) */
+static unsigned long spi_clk_get_rate(int ssp_type)
+{
+	switch (ssp_type) {
+	case CE5X00_SSP:
+		/* CE5X00 clk is 10MHZ */
+		return 10000000;
+	case CE4100_SSP:
+		/* CE4X00 clk is 3.684MHZ */
+	default:
+		return 3686400;
+	}
+
+	return 3686400;
 }
+#endif
 
-static unsigned int ssp_get_clk_div(struct driver_data *drv_data, int rate)
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+/*  see Quark SPI data sheet for implementation rationale */
+u32 qrk_set_clk_regvals(u32 rate, u32 *dds, u32 *clk_div)
+{
+	if (rate <= BITRATE_MAX && rate >= BITRATE_MIN) {
+		if (rate >= BITRATE_50MHZ) {
+			*dds = DDS_MAX;
+			*clk_div = 0;
+			return BITRATE_50MHZ;
+		} else if (rate >= BITRATE_40MHZ) {
+			*dds = DDS_666666;
+			*clk_div = 0;
+			return BITRATE_40MHZ;
+		} else if (rate >= BITRATE_25MHZ) {
+			*dds = DDS_400000;
+			*clk_div = 0;
+			return BITRATE_25MHZ;
+		} else if (rate >= BITRATE_20MHZ) {
+			*dds = DDS_666666;
+			*clk_div = 1;
+			return BITRATE_20MHZ;
+		} else if (rate >= BITRATE_16667KHZ) {
+			*dds = DDS_MAX;
+			*clk_div = 2;
+			return BITRATE_16667KHZ;
+		} else if (rate >= BITRATE_13333KHZ) {
+			*dds = DDS_666666;
+			*clk_div = 2;
+			return BITRATE_13333KHZ;
+		} else if (rate >= BITRATE_12500KHZ) {
+			*dds = DDS_200000;
+			*clk_div = 0;
+			return BITRATE_12500KHZ;
+		} else if (rate >= BITRATE_10MHZ) {
+			*dds = DDS_MAX;
+			*clk_div = 4;
+			return BITRATE_10MHZ;
+		} else if (rate >= BITRATE_8MHZ) {
+			*dds = DDS_666666;
+			*clk_div = 4;
+			return BITRATE_8MHZ;
+		} else if (rate >= BITRATE_6250KHZ) {
+			*dds = DDS_400000;
+			*clk_div = 3;
+			return BITRATE_6250KHZ;
+		} else if (rate >= BITRATE_5MHZ) {
+			*dds = DDS_400000;
+			*clk_div = 4;
+			return BITRATE_5MHZ;
+		} else if (rate >= BITRATE_4MHZ) {
+			*dds = DDS_666666;
+			*clk_div = 9;
+			return BITRATE_4MHZ;
+		} else if (rate >= BITRATE_3125KHZ) {
+			*dds = DDS_80000;
+			*clk_div = 0;
+			return BITRATE_3125KHZ;
+		} else if (rate >= BITRATE_2500KHZ) {
+			*dds = DDS_400000;
+			*clk_div = 9;
+			return BITRATE_2500KHZ;
+		} else if (rate >= BITRATE_2MHZ) {
+			*dds = DDS_666666;
+			*clk_div = 19;
+			return BITRATE_2MHZ;
+		} else if (rate >= BITRATE_1563KHZ) {
+			*dds = DDS_40000;
+			*clk_div = 0;
+			return BITRATE_1563KHZ;
+		} else if (rate >= BITRATE_1250KHZ) {
+			*dds = DDS_200000;
+			*clk_div = 9;
+			return BITRATE_1250KHZ;
+		} else if (rate >= BITRATE_1MHZ) {
+			*dds = DDS_400000;
+			*clk_div = 24;
+			return BITRATE_1MHZ;
+		} else if (rate >= BITRATE_800KHZ) {
+			*dds = DDS_666666;
+			*clk_div = 49;
+			return BITRATE_800KHZ;
+		} else if (rate >= BITRATE_781KHZ) {
+			*dds = DDS_20000;
+			*clk_div = 0;
+			return BITRATE_781KHZ;
+		} else if (rate >= BITRATE_625KHZ) {
+			*dds = DDS_200000;
+			*clk_div = 19;
+			return BITRATE_625KHZ;
+		} else if (rate >= BITRATE_500KHZ) {
+			*dds = DDS_400000;
+			*clk_div = 49;
+			return BITRATE_500KHZ;
+		} else if (rate >= BITRATE_400KHZ) {
+			*dds = DDS_666666;
+			*clk_div = 99;
+			return BITRATE_400KHZ;
+		} else if (rate >= BITRATE_390KHZ) {
+			*dds = DDS_10000;
+			*clk_div = 0;
+			return BITRATE_390KHZ;
+		} else if (rate >= BITRATE_250KHZ) {
+			*dds = DDS_400000;
+			*clk_div = 99;
+			return BITRATE_250KHZ;
+		} else if (rate >= BITRATE_200KHZ) {
+			*dds = DDS_666666;
+			*clk_div = 199;
+			return BITRATE_200KHZ;
+		} else if (rate >= BITRATE_195KHZ) {
+			*dds = DDS_8000;
+			*clk_div = 0;
+			return BITRATE_195KHZ;
+		} else if (rate >= BITRATE_125KHZ) {
+			*dds = DDS_100000;
+			*clk_div = 49;
+			return BITRATE_125KHZ;
+		} else if (rate >= BITRATE_100KHZ) {
+			*dds = DDS_200000;
+			*clk_div = 124;
+			return BITRATE_100KHZ;
+		} else if (rate >= BITRATE_50KHZ) {
+			*dds = DDS_100000;
+			*clk_div = 124;
+			return BITRATE_50KHZ;
+		} else if (rate >= BITRATE_25KHZ) {
+			*dds = DDS_80000;
+			*clk_div = 124;
+			return BITRATE_25KHZ;
+		} else if (rate >= BITRATE_10KHZ) {
+			*dds = DDS_20000;
+			*clk_div = 77;
+			return BITRATE_10KHZ;
+		} else if (rate >= BITRATE_5KHZ) {
+			*dds = DDS_20000;
+			*clk_div = 154;
+			return BITRATE_5KHZ;
+		} else if (rate >= BITRATE_1KHZ) {
+			*dds = DDS_8000;
+			*clk_div = 194;
+			return BITRATE_1KHZ;
+		}
+	} else {
+		*dds = DDS_8000;
+		*clk_div = 194;
+		return BITRATE_MIN;
+	}
+	return 0;
+}
+#else
+/* this returns the value that SCR needs to be set to
+   Bit rate = DDS_FREQ / (2 x (SCR + 1)) */
+static unsigned int ssp_get_clk_div(struct ssp_device *ssp, int rate)
 {
-	unsigned long ssp_clk = drv_data->max_clk_rate;
-	const struct ssp_device *ssp = drv_data->ssp;
-
-	rate = min_t(int, ssp_clk, rate);
+#ifdef CONFIG_GEN3_SPI
+	unsigned long ssp_clk =  spi_clk_get_rate(ssp->type);
+#else
+	unsigned long ssp_clk = clk_get_rate(ssp->clk);
+#endif
 
-	if (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP)
+	if (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP
+	    || ssp->type == CE5X00_SSP)
 		return ((ssp_clk / (2 * rate) - 1) & 0xff) << 8;
 	else
 		return ((ssp_clk / rate - 1) & 0xfff) << 8;
 }
+#endif /* CONFIG_INTEL_QUARK_X1000_SOC */
 
 static void pump_transfers(unsigned long data)
 {
@@ -587,6 +1419,11 @@
 	struct spi_transfer *transfer = NULL;
 	struct spi_transfer *previous = NULL;
 	struct chip_data *chip = NULL;
+#ifndef CONFIG_INTEL_QUARK_X1000_SOC
+	struct ssp_device *ssp = drv_data->ssp;
+#else
+	u32 actual_speed = 0;
+#endif
 	void __iomem *reg = drv_data->ioaddr;
 	u32 clk_div = 0;
 	u8 bits = 0;
@@ -599,8 +1436,11 @@
 	/* Get current state information */
 	message = drv_data->cur_msg;
 	transfer = drv_data->cur_transfer;
+
 	chip = drv_data->cur_chip;
 
+	if (transfer->bits_per_word)
+		chip->n_bytes = (transfer->bits_per_word + 7)/8;
 	/* Handle for abort */
 	if (message->state == ERROR_STATE) {
 		message->status = -EIO;
@@ -628,8 +1468,8 @@
 			cs_deassert(drv_data);
 	}
 
-	/* Check if we can DMA this transfer */
-	if (!pxa2xx_spi_dma_is_possible(transfer->len) && chip->enable_dma) {
+	/* Check for transfers that need multiple DMA segments */
+	if (transfer->len > MAX_DMA_LEN && chip->enable_dma) {
 
 		/* reject already-mapped transfers; PIO won't always work */
 		if (message->is_dma_mapped
@@ -644,35 +1484,38 @@
 		}
 
 		/* warn ... we force this to PIO mode */
-		if (printk_ratelimit())
-			dev_warn(&message->spi->dev, "pump_transfers: "
-				"DMA disabled for transfer length %ld "
-				"greater than %d\n",
-				(long)drv_data->len, MAX_DMA_LEN);
+		dev_warn_ratelimited(&message->spi->dev,
+				     "pump_transfers: "
+				     "DMA disabled for transfer length %ld "
+				     "greater than %d\n",
+				     (long)drv_data->len, MAX_DMA_LEN);
 	}
 
 	/* Setup the transfer state based on the type of transfer */
-	if (pxa2xx_spi_flush(drv_data) == 0) {
+	if (flush(drv_data) == 0) {
 		dev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");
 		message->status = -EIO;
 		giveback(drv_data);
 		return;
 	}
 	drv_data->n_bytes = chip->n_bytes;
+	drv_data->dma_width = chip->dma_width;
 	drv_data->tx = (void *)transfer->tx_buf;
-	drv_data->tx_end = drv_data->tx + transfer->len;
+	drv_data->tx_end = drv_data->tx
+		+ (transfer->len/drv_data->n_bytes)*drv_data->n_bytes;
 	drv_data->rx = transfer->rx_buf;
-	drv_data->rx_end = drv_data->rx + transfer->len;
+	drv_data->rx_end = drv_data->rx
+		+ (transfer->len/drv_data->n_bytes)*drv_data->n_bytes;
 	drv_data->rx_dma = transfer->rx_dma;
 	drv_data->tx_dma = transfer->tx_dma;
-	drv_data->len = transfer->len;
+	drv_data->len =  (transfer->len/drv_data->n_bytes)
+		* drv_data->n_bytes & DCMD_LENGTH;
 	drv_data->write = drv_data->tx ? chip->write : null_writer;
 	drv_data->read = drv_data->rx ? chip->read : null_reader;
 
 	/* Change speed and bit per word on a per transfer */
 	cr0 = chip->cr0;
 	if (transfer->speed_hz || transfer->bits_per_word) {
-
 		bits = chip->bits_per_word;
 		speed = chip->speed_hz;
 
@@ -682,22 +1525,30 @@
 		if (transfer->bits_per_word)
 			bits = transfer->bits_per_word;
 
-		clk_div = ssp_get_clk_div(drv_data, speed);
-
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+		actual_speed = qrk_set_clk_regvals
+				(speed, &chip->dds_rate, &clk_div);
+		clk_div = (clk_div << 8);
+#else
+		clk_div = ssp_get_clk_div(ssp, speed);
+#endif
 		if (bits <= 8) {
 			drv_data->n_bytes = 1;
+			drv_data->dma_width = DCMD_WIDTH1;
 			drv_data->read = drv_data->read != null_reader ?
 						u8_reader : null_reader;
 			drv_data->write = drv_data->write != null_writer ?
 						u8_writer : null_writer;
 		} else if (bits <= 16) {
 			drv_data->n_bytes = 2;
+			drv_data->dma_width = DCMD_WIDTH2;
 			drv_data->read = drv_data->read != null_reader ?
 						u16_reader : null_reader;
 			drv_data->write = drv_data->write != null_writer ?
 						u16_writer : null_writer;
 		} else if (bits <= 32) {
 			drv_data->n_bytes = 4;
+			drv_data->dma_width = DCMD_WIDTH4;
 			drv_data->read = drv_data->read != null_reader ?
 						u32_reader : null_reader;
 			drv_data->write = drv_data->write != null_writer ?
@@ -706,122 +1557,175 @@
 		/* if bits/word is changed in dma mode, then must check the
 		 * thresholds and burst also */
 		if (chip->enable_dma) {
-			if (pxa2xx_spi_set_dma_burst_and_threshold(chip,
-							message->spi,
+			if (set_dma_burst_and_threshold(chip, message->spi,
 							bits, &dma_burst,
 							&dma_thresh))
-				if (printk_ratelimit())
-					dev_warn(&message->spi->dev,
-						"pump_transfers: "
-						"DMA burst size reduced to "
-						"match bits_per_word\n");
+				dev_warn_ratelimited(&message->spi->dev,
+						     "pump_transfers: "
+						     "DMA burst size reduced to"
+						     " match bits_per_word\n");
 		}
 
-		cr0 = clk_div
-			| SSCR0_Motorola
-			| SSCR0_DataSize(bits > 16 ? bits - 16 : bits)
-			| SSCR0_SSE
-			| (bits > 16 ? SSCR0_EDSS : 0);
+		switch (drv_data->ssp_type) {
+		case CE5X00_SSP:
+			chip->cr0 = clk_div
+				| CE5X00_SSCR0_Motorola
+				| CE5X00_SSCR0_DataSize(bits > 32 ?
+							8 : bits)
+				| SSCR0_SSE;
+			break;
+		case CE4100_SSP:
+		case PXA25x_SSP:
+		default:
+			chip->cr0 = clk_div
+				| SSCR0_Motorola
+				| SSCR0_DataSize(bits > 16 ?
+						 bits - 16 : bits)
+				| SSCR0_SSE
+				| (bits > 16 ? SSCR0_EDSS : 0);
+		}
+		
+		cr0 = chip->cr0;
 	}
 
 	message->state = RUNNING_STATE;
 
+	/* Try to map dma buffer and do a dma transfer if successful, but
+	 * only if the length is non-zero and less than MAX_DMA_LEN.
+	 *
+	 * Zero-length non-descriptor DMA is illegal on PXA2xx; force use
+	 * of PIO instead.  Care is needed above because the transfer may
+	 * have have been passed with buffers that are already dma mapped.
+	 * A zero-length transfer in PIO mode will not try to write/read
+	 * to/from the buffers
+	 *
+	 * REVISIT large transfers are exactly where we most want to be
+	 * using DMA.  If this happens much, split those transfers into
+	 * multiple DMA segments rather than forcing PIO.
+	 */
 	drv_data->dma_mapped = 0;
-	if (pxa2xx_spi_dma_is_possible(drv_data->len))
-		drv_data->dma_mapped = pxa2xx_spi_map_dma_buffers(drv_data);
+	if (drv_data->len > 0 && drv_data->len <= MAX_DMA_LEN)
+		drv_data->dma_mapped = map_dma_buffers(drv_data);
 	if (drv_data->dma_mapped) {
 
 		/* Ensure we have the correct interrupt handler */
-		drv_data->transfer_handler = pxa2xx_spi_dma_transfer;
+		drv_data->transfer_handler = dma_transfer;
 
-		pxa2xx_spi_dma_prepare(drv_data, dma_burst);
+		/* Setup rx DMA Channel */
+		DCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;
+		DSADR(drv_data->rx_channel) = drv_data->ssdr_physical;
+		DTADR(drv_data->rx_channel) = drv_data->rx_dma;
+		if (drv_data->rx == drv_data->null_dma_buf)
+			/* No target address increment */
+			DCMD(drv_data->rx_channel) = DCMD_FLOWSRC
+							| drv_data->dma_width
+							| dma_burst
+							| drv_data->len;
+		else
+			DCMD(drv_data->rx_channel) = DCMD_INCTRGADDR
+							| DCMD_FLOWSRC
+							| drv_data->dma_width
+							| dma_burst
+							| drv_data->len;
+
+		/* Setup tx DMA Channel */
+		DCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;
+		DSADR(drv_data->tx_channel) = drv_data->tx_dma;
+		DTADR(drv_data->tx_channel) = drv_data->ssdr_physical;
+		if (drv_data->tx == drv_data->null_dma_buf)
+			/* No source address increment */
+			DCMD(drv_data->tx_channel) = DCMD_FLOWTRG
+							| drv_data->dma_width
+							| dma_burst
+							| drv_data->len;
+		else
+			DCMD(drv_data->tx_channel) = DCMD_INCSRCADDR
+							| DCMD_FLOWTRG
+							| drv_data->dma_width
+							| dma_burst
+							| drv_data->len;
+
+		/* Enable dma end irqs on SSP to detect end of transfer */
+		if (drv_data->ssp_type == PXA25x_SSP)
+			DCMD(drv_data->tx_channel) |= DCMD_ENDIRQEN;
 
 		/* Clear status and start DMA engine */
 		cr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;
-		write_SSSR(drv_data->clear_sr, reg);
-
-		pxa2xx_spi_dma_start(drv_data);
+		write_sssr(drv_data->clear_sr, reg);
+		DCSR(drv_data->rx_channel) |= DCSR_RUN;
+		DCSR(drv_data->tx_channel) |= DCSR_RUN;
 	} else {
 		/* Ensure we have the correct interrupt handler	*/
 		drv_data->transfer_handler = interrupt_transfer;
 
 		/* Clear status  */
 		cr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;
-		write_SSSR_CS(drv_data, drv_data->clear_sr);
-	}
-
-	if (is_lpss_ssp(drv_data)) {
-		if ((read_SSIRF(reg) & 0xff) != chip->lpss_rx_threshold)
-			write_SSIRF(chip->lpss_rx_threshold, reg);
-		if ((read_SSITF(reg) & 0xffff) != chip->lpss_tx_threshold)
-			write_SSITF(chip->lpss_tx_threshold, reg);
+		write_sssr_cs(drv_data, drv_data->clear_sr);
 	}
 
 	/* see if we need to reload the config registers */
-	if ((read_SSCR0(reg) != cr0)
-		|| (read_SSCR1(reg) & SSCR1_CHANGE_MASK) !=
-			(cr1 & SSCR1_CHANGE_MASK)) {
-
+	if (drv_data->ssp_type == CE5X00_SSP) {
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+		if (read_dds_rate(reg) != chip->dds_rate)
+			write_dds_rate(chip->dds_rate, reg);
+#endif
+		if ((read_sscr0(reg) != cr0)
+			|| (read_sscr1(reg) & CE5X00_SSCR1_CHANGE_MASK) !=
+				(cr1 & CE5X00_SSCR1_CHANGE_MASK)) {
+			/* stop the SSP, and update the other bits */
+			write_sscr0(cr0 & ~SSCR0_SSE, reg);
+			if (!pxa25x_ssp_comp(drv_data))
+				write_ssto(chip->timeout, reg);
+			/* first set CR1 w/o interrupt and service enables */
+			write_sscr1(cr1 & CE5X00_SSCR1_CHANGE_MASK, reg);
+			/* restart the SSP */
+			write_sscr0(cr0, reg);
+
+		} else {
+			if (!pxa25x_ssp_comp(drv_data))
+				write_ssto(chip->timeout, reg);
+		}
+	} else if ((read_sscr0(reg) != cr0)
+		   || (read_sscr1(reg) & SSCR1_CHANGE_MASK) !=
+		   (cr1 & SSCR1_CHANGE_MASK)) {
 		/* stop the SSP, and update the other bits */
-		write_SSCR0(cr0 & ~SSCR0_SSE, reg);
+		write_sscr0(cr0 & ~SSCR0_SSE, reg);
 		if (!pxa25x_ssp_comp(drv_data))
-			write_SSTO(chip->timeout, reg);
+			write_ssto(chip->timeout, reg);
 		/* first set CR1 without interrupt and service enables */
-		write_SSCR1(cr1 & SSCR1_CHANGE_MASK, reg);
+		write_sscr1(cr1 & SSCR1_CHANGE_MASK, reg);
 		/* restart the SSP */
-		write_SSCR0(cr0, reg);
+		write_sscr0(cr0, reg);
 
-	} else {
-		if (!pxa25x_ssp_comp(drv_data))
-			write_SSTO(chip->timeout, reg);
+	} else if (!pxa25x_ssp_comp(drv_data)) {
+		write_ssto(chip->timeout, reg);
 	}
-
 	cs_assert(drv_data);
 
 	/* after chip select, release the data by enabling service
 	 * requests and interrupts, without changing any mode bits */
-	write_SSCR1(cr1, reg);
+	write_sscr1(cr1, reg);
 }
 
-static int pxa2xx_spi_transfer_one_message(struct spi_master *master,
-					   struct spi_message *msg)
+static int transfer_one_message(struct spi_master *master,
+				struct spi_message *msg)
 {
 	struct driver_data *drv_data = spi_master_get_devdata(master);
 
+	/* Initial message state */
 	drv_data->cur_msg = msg;
-	/* Initial message state*/
-	drv_data->cur_msg->state = START_STATE;
-	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
-						struct spi_transfer,
-						transfer_list);
+	msg->state = START_STATE;
+
+	drv_data->cur_transfer = list_entry(msg->transfers.next,
+					    struct spi_transfer, transfer_list);
 
 	/* prepare to setup the SSP, in pump_transfers, using the per
 	 * chip configuration */
-	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
+	drv_data->cur_chip = spi_get_ctldata(msg->spi);
 
-	/* Mark as busy and launch transfers */
+	/* Launch transfers */
 	tasklet_schedule(&drv_data->pump_transfers);
-	return 0;
-}
-
-static int pxa2xx_spi_prepare_transfer(struct spi_master *master)
-{
-	struct driver_data *drv_data = spi_master_get_devdata(master);
 
-	pm_runtime_get_sync(&drv_data->pdev->dev);
-	return 0;
-}
-
-static int pxa2xx_spi_unprepare_transfer(struct spi_master *master)
-{
-	struct driver_data *drv_data = spi_master_get_devdata(master);
-
-	/* Disable the SSP now */
-	write_SSCR0(read_SSCR0(drv_data->ioaddr) & ~SSCR0_SSE,
-		    drv_data->ioaddr);
-
-	pm_runtime_mark_last_busy(&drv_data->pdev->dev);
-	pm_runtime_put_autosuspend(&drv_data->pdev->dev);
 	return 0;
 }
 
@@ -848,8 +1752,9 @@
 	if (gpio_is_valid(chip_info->gpio_cs)) {
 		err = gpio_request(chip_info->gpio_cs, "SPI_CS");
 		if (err) {
-			dev_err(&spi->dev, "failed to request chip select "
-					"GPIO%d\n", chip_info->gpio_cs);
+			dev_err(&spi->dev,
+				"failed to request chip select "
+				"GPIO%d\n", chip_info->gpio_cs);
 			return err;
 		}
 
@@ -863,36 +1768,61 @@
 	return err;
 }
 
+static int prepare_transfer_hardware(struct spi_master *master)
+{
+	struct driver_data *drv_data = spi_master_get_devdata(master);
+
+	/*
+	 * Just make sure we have all we need to run the transfer by syncing
+	 * with the runtime PM framework.
+	 */
+	pm_runtime_get_sync(&drv_data->pdev->dev);
+	return 0;
+}
+
+static int unprepare_transfer_hardware(struct spi_master *master)
+{
+	struct driver_data *drv_data = spi_master_get_devdata(master);
+
+	/* nothing more to do - disable spi/ssp and power off */
+	write_sscr0(0, drv_data->ioaddr);
+	clk_disable(drv_data->ssp->clk);
+
+	pm_runtime_put(&drv_data->pdev->dev);
+
+	return 0;
+}
+
 static int setup(struct spi_device *spi)
 {
 	struct pxa2xx_spi_chip *chip_info = NULL;
 	struct chip_data *chip;
 	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
+	struct ssp_device *ssp = drv_data->ssp;
 	unsigned int clk_div;
-	uint tx_thres, tx_hi_thres, rx_thres;
-
-	if (is_lpss_ssp(drv_data)) {
-		tx_thres = LPSS_TX_LOTHRESH_DFLT;
-		tx_hi_thres = LPSS_TX_HITHRESH_DFLT;
-		rx_thres = LPSS_RX_THRESH_DFLT;
-	} else {
-		tx_thres = TX_THRESH_DFLT;
-		tx_hi_thres = 0;
-		rx_thres = RX_THRESH_DFLT;
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	u32 actual_speed;
+#endif
+	uint tx_thres = TX_THRESH_DFLT;
+	uint rx_thres = RX_THRESH_DFLT;
+	if (drv_data->ssp_type == CE5X00_SSP) {
+		tx_thres = TX_THRESH_CE5X00_DFLT;
+		rx_thres = RX_THRESH_CE5X00_DFLT;
 	}
-
-	if (!pxa25x_ssp_comp(drv_data)
+	if ((!pxa25x_ssp_comp(drv_data) || pxa25x_ssp_comp(drv_data) == 2)
 		&& (spi->bits_per_word < 4 || spi->bits_per_word > 32)) {
-		dev_err(&spi->dev, "failed setup: ssp_type=%d, bits/wrd=%d "
-				"b/w not 4-32 for type non-PXA25x_SSP\n",
-				drv_data->ssp_type, spi->bits_per_word);
+		dev_err(&spi->dev,
+			"failed setup: ssp_type=%d, bits/wrd=%d "
+			"b/w not 4-32 for type non-PXA25x_SSP\n",
+			drv_data->ssp_type, spi->bits_per_word);
 		return -EINVAL;
-	} else if (pxa25x_ssp_comp(drv_data)
+	} else if (pxa25x_ssp_comp(drv_data) == 1
 			&& (spi->bits_per_word < 4
 				|| spi->bits_per_word > 16)) {
-		dev_err(&spi->dev, "failed setup: ssp_type=%d, bits/wrd=%d "
-				"b/w not 4-16 for type PXA25x_SSP\n",
-				drv_data->ssp_type, spi->bits_per_word);
+		dev_err(&spi->dev,
+			"failed setup: ssp_type=%d, bits/wrd=%d "
+			"b/w not 4-16 for type PXA25x_SSP\n",
+			drv_data->ssp_type, spi->bits_per_word);
 		return -EINVAL;
 	}
 
@@ -908,8 +1838,9 @@
 
 		if (drv_data->ssp_type == CE4100_SSP) {
 			if (spi->chip_select > 4) {
-				dev_err(&spi->dev, "failed setup: "
-				"cs number must not be > 4.\n");
+				dev_err(&spi->dev,
+					"failed setup: "
+					"cs number must not be > 4.\n");
 				kfree(chip);
 				return -EINVAL;
 			}
@@ -917,8 +1848,11 @@
 			chip->frm = spi->chip_select;
 		} else
 			chip->gpio_cs = -1;
+
 		chip->enable_dma = 0;
 		chip->timeout = TIMOUT_DFLT;
+		chip->dma_burst_size = drv_data->master_info->enable_dma ?
+					DCMD_BURST8 : 0;
 	}
 
 	/* protocol drivers may change the chip settings, so...
@@ -927,88 +1861,114 @@
 
 	/* chip_info isn't always needed */
 	chip->cr1 = 0;
+	chip->cr0 = 0;
 	if (chip_info) {
 		if (chip_info->timeout)
 			chip->timeout = chip_info->timeout;
 		if (chip_info->tx_threshold)
 			tx_thres = chip_info->tx_threshold;
-		if (chip_info->tx_hi_threshold)
-			tx_hi_thres = chip_info->tx_hi_threshold;
 		if (chip_info->rx_threshold)
 			rx_thres = chip_info->rx_threshold;
 		chip->enable_dma = drv_data->master_info->enable_dma;
 		chip->dma_threshold = 0;
 		if (chip_info->enable_loopback)
 			chip->cr1 = SSCR1_LBM;
-	} else if (ACPI_HANDLE(&spi->dev)) {
-		/*
-		 * Slave devices enumerated from ACPI namespace don't
-		 * usually have chip_info but we still might want to use
-		 * DMA with them.
-		 */
-		chip->enable_dma = drv_data->master_info->enable_dma;
 	}
 
-	chip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |
-			(SSCR1_TxTresh(tx_thres) & SSCR1_TFT);
-
-	chip->lpss_rx_threshold = SSIRF_RxThresh(rx_thres);
-	chip->lpss_tx_threshold = SSITF_TxLoThresh(tx_thres)
-				| SSITF_TxHiThresh(tx_hi_thres);
-
 	/* set dma burst and threshold outside of chip_info path so that if
 	 * chip_info goes away after setting chip->enable_dma, the
 	 * burst and threshold can still respond to changes in bits_per_word */
 	if (chip->enable_dma) {
 		/* set up legal burst and threshold for dma */
-		if (pxa2xx_spi_set_dma_burst_and_threshold(chip, spi,
-						spi->bits_per_word,
+		if (set_dma_burst_and_threshold(chip, spi, spi->bits_per_word,
 						&chip->dma_burst_size,
 						&chip->dma_threshold)) {
-			dev_warn(&spi->dev, "in setup: DMA burst size reduced "
-					"to match bits_per_word\n");
+			dev_warn(&spi->dev,
+				 "in setup: DMA burst size reduced "
+				 "to match bits_per_word\n");
 		}
 	}
-
-	clk_div = ssp_get_clk_div(drv_data, spi->max_speed_hz);
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	actual_speed = qrk_set_clk_regvals(spi->max_speed_hz,
+						&chip->dds_rate, &clk_div);
+	clk_div = (clk_div << 8);
+#else
+	clk_div = ssp_get_clk_div(ssp, spi->max_speed_hz);
+#endif
 	chip->speed_hz = spi->max_speed_hz;
 
-	chip->cr0 = clk_div
+	switch (drv_data->ssp_type) {
+	case  CE5X00_SSP:
+		chip->cr0 = clk_div
+			| CE5X00_SSCR0_Motorola
+			| CE5X00_SSCR0_DataSize(spi->bits_per_word > 32 ?
+						8 : spi->bits_per_word)
+			| SSCR0_SSE;
+		chip->threshold = (CE5X00_SSCR1_RxTresh(rx_thres)
+				   & CE5X00_SSCR1_RFT) |
+			(CE5X00_SSCR1_TxTresh(tx_thres) & CE5X00_SSCR1_TFT);
+		break;
+	case  CE4100_SSP:
+	case  PXA25x_SSP:
+	default:
+		chip->cr0 = clk_div
 			| SSCR0_Motorola
 			| SSCR0_DataSize(spi->bits_per_word > 16 ?
 				spi->bits_per_word - 16 : spi->bits_per_word)
 			| SSCR0_SSE
 			| (spi->bits_per_word > 16 ? SSCR0_EDSS : 0);
+		chip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |
+			(SSCR1_TxTresh(tx_thres) & SSCR1_TFT);
+	}
+
 	chip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
+			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0)
+			| (((spi->mode & SPI_LOOP) != 0) ? SSCR1_LBM : 0);
+#else
 	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
 			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);
-
-	if (spi->mode & SPI_LOOP)
-		chip->cr1 |= SSCR1_LBM;
+#endif
 
 	/* NOTE:  PXA25x_SSP _could_ use external clocking ... */
 	if (!pxa25x_ssp_comp(drv_data))
-		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
-			drv_data->max_clk_rate
+		dev_dbg(&spi->dev,
+			"%ld Hz actual, %s\n",
+#ifndef CONFIG_GEN3_SPI
+			clk_get_rate(ssp->clk)
+#else
+			spi_clk_get_rate(ssp->type)
+#endif
 				/ (1 + ((chip->cr0 & SSCR0_SCR(0xfff)) >> 8)),
 			chip->enable_dma ? "DMA" : "PIO");
 	else
-		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
-			drv_data->max_clk_rate / 2
+		dev_dbg(&spi->dev,
+			"%ld Hz actual, %s\n",
+#ifndef CONFIG_GEN3_SPI
+			clk_get_rate(ssp->clk) / 2
+#else
+			spi_clk_get_rate(ssp->type) / 2
+#endif
 				/ (1 + ((chip->cr0 & SSCR0_SCR(0x0ff)) >> 8)),
 			chip->enable_dma ? "DMA" : "PIO");
 
 	if (spi->bits_per_word <= 8) {
 		chip->n_bytes = 1;
+		chip->dma_width = DCMD_WIDTH1;
 		chip->read = u8_reader;
 		chip->write = u8_writer;
 	} else if (spi->bits_per_word <= 16) {
 		chip->n_bytes = 2;
+		chip->dma_width = DCMD_WIDTH2;
 		chip->read = u16_reader;
 		chip->write = u16_writer;
 	} else if (spi->bits_per_word <= 32) {
+#ifndef CONFIG_GEN3_SPI
 		chip->cr0 |= SSCR0_EDSS;
+#endif
 		chip->n_bytes = 4;
+		chip->dma_width = DCMD_WIDTH4;
 		chip->read = u32_reader;
 		chip->write = u32_writer;
 	} else {
@@ -1039,97 +1999,6 @@
 	kfree(chip);
 }
 
-#ifdef CONFIG_ACPI
-static int pxa2xx_spi_acpi_add_dma(struct acpi_resource *res, void *data)
-{
-	struct pxa2xx_spi_master *pdata = data;
-
-	if (res->type == ACPI_RESOURCE_TYPE_FIXED_DMA) {
-		const struct acpi_resource_fixed_dma *dma;
-
-		dma = &res->data.fixed_dma;
-		if (pdata->tx_slave_id < 0) {
-			pdata->tx_slave_id = dma->request_lines;
-			pdata->tx_chan_id = dma->channels;
-		} else if (pdata->rx_slave_id < 0) {
-			pdata->rx_slave_id = dma->request_lines;
-			pdata->rx_chan_id = dma->channels;
-		}
-	}
-
-	/* Tell the ACPI core to skip this resource */
-	return 1;
-}
-
-static struct pxa2xx_spi_master *
-pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
-{
-	struct pxa2xx_spi_master *pdata;
-	struct list_head resource_list;
-	struct acpi_device *adev;
-	struct ssp_device *ssp;
-	struct resource *res;
-	int devid;
-
-	if (!ACPI_HANDLE(&pdev->dev) ||
-	    acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))
-		return NULL;
-
-	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata) {
-		dev_err(&pdev->dev,
-			"failed to allocate memory for platform data\n");
-		return NULL;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return NULL;
-
-	ssp = &pdata->ssp;
-
-	ssp->phys_base = res->start;
-	ssp->mmio_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(ssp->mmio_base))
-		return PTR_ERR(ssp->mmio_base);
-
-	ssp->clk = devm_clk_get(&pdev->dev, NULL);
-	ssp->irq = platform_get_irq(pdev, 0);
-	ssp->type = LPSS_SSP;
-	ssp->pdev = pdev;
-
-	ssp->port_id = -1;
-	if (adev->pnp.unique_id && !kstrtoint(adev->pnp.unique_id, 0, &devid))
-		ssp->port_id = devid;
-
-	pdata->num_chipselect = 1;
-	pdata->rx_slave_id = -1;
-	pdata->tx_slave_id = -1;
-
-	INIT_LIST_HEAD(&resource_list);
-	acpi_dev_get_resources(adev, &resource_list, pxa2xx_spi_acpi_add_dma,
-			       pdata);
-	acpi_dev_free_resource_list(&resource_list);
-
-	pdata->enable_dma = pdata->rx_slave_id >= 0 && pdata->tx_slave_id >= 0;
-
-	return pdata;
-}
-
-static struct acpi_device_id pxa2xx_spi_acpi_match[] = {
-	{ "INT33C0", 0 },
-	{ "INT33C1", 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(acpi, pxa2xx_spi_acpi_match);
-#else
-static inline struct pxa2xx_spi_master *
-pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
-{
-	return NULL;
-}
-#endif
-
 static int pxa2xx_spi_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1139,21 +2008,11 @@
 	struct ssp_device *ssp;
 	int status;
 
-	platform_info = dev_get_platdata(dev);
-	if (!platform_info) {
-		platform_info = pxa2xx_spi_acpi_get_pdata(pdev);
-		if (!platform_info) {
-			dev_err(&pdev->dev, "missing platform data\n");
-			return -ENODEV;
-		}
-	}
+	platform_info = dev->platform_data;
 
 	ssp = pxa_ssp_request(pdev->id, pdev->name);
-	if (!ssp)
-		ssp = &platform_info->ssp;
-
-	if (!ssp->mmio_base) {
-		dev_err(&pdev->dev, "failed to get ssp\n");
+	if (ssp == NULL) {
+		dev_err(&pdev->dev, "failed to request SSP%d\n", pdev->id);
 		return -ENODEV;
 	}
 
@@ -1171,21 +2030,31 @@
 	drv_data->ssp = ssp;
 
 	master->dev.parent = &pdev->dev;
+#ifdef CONFIG_OF
+#ifndef CONFIG_GEN3_SPI
 	master->dev.of_node = pdev->dev.of_node;
+#endif
+#endif
+
 	/* the spi->mode bits understood by this driver: */
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
-
-	master->bus_num = ssp->port_id;
+#else
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+#endif
+	master->bus_num = pdev->id;
 	master->num_chipselect = platform_info->num_chipselect;
 	master->dma_alignment = DMA_ALIGNMENT;
 	master->cleanup = cleanup;
 	master->setup = setup;
-	master->transfer_one_message = pxa2xx_spi_transfer_one_message;
-	master->prepare_transfer_hardware = pxa2xx_spi_prepare_transfer;
-	master->unprepare_transfer_hardware = pxa2xx_spi_unprepare_transfer;
+	master->prepare_transfer_hardware = prepare_transfer_hardware;
+	master->transfer_one_message = transfer_one_message;
+	master->unprepare_transfer_hardware = unprepare_transfer_hardware;
+	master->rt = true;
 
 	drv_data->ssp_type = ssp->type;
-	drv_data->null_dma_buf = (u32 *)PTR_ALIGN(&drv_data[1], DMA_ALIGNMENT);
+	drv_data->null_dma_buf = (u32 *)ALIGN((u32)(drv_data +
+						sizeof(struct driver_data)), 8);
 
 	drv_data->ioaddr = ssp->mmio_base;
 	drv_data->ssdr_physical = ssp->phys_base + SSDR;
@@ -1196,7 +2065,7 @@
 		drv_data->mask_sr = SSSR_RFS | SSSR_TFS | SSSR_ROR;
 	} else {
 		drv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE | SSCR1_TINTE;
-		drv_data->dma_cr1 = DEFAULT_DMA_CR1;
+		drv_data->dma_cr1 = SSCR1_TSRE | SSCR1_RSRE | SSCR1_TINTE;
 		drv_data->clear_sr = SSSR_ROR | SSSR_TINT;
 		drv_data->mask_sr = SSSR_TINT | SSSR_RFS | SSSR_TFS | SSSR_ROR;
 	}
@@ -1212,35 +2081,79 @@
 	drv_data->tx_channel = -1;
 	drv_data->rx_channel = -1;
 	if (platform_info->enable_dma) {
-		status = pxa2xx_spi_dma_setup(drv_data);
-		if (status) {
-			dev_warn(dev, "failed to setup DMA, using PIO\n");
-			platform_info->enable_dma = false;
+
+		/* Get two DMA channels	(rx and tx) */
+		drv_data->rx_channel = pxa_request_dma("pxa2xx_spi_ssp_rx",
+							DMA_PRIO_HIGH,
+							dma_handler,
+							drv_data);
+		if (drv_data->rx_channel < 0) {
+			dev_err(dev, "problem (%d) requesting rx channel\n",
+				drv_data->rx_channel);
+			status = -ENODEV;
+			goto out_error_irq_alloc;
+		}
+		drv_data->tx_channel = pxa_request_dma("pxa2xx_spi_ssp_tx",
+							DMA_PRIO_MEDIUM,
+							dma_handler,
+							drv_data);
+		if (drv_data->tx_channel < 0) {
+			dev_err(dev, "problem (%d) requesting tx channel\n",
+				drv_data->tx_channel);
+			status = -ENODEV;
+			goto out_error_dma_alloc;
 		}
+
+		DRCMR(ssp->drcmr_rx) = DRCMR_MAPVLD | drv_data->rx_channel;
+		DRCMR(ssp->drcmr_tx) = DRCMR_MAPVLD | drv_data->tx_channel;
 	}
 
 	/* Enable SOC clock */
-	clk_prepare_enable(ssp->clk);
-
-	drv_data->max_clk_rate = clk_get_rate(ssp->clk);
+	clk_enable(ssp->clk);
 
 	/* Load default SSP configuration */
-	write_SSCR0(0, drv_data->ioaddr);
-	write_SSCR1(SSCR1_RxTresh(RX_THRESH_DFLT) |
-				SSCR1_TxTresh(TX_THRESH_DFLT),
-				drv_data->ioaddr);
-	write_SSCR0(SSCR0_SCR(2)
-			| SSCR0_Motorola
-			| SSCR0_DataSize(8),
-			drv_data->ioaddr);
+	write_sscr0(0, drv_data->ioaddr);
+	switch (drv_data->ssp_type) {
+	case CE5X00_SSP:
+		write_sscr1(CE5X00_SSCR1_RxTresh(RX_THRESH_CE5X00_DFLT) |
+			    CE5X00_SSCR1_TxTresh(TX_THRESH_CE5X00_DFLT),
+			    drv_data->ioaddr);
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+		/* using the Motorola SPI protocol and use 8 bit frame */
+		write_sscr0(CE5X00_SSCR0_Motorola
+			    | CE5X00_SSCR0_DataSize(8),
+			    drv_data->ioaddr);
+#else
+		/* default using Motorola SPI protocol and use 8 bit frame */
+		write_sscr0(SSCR0_SCR(2)
+			    | CE5X00_SSCR0_Motorola
+			    | CE5X00_SSCR0_DataSize(8),
+			    drv_data->ioaddr);
+#endif
+		break;
+	case CE4100_SSP:
+	case PXA25x_SSP:
+	default:
+		write_sscr1(SSCR1_RxTresh(RX_THRESH_DFLT) |
+			    SSCR1_TxTresh(TX_THRESH_DFLT),
+			    drv_data->ioaddr);
+		write_sscr0(SSCR0_SCR(2)
+			    | SSCR0_Motorola
+			    | SSCR0_DataSize(8),
+			    drv_data->ioaddr);
+	}
 	if (!pxa25x_ssp_comp(drv_data))
-		write_SSTO(0, drv_data->ioaddr);
-	write_SSPSP(0, drv_data->ioaddr);
-
-	lpss_ssp_setup(drv_data);
+		write_ssto(0, drv_data->ioaddr);
+#ifndef CONFIG_GEN3_SPI
+	/*
+	 *  SSPSP register is resrved on the CEXXXX SOCs.
+	 */
+	write_sspsp(0, drv_data->ioaddr);
+#endif
 
-	tasklet_init(&drv_data->pump_transfers, pump_transfers,
-		     (unsigned long)drv_data);
+	/* Initialise transfer pump */
+	tasklet_init(&drv_data->pump_transfers,
+			pump_transfers,	(unsigned long)drv_data);
 
 	/* Register with the SPI framework */
 	platform_set_drvdata(pdev, drv_data);
@@ -1250,16 +2163,18 @@
 		goto out_error_clock_enabled;
 	}
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
-
 	return status;
 
 out_error_clock_enabled:
-	clk_disable_unprepare(ssp->clk);
-	pxa2xx_spi_dma_release(drv_data);
+	clk_disable(ssp->clk);
+
+out_error_dma_alloc:
+	if (drv_data->tx_channel != -1)
+		pxa_free_dma(drv_data->tx_channel);
+	if (drv_data->rx_channel != -1)
+		pxa_free_dma(drv_data->rx_channel);
+
+out_error_irq_alloc:
 	free_irq(ssp->irq, drv_data);
 
 out_error_master_alloc:
@@ -1277,18 +2192,17 @@
 		return 0;
 	ssp = drv_data->ssp;
 
-	pm_runtime_get_sync(&pdev->dev);
-
 	/* Disable the SSP at the peripheral and SOC level */
-	write_SSCR0(0, drv_data->ioaddr);
-	clk_disable_unprepare(ssp->clk);
+	write_sscr0(0, drv_data->ioaddr);
+	clk_disable(ssp->clk);
 
 	/* Release DMA */
-	if (drv_data->master_info->enable_dma)
-		pxa2xx_spi_dma_release(drv_data);
-
-	pm_runtime_put_noidle(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
+	if (drv_data->master_info->enable_dma) {
+		DRCMR(ssp->drcmr_rx) = 0;
+		DRCMR(ssp->drcmr_tx) = 0;
+		pxa_free_dma(drv_data->tx_channel);
+		pxa_free_dma(drv_data->rx_channel);
+	}
 
 	/* Release IRQ */
 	free_irq(ssp->irq, drv_data);
@@ -1296,6 +2210,9 @@
 	/* Release SSP */
 	pxa_ssp_free(ssp);
 
+	/* Disable transfer pump */
+	tasklet_disable(&drv_data->pump_transfers);
+
 	/* Disconnect from the SPI framework */
 	spi_unregister_master(drv_data->master);
 
@@ -1309,7 +2226,8 @@
 {
 	int status = 0;
 
-	if ((status = pxa2xx_spi_remove(pdev)) != 0)
+	status = pxa2xx_spi_remove(pdev);
+	if (status != 0)
 		dev_err(&pdev->dev, "shutdown failed with %d\n", status);
 }
 
@@ -1321,10 +2239,15 @@
 	int status = 0;
 
 	status = spi_master_suspend(drv_data->master);
-	if (status != 0)
+	if (status) {
+		dev_warn(dev, "cannot suspend master\n");
 		return status;
-	write_SSCR0(0, drv_data->ioaddr);
-	clk_disable_unprepare(ssp->clk);
+	}
+
+	pm_runtime_get_sync(dev);
+
+	write_sscr0(0, drv_data->ioaddr);
+	clk_disable(ssp->clk);
 
 	return 0;
 }
@@ -1335,52 +2258,39 @@
 	struct ssp_device *ssp = drv_data->ssp;
 	int status = 0;
 
-	pxa2xx_spi_dma_resume(drv_data);
+	if (drv_data->rx_channel != -1)
+		DRCMR(drv_data->ssp->drcmr_rx) =
+			DRCMR_MAPVLD | drv_data->rx_channel;
+	if (drv_data->tx_channel != -1)
+		DRCMR(drv_data->ssp->drcmr_tx) =
+			DRCMR_MAPVLD | drv_data->tx_channel;
 
 	/* Enable the SSP clock */
-	clk_prepare_enable(ssp->clk);
+	clk_enable(ssp->clk);
+
+	pm_runtime_put(dev);
 
 	/* Start the queue running */
 	status = spi_master_resume(drv_data->master);
-	if (status != 0) {
+	if (status)
 		dev_err(dev, "problem starting queue (%d)\n", status);
-		return status;
-	}
 
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_PM_RUNTIME
-static int pxa2xx_spi_runtime_suspend(struct device *dev)
-{
-	struct driver_data *drv_data = dev_get_drvdata(dev);
-
-	clk_disable_unprepare(drv_data->ssp->clk);
-	return 0;
-}
-
-static int pxa2xx_spi_runtime_resume(struct device *dev)
-{
-	struct driver_data *drv_data = dev_get_drvdata(dev);
-
-	clk_prepare_enable(drv_data->ssp->clk);
-	return 0;
+	return status;
 }
-#endif
 
 static const struct dev_pm_ops pxa2xx_spi_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pxa2xx_spi_suspend, pxa2xx_spi_resume)
-	SET_RUNTIME_PM_OPS(pxa2xx_spi_runtime_suspend,
-			   pxa2xx_spi_runtime_resume, NULL)
+	.suspend	= pxa2xx_spi_suspend,
+	.resume		= pxa2xx_spi_resume,
 };
+#endif
 
 static struct platform_driver driver = {
 	.driver = {
 		.name	= "pxa2xx-spi",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
 		.pm	= &pxa2xx_spi_pm_ops,
-		.acpi_match_table = ACPI_PTR(pxa2xx_spi_acpi_match),
+#endif
 	},
 	.probe = pxa2xx_spi_probe,
 	.remove = pxa2xx_spi_remove,
diff --git a/include/linux/pxa2xx_ssp.h b/include/linux/pxa2xx_ssp.h
index f366320..9810c71 100644
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@ -104,6 +104,28 @@
 #define SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..4] */
 #define SSCR1_RFT	(0x00000c00)	/* Receive FIFO Threshold (mask) */
 #define SSCR1_RxTresh(x) (((x) - 1) << 10) /* level [1..4] */
+
+/* CE5X00 SSCR0 bit definition */
+#define CE5X00_SSCR0_DSS	((1<<5)-1)	/* Data Size Select (mask) */
+#define CE5X00_SSCR0_DataSize(x)  ((x) - 1)	/* Data Size Select [4..32] */
+#define CE5X00_SSCR0_FRF	(((1<<2)-1) << 5)	/* FRame Format (mask) */
+#define CE5X00_SSCR0_Motorola	(0x0 << 5)	/* Motorola's Serial Peripheral Interface (SPI) */
+#define CE5X00_SSCR0_TI	(0x1 << 5)	/* Texas Instruments' Synchronous Serial Protocol (SSP) */
+#define CE5X00_SSCR0_National	(0x2 << 5)	/* National Microwire */
+
+#define RX_THRESH_CE5X00_DFLT	16
+#define TX_THRESH_CE5X00_DFLT	16
+
+#define CE5X00_SSSR_TFL_MASK	(0x1F << 8)	/* Transmit FIFO Level mask */
+#define CE5X00_SSSR_RFL_MASK	(0x1F << 13)	/* Receive FIFO Level mask */
+
+#define CE5X00_SSCR1_TFT	(((1<<5)-1) << 6)	/* Transmit FIFO Threshold (mask) */
+#define CE5X00_SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..32] */
+#define CE5X00_SSCR1_RFT	(((1<<5)-1) << 11)	/* Receive FIFO Threshold (mask) */
+#define CE5X00_SSCR1_RxTresh(x) (((x) - 1) << 11) /* level [1..32] */
+#define CE5X00_SSCR1_STRF       (1 << 17)	/* Select FIFO or EFWR */
+#define CE5X00_SSCR1_EFWR	(1 << 16)	/* Enable FIFO Write/Read */
+
 #endif
 
 /* extra bits in PXA255, PXA26x and PXA27x SSP ports */
@@ -172,7 +186,7 @@
 	PXA168_SSP,
 	PXA910_SSP,
 	CE4100_SSP,
-	LPSS_SSP,
+	CE5X00_SSP,
 };
 
 struct ssp_device {
@@ -190,6 +204,7 @@
 	int		irq;
 	int		drcmr_rx;
 	int		drcmr_tx;
+	struct pci_dev  *pcidev;
 };
 
 /**
@@ -215,15 +230,7 @@
 	return __raw_readl(dev->mmio_base + reg);
 }
 
-#ifdef CONFIG_ARCH_PXA
 struct ssp_device *pxa_ssp_request(int port, const char *label);
 void pxa_ssp_free(struct ssp_device *);
-#else
-static inline struct ssp_device *pxa_ssp_request(int port, const char *label)
-{
-	return NULL;
-}
-static inline void pxa_ssp_free(struct ssp_device *ssp) {}
-#endif
-
+int pxa_msi_enabled(void);
 #endif
diff --git a/include/linux/spi/pxa2xx_spi.h b/include/linux/spi/pxa2xx_spi.h
index c73d144..acac9ae 100644
--- a/include/linux/spi/pxa2xx_spi.h
+++ b/include/linux/spi/pxa2xx_spi.h
@@ -44,7 +35,6 @@
  */
 struct pxa2xx_spi_chip {
 	u8 tx_threshold;
-	u8 tx_hi_threshold;
 	u8 rx_threshold;
 	u8 dma_burst_size;
 	u32 timeout;
@@ -60,5 +50,92 @@
 
 extern void pxa2xx_set_spi_info(unsigned id, struct pxa2xx_spi_master *info);
 
+#else
+/*
+ * This is the implemtation for CE4100 on x86. ARM defines them in mach/ or
+ * plat/ include path.
+ * The CE4100 does not provide DMA support. This bits are here to let the driver
+ * compile and will never be used. Maybe we get DMA support at a later point in
+ * time.
+ */
+
+#define DCSR(n)         (n)
+#define DSADR(n)        (n)
+#define DTADR(n)        (n)
+#define DCMD(n)         (n)
+#define DRCMR(n)        (n)
+
+#define DCSR_RUN	(1 << 31)	/* Run Bit */
+#define DCSR_NODESC	(1 << 30)	/* No-Descriptor Fetch */
+#define DCSR_STOPIRQEN	(1 << 29)	/* Stop Interrupt Enable */
+#define DCSR_REQPEND	(1 << 8)	/* Request Pending (read-only) */
+#define DCSR_STOPSTATE	(1 << 3)	/* Stop State (read-only) */
+#define DCSR_ENDINTR	(1 << 2)	/* End Interrupt */
+#define DCSR_STARTINTR	(1 << 1)	/* Start Interrupt */
+#define DCSR_BUSERR	(1 << 0)	/* Bus Error Interrupt */
+
+#define DCSR_EORIRQEN	(1 << 28)	/* End of Receive Interrupt Enable */
+#define DCSR_EORJMPEN	(1 << 27)	/* Jump to next descriptor on EOR */
+#define DCSR_EORSTOPEN	(1 << 26)	/* STOP on an EOR */
+#define DCSR_SETCMPST	(1 << 25)	/* Set Descriptor Compare Status */
+#define DCSR_CLRCMPST	(1 << 24)	/* Clear Descriptor Compare Status */
+#define DCSR_CMPST	(1 << 10)	/* The Descriptor Compare Status */
+#define DCSR_EORINTR	(1 << 9)	/* The end of Receive */
+
+#define DRCMR_MAPVLD	(1 << 7)	/* Map Valid */
+#define DRCMR_CHLNUM	0x1f		/* mask for Channel Number */
+
+#define DDADR_DESCADDR	0xfffffff0	/* Address of next descriptor */
+#define DDADR_STOP	(1 << 0)	/* Stop */
+
+#define DCMD_INCSRCADDR	(1 << 31)	/* Source Address Increment Setting. */
+#define DCMD_INCTRGADDR	(1 << 30)	/* Target Address Increment Setting. */
+#define DCMD_FLOWSRC	(1 << 29)	/* Flow Control by the source. */
+#define DCMD_FLOWTRG	(1 << 28)	/* Flow Control by the target. */
+#define DCMD_STARTIRQEN	(1 << 22)	/* Start Interrupt Enable */
+#define DCMD_ENDIRQEN	(1 << 21)	/* End Interrupt Enable */
+#define DCMD_ENDIAN	(1 << 18)	/* Device Endian-ness. */
+#define DCMD_BURST8	(1 << 16)	/* 8 byte burst */
+#define DCMD_BURST16	(2 << 16)	/* 16 byte burst */
+#define DCMD_BURST32	(3 << 16)	/* 32 byte burst */
+#define DCMD_WIDTH1	(1 << 14)	/* 1 byte width */
+#define DCMD_WIDTH2	(2 << 14)	/* 2 byte width (HalfWord) */
+#define DCMD_WIDTH4	(3 << 14)	/* 4 byte width (Word) */
+#define DCMD_LENGTH	0x01fff		/* length mask (max = 8K - 1) */
+
+/*
+ * Descriptor structure for PXA's DMA engine
+ * Note: this structure must always be aligned to a 16-byte boundary.
+ */
+
+typedef enum {
+	DMA_PRIO_HIGH = 0,
+	DMA_PRIO_MEDIUM = 1,
+	DMA_PRIO_LOW = 2
+} pxa_dma_prio;
+
+/*
+ * DMA registration
+ */
+
+static inline int pxa_request_dma(char *name,
+		pxa_dma_prio prio,
+		void (*irq_handler)(int, void *),
+		void *data)
+{
+	return -ENODEV;
+}
+
+static inline void pxa_free_dma(int dma_ch)
+{
+}
+
+#ifndef CONFIG_GEN3_SPI
+static inline unsigned long clk_get_rate(struct clk *clk)
+{
+	return 3686400;
+}
+#endif
+
 #endif
 #endif
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f629189..307d218 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -80,6 +80,8 @@ struct spi_device {
 #define	SPI_MODE_2	(SPI_CPOL|0)
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
+#define SPI_MODE_QUAD_IO 0x05                   /* Quad IO mode using 4 wire */
+#define SPI_MODE_DUAL_IO 0x06                   /* Dual IO mode using 2 wire */
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
 #define	SPI_3WIRE	0x10			/* SI/SO signals shared */
 #define	SPI_LOOP	0x20			/* loopback mode */
-- 
1.7.4.1

